=== modified file 'configure.ac'
Index: gnome-control-center/configure.ac
===================================================================
--- gnome-control-center.orig/configure.ac	2012-02-10 14:39:56.993601000 -0500
+++ gnome-control-center/configure.ac	2012-02-10 14:39:56.993601000 -0500
@@ -337,6 +337,9 @@
 panels/online-accounts/icons/32x32/Makefile
 panels/online-accounts/icons/48x48/Makefile
 panels/online-accounts/icons/256x256/Makefile
+panels/sound-nua/Makefile
+panels/sound-nua/data/Makefile
+panels/sound-nua/data/gnome-sound-nua-panel.desktop.in
 panels/sound/Makefile
 panels/sound/data/Makefile
 panels/sound/data/gnome-sound-panel.desktop.in
Index: gnome-control-center/panels/Makefile.am
===================================================================
--- gnome-control-center.orig/panels/Makefile.am	2012-02-10 14:39:56.993601000 -0500
+++ gnome-control-center/panels/Makefile.am	2012-02-10 14:39:56.993601000 -0500
@@ -11,6 +11,7 @@
 	region \
 	info \
 	sound \
+	sound-nua \
 	keyboard \
 	universal-access \
 	user-accounts \
Index: gnome-control-center/panels/sound-nua/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/Makefile.am	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,93 @@
+SUBDIRS = data
+
+# This is used in PANEL_CFLAGS
+cappletname = sound
+NULL =
+
+ccpanelsdir = $(PANELS_DIR)
+ccpanels_LTLIBRARIES = libsoundnua.la
+
+AM_CPPFLAGS =					\
+	$(PANEL_CFLAGS) 			\
+	$(SOUND_PANEL_CFLAGS)			\
+	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
+	-DLIBEXECDIR=\"$(libexecdir)\"		\
+	-DGLADEDIR=\""$(pkgdatadir)"\"		\
+        -DSOUND_DATA_DIR="\"$(datadir)/sounds\""	\
+        -DSOUND_SET_DIR="\"$(pkgdatadir)/sounds\""	\
+	-DICON_DATA_DIR="\"$(pkgdatadir)/icons\"" \
+	$(NULL)
+
+noinst_LTLIBRARIES = libgnomevolumecontrol.la
+libgnomevolumecontrol_la_SOURCES =		\
+	gvc-mixer-card.h			\
+	gvc-mixer-card.c			\
+	gvc-mixer-card-private.h		\
+	gvc-mixer-stream.h			\
+	gvc-mixer-stream.c			\
+	gvc-mixer-stream-private.h		\
+	gvc-mixer-ui-device.h			\
+	gvc-mixer-ui-device.c			\
+	gvc-channel-map.h			\
+	gvc-channel-map.c			\
+	gvc-channel-map-private.h		\
+	gvc-mixer-sink.h			\
+	gvc-mixer-sink.c			\
+	gvc-mixer-source.h			\
+	gvc-mixer-source.c			\
+	gvc-mixer-sink-input.h			\
+	gvc-mixer-sink-input.c			\
+	gvc-mixer-source-output.h		\
+	gvc-mixer-source-output.c		\
+	gvc-mixer-event-role.h			\
+	gvc-mixer-event-role.c			\
+	gvc-mixer-control.h			\
+	gvc-mixer-control.c			\
+	gvc-mixer-control-private.h		\
+	gvc-channel-bar.h			\
+	gvc-channel-bar.c			\
+	gvc-pulseaudio-fake.h			\
+	$(NULL)
+
+libsoundnua_la_LIBADD =				\
+	-lm					\
+	libgnomevolumecontrol.la		\
+	$(PANEL_LIBS)				\
+	$(SOUND_PANEL_LIBS)			\
+	$(NULL)
+
+libsoundnua_la_LDFLAGS =				\
+	$(PANEL_LDFLAGS)			\
+	$(NULL)
+
+libsoundnua_la_SOURCES =				\
+	gvc-balance-bar.h			\
+	gvc-balance-bar.c			\
+	gvc-mixer-dialog.h			\
+	gvc-mixer-dialog.c			\
+	gvc-level-bar.h				\
+	gvc-level-bar.c				\
+	gvc-combo-box.h				\
+	gvc-combo-box.c				\
+	gvc-speaker-test.h			\
+	gvc-speaker-test.c			\
+	gvc-sound-theme-chooser.c		\
+	gvc-sound-theme-chooser.h		\
+	sound-theme-file-utils.c		\
+	sound-theme-file-utils.h		\
+	cc-sound-panel.c			\
+	cc-sound-panel.h			\
+	$(NULL)
+
+BUILT_SOURCES =				\
+	$(NULL)
+
+CLEANFILES =				\
+	$(BUILT_SOURCES)		\
+	$(NULL)
+
+MAINTAINERCLEANFILES =                  \
+        *~                              \
+        Makefile.in
+
+-include $(top_srcdir)/git.mk
Index: gnome-control-center/panels/sound-nua/Makefile.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/Makefile.in	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,939 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = panels/sound-nua
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/gnome-doc-utils.m4 \
+	$(top_srcdir)/m4/intltool.m4 $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(ccpanelsdir)"
+LTLIBRARIES = $(ccpanels_LTLIBRARIES) $(noinst_LTLIBRARIES)
+libgnomevolumecontrol_la_LIBADD =
+am__objects_1 =
+am_libgnomevolumecontrol_la_OBJECTS = gvc-mixer-card.lo \
+	gvc-mixer-stream.lo gvc-mixer-ui-device.lo gvc-channel-map.lo \
+	gvc-mixer-sink.lo gvc-mixer-source.lo gvc-mixer-sink-input.lo \
+	gvc-mixer-source-output.lo gvc-mixer-event-role.lo \
+	gvc-mixer-control.lo gvc-channel-bar.lo $(am__objects_1)
+libgnomevolumecontrol_la_OBJECTS =  \
+	$(am_libgnomevolumecontrol_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+am__DEPENDENCIES_1 =
+libsoundnua_la_DEPENDENCIES = libgnomevolumecontrol.la \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
+am_libsoundnua_la_OBJECTS = gvc-balance-bar.lo gvc-mixer-dialog.lo \
+	gvc-level-bar.lo gvc-combo-box.lo gvc-speaker-test.lo \
+	gvc-sound-theme-chooser.lo sound-theme-file-utils.lo \
+	cc-sound-panel.lo $(am__objects_1)
+libsoundnua_la_OBJECTS = $(am_libsoundnua_la_OBJECTS)
+libsoundnua_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libsoundnua_la_LDFLAGS) $(LDFLAGS) -o \
+	$@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo "  CC    " $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo "  CCLD  " $@;
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN   " $@;
+SOURCES = $(libgnomevolumecontrol_la_SOURCES) \
+	$(libsoundnua_la_SOURCES)
+DIST_SOURCES = $(libgnomevolumecontrol_la_SOURCES) \
+	$(libsoundnua_la_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+ALL_LINGUAS = @ALL_LINGUAS@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BACKGROUND_PANEL_CFLAGS = @BACKGROUND_PANEL_CFLAGS@
+BACKGROUND_PANEL_LIBS = @BACKGROUND_PANEL_LIBS@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CHEESE_CFLAGS = @CHEESE_CFLAGS@
+CHEESE_LIBS = @CHEESE_LIBS@
+COLOR_PANEL_CFLAGS = @COLOR_PANEL_CFLAGS@
+COLOR_PANEL_LIBS = @COLOR_PANEL_LIBS@
+CONTROL_CENTER_VERSION = @CONTROL_CENTER_VERSION@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CUPS_CFLAGS = @CUPS_CFLAGS@
+CUPS_CONFIG = @CUPS_CONFIG@
+CUPS_LIBS = @CUPS_LIBS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DATETIME_PANEL_CFLAGS = @DATETIME_PANEL_CFLAGS@
+DATETIME_PANEL_LIBS = @DATETIME_PANEL_LIBS@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DISABLE_DEPRECATED = @DISABLE_DEPRECATED@
+DISPLAY_PANEL_CFLAGS = @DISPLAY_PANEL_CFLAGS@
+DISPLAY_PANEL_LIBS = @DISPLAY_PANEL_LIBS@
+DISTCHECK_CONFIGURE_FLAGS = @DISTCHECK_CONFIGURE_FLAGS@
+DLLTOOL = @DLLTOOL@
+DOC_USER_FORMATS = @DOC_USER_FORMATS@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GDESKTOP_PREFIX = @GDESKTOP_PREFIX@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
+GLIB_MKENUMS = @GLIB_MKENUMS@
+GMSGFMT = @GMSGFMT@
+GREP = @GREP@
+HELP_DIR = @HELP_DIR@
+INFO_PANEL_CFLAGS = @INFO_PANEL_CFLAGS@
+INFO_PANEL_LIBS = @INFO_PANEL_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
+INTLTOOL_MERGE = @INTLTOOL_MERGE@
+INTLTOOL_PERL = @INTLTOOL_PERL@
+INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
+INTLTOOL_V_MERGE = @INTLTOOL_V_MERGE@
+INTLTOOL_V_MERGE_OPTIONS = @INTLTOOL_V_MERGE_OPTIONS@
+INTLTOOL__v_MERGE_ = @INTLTOOL__v_MERGE_@
+INTLTOOL__v_MERGE_0 = @INTLTOOL__v_MERGE_0@
+ISOCODES_CFLAGS = @ISOCODES_CFLAGS@
+ISOCODES_LIBS = @ISOCODES_LIBS@
+KEYBOARD_PANEL_CFLAGS = @KEYBOARD_PANEL_CFLAGS@
+KEYBOARD_PANEL_LIBS = @KEYBOARD_PANEL_LIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBGNOMECONTROLCENTER_AGE = @LIBGNOMECONTROLCENTER_AGE@
+LIBGNOMECONTROLCENTER_CURRENT = @LIBGNOMECONTROLCENTER_CURRENT@
+LIBGNOMECONTROLCENTER_REVISION = @LIBGNOMECONTROLCENTER_REVISION@
+LIBGNOME_CONTROL_CENTER_CFLAGS = @LIBGNOME_CONTROL_CENTER_CFLAGS@
+LIBGNOME_CONTROL_CENTER_LIBS = @LIBGNOME_CONTROL_CENTER_LIBS@
+LIBLANGUAGE_CFLAGS = @LIBLANGUAGE_CFLAGS@
+LIBLANGUAGE_LIBS = @LIBLANGUAGE_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBSHORTCUTS_CFLAGS = @LIBSHORTCUTS_CFLAGS@
+LIBSHORTCUTS_LIBS = @LIBSHORTCUTS_LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MEDIA_PANEL_CFLAGS = @MEDIA_PANEL_CFLAGS@
+MEDIA_PANEL_LIBS = @MEDIA_PANEL_LIBS@
+MKDIR_P = @MKDIR_P@
+MOUSE_PANEL_CFLAGS = @MOUSE_PANEL_CFLAGS@
+MOUSE_PANEL_LIBS = @MOUSE_PANEL_LIBS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+NETWORK_MANAGER_CFLAGS = @NETWORK_MANAGER_CFLAGS@
+NETWORK_MANAGER_LIBS = @NETWORK_MANAGER_LIBS@
+NETWORK_PANEL_CFLAGS = @NETWORK_PANEL_CFLAGS@
+NETWORK_PANEL_LIBS = @NETWORK_PANEL_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OMF_DIR = @OMF_DIR@
+ONLINE_ACCOUNTS_PANEL_CFLAGS = @ONLINE_ACCOUNTS_PANEL_CFLAGS@
+ONLINE_ACCOUNTS_PANEL_LIBS = @ONLINE_ACCOUNTS_PANEL_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PANELS_DIR = @PANELS_DIR@
+PANEL_CFLAGS = @PANEL_CFLAGS@
+PANEL_LDFLAGS = @PANEL_LDFLAGS@
+PANEL_LIBS = @PANEL_LIBS@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+POWER_PANEL_CFLAGS = @POWER_PANEL_CFLAGS@
+POWER_PANEL_LIBS = @POWER_PANEL_LIBS@
+PRINTERS_PANEL_CFLAGS = @PRINTERS_PANEL_CFLAGS@
+PRINTERS_PANEL_LIBS = @PRINTERS_PANEL_LIBS@
+RANLIB = @RANLIB@
+REGION_PANEL_CFLAGS = @REGION_PANEL_CFLAGS@
+REGION_PANEL_LIBS = @REGION_PANEL_LIBS@
+SCREEN_PANEL_CFLAGS = @SCREEN_PANEL_CFLAGS@
+SCREEN_PANEL_LIBS = @SCREEN_PANEL_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SHELL_CFLAGS = @SHELL_CFLAGS@
+SHELL_LIBS = @SHELL_LIBS@
+SOCIALWEB_CFLAGS = @SOCIALWEB_CFLAGS@
+SOCIALWEB_LIBS = @SOCIALWEB_LIBS@
+SOUND_PANEL_CFLAGS = @SOUND_PANEL_CFLAGS@
+SOUND_PANEL_LIBS = @SOUND_PANEL_LIBS@
+STRIP = @STRIP@
+UNIVERSAL_ACCESS_PANEL_CFLAGS = @UNIVERSAL_ACCESS_PANEL_CFLAGS@
+UNIVERSAL_ACCESS_PANEL_LIBS = @UNIVERSAL_ACCESS_PANEL_LIBS@
+UPDATE_MIME_DATABASE = @UPDATE_MIME_DATABASE@
+USER_ACCOUNTS_PANEL_CFLAGS = @USER_ACCOUNTS_PANEL_CFLAGS@
+USER_ACCOUNTS_PANEL_LIBS = @USER_ACCOUNTS_PANEL_LIBS@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+WACOM_PANEL_CFLAGS = @WACOM_PANEL_CFLAGS@
+WACOM_PANEL_LIBS = @WACOM_PANEL_LIBS@
+WARN_CFLAGS = @WARN_CFLAGS@
+XF86MISC_LIBS = @XF86MISC_LIBS@
+XGETTEXT = @XGETTEXT@
+XMKMF = @XMKMF@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+intltool__v_merge_options_ = @intltool__v_merge_options_@
+intltool__v_merge_options_0 = @intltool__v_merge_options_0@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = data
+
+# This is used in PANEL_CFLAGS
+cappletname = sound
+NULL = 
+ccpanelsdir = $(PANELS_DIR)
+ccpanels_LTLIBRARIES = libsoundnua.la
+AM_CPPFLAGS = \
+	$(PANEL_CFLAGS) 			\
+	$(SOUND_PANEL_CFLAGS)			\
+	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
+	-DLIBEXECDIR=\"$(libexecdir)\"		\
+	-DGLADEDIR=\""$(pkgdatadir)"\"		\
+        -DSOUND_DATA_DIR="\"$(datadir)/sounds\""	\
+        -DSOUND_SET_DIR="\"$(pkgdatadir)/sounds\""	\
+	-DICON_DATA_DIR="\"$(pkgdatadir)/icons\"" \
+	$(NULL)
+
+noinst_LTLIBRARIES = libgnomevolumecontrol.la
+libgnomevolumecontrol_la_SOURCES = \
+	gvc-mixer-card.h			\
+	gvc-mixer-card.c			\
+	gvc-mixer-card-private.h		\
+	gvc-mixer-stream.h			\
+	gvc-mixer-stream.c			\
+	gvc-mixer-stream-private.h		\
+	gvc-mixer-ui-device.h			\
+	gvc-mixer-ui-device.c			\
+	gvc-channel-map.h			\
+	gvc-channel-map.c			\
+	gvc-channel-map-private.h		\
+	gvc-mixer-sink.h			\
+	gvc-mixer-sink.c			\
+	gvc-mixer-source.h			\
+	gvc-mixer-source.c			\
+	gvc-mixer-sink-input.h			\
+	gvc-mixer-sink-input.c			\
+	gvc-mixer-source-output.h		\
+	gvc-mixer-source-output.c		\
+	gvc-mixer-event-role.h			\
+	gvc-mixer-event-role.c			\
+	gvc-mixer-control.h			\
+	gvc-mixer-control.c			\
+	gvc-mixer-control-private.h		\
+	gvc-channel-bar.h			\
+	gvc-channel-bar.c			\
+	gvc-pulseaudio-fake.h			\
+	$(NULL)
+
+libsoundnua_la_LIBADD = \
+	-lm					\
+	libgnomevolumecontrol.la		\
+	$(PANEL_LIBS)				\
+	$(SOUND_PANEL_LIBS)			\
+	$(NULL)
+
+libsoundnua_la_LDFLAGS = \
+	$(PANEL_LDFLAGS)			\
+	$(NULL)
+
+libsoundnua_la_SOURCES = \
+	gvc-balance-bar.h			\
+	gvc-balance-bar.c			\
+	gvc-mixer-dialog.h			\
+	gvc-mixer-dialog.c			\
+	gvc-level-bar.h				\
+	gvc-level-bar.c				\
+	gvc-combo-box.h				\
+	gvc-combo-box.c				\
+	gvc-speaker-test.h			\
+	gvc-speaker-test.c			\
+	gvc-sound-theme-chooser.c		\
+	gvc-sound-theme-chooser.h		\
+	sound-theme-file-utils.c		\
+	sound-theme-file-utils.h		\
+	cc-sound-panel.c			\
+	cc-sound-panel.h			\
+	$(NULL)
+
+BUILT_SOURCES = \
+	$(NULL)
+
+CLEANFILES = \
+	$(BUILT_SOURCES)		\
+	$(NULL)
+
+MAINTAINERCLEANFILES = \
+        *~                              \
+        Makefile.in
+
+all: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu panels/sound-nua/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu panels/sound-nua/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-ccpanelsLTLIBRARIES: $(ccpanels_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(ccpanelsdir)" || $(MKDIR_P) "$(DESTDIR)$(ccpanelsdir)"
+	@list='$(ccpanels_LTLIBRARIES)'; test -n "$(ccpanelsdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(ccpanelsdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(ccpanelsdir)"; \
+	}
+
+uninstall-ccpanelsLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(ccpanels_LTLIBRARIES)'; test -n "$(ccpanelsdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(ccpanelsdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(ccpanelsdir)/$$f"; \
+	done
+
+clean-ccpanelsLTLIBRARIES:
+	-test -z "$(ccpanels_LTLIBRARIES)" || rm -f $(ccpanels_LTLIBRARIES)
+	@list='$(ccpanels_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libgnomevolumecontrol.la: $(libgnomevolumecontrol_la_OBJECTS) $(libgnomevolumecontrol_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK)  $(libgnomevolumecontrol_la_OBJECTS) $(libgnomevolumecontrol_la_LIBADD) $(LIBS)
+libsoundnua.la: $(libsoundnua_la_OBJECTS) $(libsoundnua_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libsoundnua_la_LINK) -rpath $(ccpanelsdir) $(libsoundnua_la_OBJECTS) $(libsoundnua_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cc-sound-panel.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-balance-bar.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-channel-bar.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-channel-map.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-combo-box.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-level-bar.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-card.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-control.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-dialog.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-event-role.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-sink-input.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-sink.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-source-output.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-source.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-stream.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-mixer-ui-device.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-sound-theme-chooser.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gvc-speaker-test.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sound-theme-file-utils.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-recursive
+all-am: Makefile $(LTLIBRARIES)
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(ccpanelsdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-recursive
+
+clean-am: clean-ccpanelsLTLIBRARIES clean-generic clean-libtool \
+	clean-noinstLTLIBRARIES mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-ccpanelsLTLIBRARIES
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-ccpanelsLTLIBRARIES
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check \
+	ctags-recursive install install-am install-strip \
+	tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-ccpanelsLTLIBRARIES \
+	clean-generic clean-libtool clean-noinstLTLIBRARIES ctags \
+	ctags-recursive distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am \
+	install-ccpanelsLTLIBRARIES install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am \
+	uninstall-ccpanelsLTLIBRARIES
+
+
+-include $(top_srcdir)/git.mk
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: gnome-control-center/panels/sound-nua/applet-main.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/applet-main.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,110 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include <libintl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <glib/gi18n.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gio/gio.h>
+
+#include "gvc-applet.h"
+#include "gvc-log.h"
+
+#define GVCA_DBUS_NAME "org.gnome.VolumeControlApplet"
+
+static gboolean show_version = FALSE;
+static gboolean debug = FALSE;
+
+int
+main (int argc, char **argv)
+{
+        GError             *error;
+        GvcApplet          *applet;
+        GApplication       *app = NULL;
+        static GOptionEntry entries[] = {
+                { "debug", 0, 0, G_OPTION_ARG_NONE, &debug, N_("Enable debugging code"), NULL },
+                { "version", 0, 0, G_OPTION_ARG_NONE, &show_version, N_("Version of this application"), NULL },
+                { NULL, 0, 0, 0, NULL, NULL, NULL }
+        };
+
+        bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
+        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+        textdomain (GETTEXT_PACKAGE);
+
+        gvc_log_init ();
+
+        error = NULL;
+        gtk_init_with_args (&argc, &argv,
+                            (char *) _(" â€” GNOME Volume Control Applet"),
+                            entries, GETTEXT_PACKAGE,
+                            &error);
+
+        if (error != NULL) {
+                g_warning ("%s", error->message);
+                exit (1);
+        }
+
+        if (show_version) {
+                g_print ("%s %s\n", argv [0], VERSION);
+                exit (1);
+        }
+
+        gvc_log_set_debug (debug);
+
+        if (debug == FALSE) {
+                GError *error = NULL;
+
+                app = g_application_new (GVCA_DBUS_NAME,
+                                         G_APPLICATION_FLAGS_NONE);
+                if (!g_application_register (app, NULL, &error)) {
+                       g_warning ("%s", error->message);
+                       g_error_free (error);
+                       return 1;
+                }
+                if (g_application_get_is_remote (app)) {
+                        g_warning ("Applet is already running, exiting");
+                        return 0;
+                }
+        }
+
+        gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (),
+                                           ICON_DATA_DIR);
+
+        applet = gvc_applet_new ();
+        gvc_applet_start (applet);
+
+        gtk_main ();
+
+        if (applet != NULL) {
+                g_object_unref (applet);
+        }
+        if (app != NULL) {
+                g_object_unref (app);
+        }
+
+        return 0;
+}
Index: gnome-control-center/panels/sound-nua/cc-sound-panel.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/cc-sound-panel.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,141 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include <libintl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <glib/gi18n-lib.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "cc-sound-panel.h"
+#include "gvc-mixer-dialog.h"
+
+G_DEFINE_DYNAMIC_TYPE (CcSoundNuaPanel, cc_sound_panel, CC_TYPE_PANEL)
+
+enum {
+        PROP_0,
+        PROP_ARGV
+};
+
+static void cc_sound_panel_finalize (GObject *object);
+
+static void
+cc_sound_panel_set_property (GObject      *object,
+                             guint         property_id,
+                             const GValue *value,
+                             GParamSpec   *pspec)
+{
+        CcSoundNuaPanel *self = CC_SOUND_PANEL (object);
+
+        switch (property_id) {
+        case PROP_ARGV: {
+                gchar **args;
+
+                args = g_value_get_boxed (value);
+
+                if (args && args[0]) {
+                        gvc_mixer_dialog_set_page (self->dialog, args[0]);
+                }
+                break;
+        }
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+        }
+}
+
+static void
+cc_sound_panel_class_init (CcSoundNuaPanelClass *klass)
+{
+        GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = cc_sound_panel_finalize;
+        object_class->set_property = cc_sound_panel_set_property;
+
+        g_object_class_override_property (object_class, PROP_ARGV, "argv");
+}
+
+static void
+cc_sound_panel_class_finalize (CcSoundNuaPanelClass *klass)
+{
+}
+
+static void
+cc_sound_panel_finalize (GObject *object)
+{
+        CcSoundNuaPanel *panel = CC_SOUND_PANEL (object);
+
+        if (panel->dialog != NULL)
+                panel->dialog = NULL;
+        if (panel->connecting_label != NULL)
+                panel->connecting_label = NULL;
+        if (panel->control != NULL) {
+                g_object_unref (panel->control);
+                panel->control = NULL;
+        }
+
+        G_OBJECT_CLASS (cc_sound_panel_parent_class)->finalize (object);
+}
+
+static void
+cc_sound_panel_init (CcSoundNuaPanel *self)
+{
+        gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (),
+                                           ICON_DATA_DIR);
+        gtk_window_set_default_icon_name ("multimedia-volume-control");
+
+        self->control = gvc_mixer_control_new ("GNOME Volume Control Dialog");
+        gvc_mixer_control_open (self->control);
+        self->dialog = gvc_mixer_dialog_new (self->control);
+        gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (self->dialog));
+        gtk_widget_show (GTK_WIDGET (self->dialog));
+}
+
+void
+cc_sound_panel_register (GIOModule *module)
+{
+        cc_sound_panel_register_type (G_TYPE_MODULE (module));
+        g_io_extension_point_implement (CC_SHELL_PANEL_EXTENSION_POINT,
+                                        CC_TYPE_SOUND_PANEL,
+                                        "sound-nua", 0);
+}
+
+/* GIO extension stuff */
+void
+g_io_module_load (GIOModule *module)
+{
+        bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
+        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+
+        /* register the panel */
+        cc_sound_panel_register (module);
+}
+
+void
+g_io_module_unload (GIOModule *module)
+{
+}
+
Index: gnome-control-center/panels/sound-nua/cc-sound-panel.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/cc-sound-panel.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,60 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _CC_SOUND_PANEL_H
+#define _CC_SOUND_PANEL_H
+
+#include <libgnome-control-center/cc-panel.h>
+#include "gvc-mixer-control.h"
+#include "gvc-mixer-dialog.h"
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SOUND_PANEL cc_sound_panel_get_type()
+#define CC_SOUND_PANEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CC_TYPE_SOUND_PANEL, CcSoundNuaPanel))
+#define CC_SOUND_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CC_TYPE_SOUND_PANEL, CcSoundNuaPanelClass))
+#define CC_IS_SOUND_PANEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CC_TYPE_SOUND_PANEL))
+#define CC_IS_SOUND_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CC_TYPE_SOUND_PANEL))
+#define CC_SOUND_PANEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CC_TYPE_SOUND_PANEL, CcSoundNuaPanelClass))
+
+typedef struct _CcSoundNuaPanel CcSoundNuaPanel;
+typedef struct _CcSoundNuaPanelClass CcSoundNuaPanelClass;
+typedef struct _CcSoundNuaPanelPrivate CcSoundNuaPanelPrivate;
+
+struct _CcSoundNuaPanel {
+	CcPanel parent;
+
+	GvcMixerControl *control;
+	GvcMixerDialog  *dialog;
+	GtkWidget       *connecting_label;
+};
+
+struct _CcSoundNuaPanelClass {
+	CcPanelClass parent_class;
+};
+
+GType cc_sound_panel_get_type (void) G_GNUC_CONST;
+
+void  cc_sound_panel_register (GIOModule *module);
+
+G_END_DECLS
+
+#endif /* _CC_SOUND_PANEL_H */
+
Index: gnome-control-center/panels/sound-nua/data/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/data/Makefile.am	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,17 @@
+NULL =
+
+@INTLTOOL_DESKTOP_RULE@
+
+appsdir = $(datadir)/applications
+apps_in_files = gnome-sound-nua-panel.desktop.in
+apps_DATA = $(apps_in_files:.desktop.in=.desktop)
+
+EXTRA_DIST =					\
+	gnome-sound-nua-panel.desktop.in.in		\
+	$(NULL)
+
+CLEANFILES =					\
+	gnome-sound-nua-panel.desktop		\
+	$(NULL)
+
+-include $(top_srcdir)/git.mk
Index: gnome-control-center/panels/sound-nua/data/Makefile.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/data/Makefile.in	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,529 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = panels/sound-nua/data
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/gnome-sound-nua-panel.desktop.in.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/gnome-doc-utils.m4 \
+	$(top_srcdir)/m4/intltool.m4 $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES = gnome-sound-nua-panel.desktop.in
+CONFIG_CLEAN_VPATH_FILES =
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN   " $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(appsdir)"
+DATA = $(apps_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALL_LINGUAS = @ALL_LINGUAS@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BACKGROUND_PANEL_CFLAGS = @BACKGROUND_PANEL_CFLAGS@
+BACKGROUND_PANEL_LIBS = @BACKGROUND_PANEL_LIBS@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CHEESE_CFLAGS = @CHEESE_CFLAGS@
+CHEESE_LIBS = @CHEESE_LIBS@
+COLOR_PANEL_CFLAGS = @COLOR_PANEL_CFLAGS@
+COLOR_PANEL_LIBS = @COLOR_PANEL_LIBS@
+CONTROL_CENTER_VERSION = @CONTROL_CENTER_VERSION@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CUPS_CFLAGS = @CUPS_CFLAGS@
+CUPS_CONFIG = @CUPS_CONFIG@
+CUPS_LIBS = @CUPS_LIBS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DATETIME_PANEL_CFLAGS = @DATETIME_PANEL_CFLAGS@
+DATETIME_PANEL_LIBS = @DATETIME_PANEL_LIBS@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DISABLE_DEPRECATED = @DISABLE_DEPRECATED@
+DISPLAY_PANEL_CFLAGS = @DISPLAY_PANEL_CFLAGS@
+DISPLAY_PANEL_LIBS = @DISPLAY_PANEL_LIBS@
+DISTCHECK_CONFIGURE_FLAGS = @DISTCHECK_CONFIGURE_FLAGS@
+DLLTOOL = @DLLTOOL@
+DOC_USER_FORMATS = @DOC_USER_FORMATS@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GDESKTOP_PREFIX = @GDESKTOP_PREFIX@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
+GLIB_MKENUMS = @GLIB_MKENUMS@
+GMSGFMT = @GMSGFMT@
+GREP = @GREP@
+HELP_DIR = @HELP_DIR@
+INFO_PANEL_CFLAGS = @INFO_PANEL_CFLAGS@
+INFO_PANEL_LIBS = @INFO_PANEL_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
+INTLTOOL_MERGE = @INTLTOOL_MERGE@
+INTLTOOL_PERL = @INTLTOOL_PERL@
+INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
+INTLTOOL_V_MERGE = @INTLTOOL_V_MERGE@
+INTLTOOL_V_MERGE_OPTIONS = @INTLTOOL_V_MERGE_OPTIONS@
+INTLTOOL__v_MERGE_ = @INTLTOOL__v_MERGE_@
+INTLTOOL__v_MERGE_0 = @INTLTOOL__v_MERGE_0@
+ISOCODES_CFLAGS = @ISOCODES_CFLAGS@
+ISOCODES_LIBS = @ISOCODES_LIBS@
+KEYBOARD_PANEL_CFLAGS = @KEYBOARD_PANEL_CFLAGS@
+KEYBOARD_PANEL_LIBS = @KEYBOARD_PANEL_LIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBGNOMECONTROLCENTER_AGE = @LIBGNOMECONTROLCENTER_AGE@
+LIBGNOMECONTROLCENTER_CURRENT = @LIBGNOMECONTROLCENTER_CURRENT@
+LIBGNOMECONTROLCENTER_REVISION = @LIBGNOMECONTROLCENTER_REVISION@
+LIBGNOME_CONTROL_CENTER_CFLAGS = @LIBGNOME_CONTROL_CENTER_CFLAGS@
+LIBGNOME_CONTROL_CENTER_LIBS = @LIBGNOME_CONTROL_CENTER_LIBS@
+LIBLANGUAGE_CFLAGS = @LIBLANGUAGE_CFLAGS@
+LIBLANGUAGE_LIBS = @LIBLANGUAGE_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBSHORTCUTS_CFLAGS = @LIBSHORTCUTS_CFLAGS@
+LIBSHORTCUTS_LIBS = @LIBSHORTCUTS_LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MEDIA_PANEL_CFLAGS = @MEDIA_PANEL_CFLAGS@
+MEDIA_PANEL_LIBS = @MEDIA_PANEL_LIBS@
+MKDIR_P = @MKDIR_P@
+MOUSE_PANEL_CFLAGS = @MOUSE_PANEL_CFLAGS@
+MOUSE_PANEL_LIBS = @MOUSE_PANEL_LIBS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+NETWORK_MANAGER_CFLAGS = @NETWORK_MANAGER_CFLAGS@
+NETWORK_MANAGER_LIBS = @NETWORK_MANAGER_LIBS@
+NETWORK_PANEL_CFLAGS = @NETWORK_PANEL_CFLAGS@
+NETWORK_PANEL_LIBS = @NETWORK_PANEL_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OMF_DIR = @OMF_DIR@
+ONLINE_ACCOUNTS_PANEL_CFLAGS = @ONLINE_ACCOUNTS_PANEL_CFLAGS@
+ONLINE_ACCOUNTS_PANEL_LIBS = @ONLINE_ACCOUNTS_PANEL_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PANELS_DIR = @PANELS_DIR@
+PANEL_CFLAGS = @PANEL_CFLAGS@
+PANEL_LDFLAGS = @PANEL_LDFLAGS@
+PANEL_LIBS = @PANEL_LIBS@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+POWER_PANEL_CFLAGS = @POWER_PANEL_CFLAGS@
+POWER_PANEL_LIBS = @POWER_PANEL_LIBS@
+PRINTERS_PANEL_CFLAGS = @PRINTERS_PANEL_CFLAGS@
+PRINTERS_PANEL_LIBS = @PRINTERS_PANEL_LIBS@
+RANLIB = @RANLIB@
+REGION_PANEL_CFLAGS = @REGION_PANEL_CFLAGS@
+REGION_PANEL_LIBS = @REGION_PANEL_LIBS@
+SCREEN_PANEL_CFLAGS = @SCREEN_PANEL_CFLAGS@
+SCREEN_PANEL_LIBS = @SCREEN_PANEL_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SHELL_CFLAGS = @SHELL_CFLAGS@
+SHELL_LIBS = @SHELL_LIBS@
+SOCIALWEB_CFLAGS = @SOCIALWEB_CFLAGS@
+SOCIALWEB_LIBS = @SOCIALWEB_LIBS@
+SOUND_PANEL_CFLAGS = @SOUND_PANEL_CFLAGS@
+SOUND_PANEL_LIBS = @SOUND_PANEL_LIBS@
+STRIP = @STRIP@
+UNIVERSAL_ACCESS_PANEL_CFLAGS = @UNIVERSAL_ACCESS_PANEL_CFLAGS@
+UNIVERSAL_ACCESS_PANEL_LIBS = @UNIVERSAL_ACCESS_PANEL_LIBS@
+UPDATE_MIME_DATABASE = @UPDATE_MIME_DATABASE@
+USER_ACCOUNTS_PANEL_CFLAGS = @USER_ACCOUNTS_PANEL_CFLAGS@
+USER_ACCOUNTS_PANEL_LIBS = @USER_ACCOUNTS_PANEL_LIBS@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+WACOM_PANEL_CFLAGS = @WACOM_PANEL_CFLAGS@
+WACOM_PANEL_LIBS = @WACOM_PANEL_LIBS@
+WARN_CFLAGS = @WARN_CFLAGS@
+XF86MISC_LIBS = @XF86MISC_LIBS@
+XGETTEXT = @XGETTEXT@
+XMKMF = @XMKMF@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+intltool__v_merge_options_ = @intltool__v_merge_options_@
+intltool__v_merge_options_0 = @intltool__v_merge_options_0@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+NULL = 
+appsdir = $(datadir)/applications
+apps_in_files = gnome-sound-nua-panel.desktop.in
+apps_DATA = $(apps_in_files:.desktop.in=.desktop)
+EXTRA_DIST = \
+	gnome-sound-nua-panel.desktop.in.in		\
+	$(NULL)
+
+CLEANFILES = \
+	gnome-sound-nua-panel.desktop		\
+	$(NULL)
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu panels/sound-nua/data/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu panels/sound-nua/data/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+gnome-sound-nua-panel.desktop.in: $(top_builddir)/config.status $(srcdir)/gnome-sound-nua-panel.desktop.in.in
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-appsDATA: $(apps_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(appsdir)" || $(MKDIR_P) "$(DESTDIR)$(appsdir)"
+	@list='$(apps_DATA)'; test -n "$(appsdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(appsdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(appsdir)" || exit $$?; \
+	done
+
+uninstall-appsDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(apps_DATA)'; test -n "$(appsdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(appsdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(appsdir)" && rm -f $$files
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(appsdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-appsDATA
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-appsDATA
+
+.MAKE: install-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-appsDATA install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	uninstall uninstall-am uninstall-appsDATA
+
+
+@INTLTOOL_DESKTOP_RULE@
+
+-include $(top_srcdir)/git.mk
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: gnome-control-center/panels/sound-nua/data/gnome-sound-nua-panel.desktop.in.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/data/gnome-sound-nua-panel.desktop.in.in	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,17 @@
+[Desktop Entry]
+_Name=Sound
+_Comment=Change sound volume and sound events
+Exec=gnome-control-center sound-nua
+Icon=multimedia-volume-control
+Terminal=false
+Type=Application
+StartupNotify=true
+Categories=GNOME;GTK;Settings;HardwareSettings;X-GNOME-Settings-Panel;
+OnlyShowIn=Unity;
+X-GNOME-Bugzilla-Bugzilla=GNOME
+X-GNOME-Bugzilla-Product=gnome-control-center
+X-GNOME-Bugzilla-Component=sound
+X-GNOME-Bugzilla-Version=@VERSION@
+X-GNOME-Settings-Panel=sound-nua
+# Translators: those are keywords for the sound control-center panel
+_X-GNOME-Keywords=Card;Microphone;Volume;Fade;Balance;Bluetooth;Headset;
Index: gnome-control-center/panels/sound-nua/gvc-applet.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-applet.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,305 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-applet.h"
+#include "gvc-mixer-control.h"
+#include "gvc-stream-status-icon.h"
+
+#define GVC_APPLET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_APPLET, GvcAppletPrivate))
+
+#define SCALE_SIZE 128
+
+static const char *output_icon_names[] = {
+        "audio-volume-muted-symbolic",
+        "audio-volume-low-symbolic",
+        "audio-volume-medium-symbolic",
+        "audio-volume-high-symbolic",
+        NULL
+};
+
+static const char *input_icon_names[] = {
+        "audio-input-microphone-muted-symbolic",
+        "audio-input-microphone-low-symbolic",
+        "audio-input-microphone-medium-symbolic",
+        "audio-input-microphone-high-symbolic",
+        NULL
+};
+
+struct GvcAppletPrivate
+{
+        GvcStreamStatusIcon *input_status_icon;
+        GvcStreamStatusIcon *output_status_icon;
+        GvcMixerControl     *control;
+};
+
+static void     gvc_applet_class_init (GvcAppletClass *klass);
+static void     gvc_applet_init       (GvcApplet      *applet);
+static void     gvc_applet_finalize   (GObject        *object);
+
+G_DEFINE_TYPE (GvcApplet, gvc_applet, G_TYPE_OBJECT)
+
+static void
+maybe_show_status_icons (GvcApplet *applet)
+{
+        gboolean        show;
+        GvcMixerStream *stream;
+        GSList         *source_outputs, *l;
+
+        show = TRUE;
+        stream = gvc_mixer_control_get_default_sink (applet->priv->control);
+        if (stream == NULL) {
+                show = FALSE;
+        }
+        gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->output_status_icon), show);
+
+
+        show = FALSE;
+        stream = gvc_mixer_control_get_default_source (applet->priv->control);
+        source_outputs = gvc_mixer_control_get_source_outputs (applet->priv->control);
+        if (stream != NULL && source_outputs != NULL) {
+                /* Check that we're not trying to add the peak detector
+                 * as an application doing recording */
+                for (l = source_outputs ; l ; l = l->next) {
+                        GvcMixerStream *s = l->data;
+                        const char *id;
+
+                        id = gvc_mixer_stream_get_application_id (s);
+                        if (id == NULL) {
+                                show = TRUE;
+                                break;
+                        }
+
+                        if (!g_str_equal (id, "org.gnome.VolumeControl") &&
+                            !g_str_equal (id, "org.PulseAudio.pavucontrol")) {
+                                show = TRUE;
+                                break;
+                        }
+                }
+        }
+        gtk_status_icon_set_visible (GTK_STATUS_ICON (applet->priv->input_status_icon), show);
+
+        g_slist_free (source_outputs);
+}
+
+void
+gvc_applet_start (GvcApplet *applet)
+{
+        g_return_if_fail (GVC_IS_APPLET (applet));
+
+        maybe_show_status_icons (applet);
+}
+
+static void
+gvc_applet_dispose (GObject *object)
+{
+        GvcApplet *applet = GVC_APPLET (object);
+
+        if (applet->priv->control != NULL) {
+                g_object_unref (applet->priv->control);
+                applet->priv->control = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_applet_parent_class)->dispose (object);
+}
+
+static void
+update_default_source (GvcApplet *applet)
+{
+        GvcMixerStream *stream;
+
+        stream = gvc_mixer_control_get_default_source (applet->priv->control);
+        if (stream != NULL) {
+                gvc_stream_status_icon_set_mixer_stream (applet->priv->input_status_icon,
+                                                         stream);
+                maybe_show_status_icons(applet);
+        } else {
+                g_debug ("Unable to get default source, or no source available");
+        }
+}
+
+static void
+update_default_sink (GvcApplet *applet)
+{
+        GvcMixerStream *stream;
+
+        stream = gvc_mixer_control_get_default_sink (applet->priv->control);
+        if (stream != NULL) {
+                gvc_stream_status_icon_set_mixer_stream (applet->priv->output_status_icon,
+                                                         stream);
+                maybe_show_status_icons(applet);
+        } else {
+                g_warning ("Unable to get default sink");
+        }
+}
+
+static void
+on_control_state_changed (GvcMixerControl      *control,
+                          GvcMixerControlState  new_state,
+                          GvcApplet            *applet)
+{
+        if (new_state == GVC_STATE_READY)  {
+                update_default_sink (applet);
+                update_default_source (applet);
+        } else if (new_state == GVC_STATE_CONNECTING) {
+                g_debug ("Connecting...");
+        }
+}
+
+static void
+on_control_default_sink_changed (GvcMixerControl *control,
+                                 guint            id,
+                                 GvcApplet       *applet)
+{
+        update_default_sink (applet);
+}
+
+static void
+on_control_default_source_changed (GvcMixerControl *control,
+                                   guint            id,
+                                   GvcApplet       *applet)
+{
+        update_default_source (applet);
+}
+
+static void
+on_control_stream_removed (GvcMixerControl *control,
+                           guint            id,
+                           GvcApplet       *applet)
+{
+        maybe_show_status_icons (applet);
+}
+
+static void
+on_control_stream_added (GvcMixerControl *control,
+                         guint            id,
+                         GvcApplet       *applet)
+{
+        maybe_show_status_icons (applet);
+}
+
+static GObject *
+gvc_applet_constructor (GType                  type,
+                        guint                  n_construct_properties,
+                        GObjectConstructParam *construct_params)
+{
+        GObject   *object;
+        GvcApplet *self;
+
+        object = G_OBJECT_CLASS (gvc_applet_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_APPLET (object);
+
+        self->priv->control = gvc_mixer_control_new ("GNOME Volume Control Applet");
+        g_signal_connect (self->priv->control,
+                          "state-changed",
+                          G_CALLBACK (on_control_state_changed),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "default-sink-changed",
+                          G_CALLBACK (on_control_default_sink_changed),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "default-source-changed",
+                          G_CALLBACK (on_control_default_source_changed),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "stream-added",
+                          G_CALLBACK (on_control_stream_added),
+                          self);
+        g_signal_connect (self->priv->control,
+                          "stream-removed",
+                          G_CALLBACK (on_control_stream_removed),
+                          self);
+
+        gvc_mixer_control_open (self->priv->control);
+
+        return object;
+}
+
+static void
+gvc_applet_class_init (GvcAppletClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gvc_applet_finalize;
+        object_class->dispose = gvc_applet_dispose;
+        object_class->constructor = gvc_applet_constructor;
+
+        g_type_class_add_private (klass, sizeof (GvcAppletPrivate));
+}
+
+static void
+gvc_applet_init (GvcApplet *applet)
+{
+        applet->priv = GVC_APPLET_GET_PRIVATE (applet);
+
+        applet->priv->output_status_icon = gvc_stream_status_icon_new (NULL,
+                                                                       output_icon_names);
+        gvc_stream_status_icon_set_display_name (applet->priv->output_status_icon,
+                                                 _("Output"));
+        gtk_status_icon_set_title (GTK_STATUS_ICON (applet->priv->output_status_icon),
+                                   _("Sound Output Volume"));
+        applet->priv->input_status_icon = gvc_stream_status_icon_new (NULL,
+                                                                      input_icon_names);
+        gvc_stream_status_icon_set_display_name (applet->priv->input_status_icon,
+                                                 _("Input"));
+        gtk_status_icon_set_title (GTK_STATUS_ICON (applet->priv->input_status_icon),
+                                   _("Microphone Volume"));
+}
+
+static void
+gvc_applet_finalize (GObject *object)
+{
+        GvcApplet *applet;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_APPLET (object));
+
+        applet = GVC_APPLET (object);
+
+        g_return_if_fail (applet->priv != NULL);
+
+
+        G_OBJECT_CLASS (gvc_applet_parent_class)->finalize (object);
+}
+
+GvcApplet *
+gvc_applet_new (void)
+{
+        GObject *applet;
+
+        applet = g_object_new (GVC_TYPE_APPLET, NULL);
+
+        return GVC_APPLET (applet);
+}
Index: gnome-control-center/panels/sound-nua/gvc-applet.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-applet.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_APPLET_H
+#define __GVC_APPLET_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_APPLET         (gvc_applet_get_type ())
+#define GVC_APPLET(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_APPLET, GvcApplet))
+#define GVC_APPLET_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_APPLET, GvcAppletClass))
+#define GVC_IS_APPLET(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_APPLET))
+#define GVC_IS_APPLET_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_APPLET))
+#define GVC_APPLET_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_APPLET, GvcAppletClass))
+
+typedef struct GvcAppletPrivate GvcAppletPrivate;
+
+typedef struct
+{
+        GObject            parent;
+        GvcAppletPrivate *priv;
+} GvcApplet;
+
+typedef struct
+{
+        GObjectClass   parent_class;
+} GvcAppletClass;
+
+GType               gvc_applet_get_type            (void);
+
+GvcApplet *         gvc_applet_new                 (void);
+void                gvc_applet_start               (GvcApplet     *applet);
+
+G_END_DECLS
+
+#endif /* __GVC_APPLET_H */
Index: gnome-control-center/panels/sound-nua/gvc-balance-bar.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-balance-bar.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,556 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-balance-bar.h"
+#include "gvc-channel-map-private.h"
+
+#define SCALE_SIZE 220
+#define ADJUSTMENT_MAX_NORMAL 65536.0 /* PA_VOLUME_NORM */
+
+#define GVC_BALANCE_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_BALANCE_BAR, GvcBalanceBarPrivate))
+
+struct GvcBalanceBarPrivate
+{
+        GvcChannelMap *channel_map;
+        GvcBalanceType btype;
+        GtkWidget     *scale_box;
+        GtkWidget     *start_box;
+        GtkWidget     *end_box;
+        GtkWidget     *label;
+        GtkWidget     *scale;
+        GtkAdjustment *adjustment;
+        GtkSizeGroup  *size_group;
+        gboolean       symmetric;
+        gboolean       click_lock;
+};
+
+enum
+{
+        PROP_0,
+        PROP_CHANNEL_MAP,
+        PROP_BALANCE_TYPE,
+};
+
+static void     gvc_balance_bar_class_init (GvcBalanceBarClass *klass);
+static void     gvc_balance_bar_init       (GvcBalanceBar      *balance_bar);
+static void     gvc_balance_bar_finalize   (GObject            *object);
+
+static gboolean on_scale_button_press_event   (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcBalanceBar  *bar);
+static gboolean on_scale_button_release_event (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcBalanceBar  *bar);
+static gboolean on_scale_scroll_event         (GtkWidget      *widget,
+                                               GdkEventScroll *event,
+                                               GvcBalanceBar  *bar);
+static void on_adjustment_value_changed       (GtkAdjustment *adjustment,
+                                               GvcBalanceBar *bar);
+
+G_DEFINE_TYPE (GvcBalanceBar, gvc_balance_bar, GTK_TYPE_HBOX)
+
+static GtkWidget *
+_scale_box_new (GvcBalanceBar *bar)
+{
+        GvcBalanceBarPrivate *priv = bar->priv;
+        GtkWidget            *box;
+        GtkWidget            *sbox;
+        GtkWidget            *ebox;
+        GtkAdjustment        *adjustment = bar->priv->adjustment;
+        char                 *str_lower, *str_upper;
+        gdouble              lower, upper;
+
+        bar->priv->scale_box = box = gtk_box_new (FALSE, 6);
+        priv->scale = gtk_hscale_new (priv->adjustment);
+        gtk_widget_set_size_request (priv->scale, SCALE_SIZE, -1);
+        gtk_scale_set_has_origin (GTK_SCALE (priv->scale), FALSE);
+        gtk_widget_set_name (priv->scale, "balance-bar-scale");
+        gtk_rc_parse_string ("style \"balance-bar-scale-style\" {\n"
+                             " GtkScale::trough-side-details = 0\n"
+                             "}\n"
+                             "widget \"*.balance-bar-scale\" style : rc \"balance-bar-scale-style\"\n");
+
+        bar->priv->start_box = sbox = gtk_box_new (FALSE, 6);
+        gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (sbox), priv->label, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (box), priv->scale, TRUE, TRUE, 0);
+
+        switch (bar->priv->btype) {
+        case BALANCE_TYPE_RL:
+                str_lower = g_strdup_printf ("<small>%s</small>", C_("balance", "Left"));
+                str_upper = g_strdup_printf ("<small>%s</small>", C_("balance", "Right"));
+                break;
+        case BALANCE_TYPE_FR:
+                str_lower = g_strdup_printf ("<small>%s</small>", C_("balance", "Rear"));
+                str_upper = g_strdup_printf ("<small>%s</small>", C_("balance", "Front"));
+                break;
+        case BALANCE_TYPE_LFE:
+                str_lower = g_strdup_printf ("<small>%s</small>", C_("balance", "Minimum"));
+                str_upper = g_strdup_printf ("<small>%s</small>", C_("balance", "Maximum"));
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        lower = gtk_adjustment_get_lower (adjustment);
+        gtk_scale_add_mark (GTK_SCALE (priv->scale), lower,
+                            GTK_POS_BOTTOM, str_lower);
+        g_free (str_lower);
+        upper = gtk_adjustment_get_upper (adjustment);
+        gtk_scale_add_mark (GTK_SCALE (priv->scale), upper,
+                            GTK_POS_BOTTOM, str_upper);
+        g_free (str_upper);
+
+        if (bar->priv->btype != BALANCE_TYPE_LFE) {
+                gtk_scale_add_mark (GTK_SCALE (priv->scale),
+                                    (upper - lower)/2 + lower,
+                                    GTK_POS_BOTTOM, NULL);
+        }
+
+        bar->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+        gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+        ca_gtk_widget_disable_sounds (bar->priv->scale, FALSE);
+        gtk_widget_add_events (bar->priv->scale, GDK_SCROLL_MASK);
+
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-press-event",
+                          G_CALLBACK (on_scale_button_press_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-release-event",
+                          G_CALLBACK (on_scale_button_release_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "scroll-event",
+                          G_CALLBACK (on_scale_scroll_event), bar);
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group, sbox);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group, ebox);
+                }
+        }
+
+        gtk_scale_set_draw_value (GTK_SCALE (priv->scale), FALSE);
+
+        return box;
+}
+
+void
+gvc_balance_bar_set_size_group (GvcBalanceBar *bar,
+                                GtkSizeGroup  *group,
+                                gboolean       symmetric)
+{
+        g_return_if_fail (GVC_IS_BALANCE_BAR (bar));
+
+        bar->priv->size_group = group;
+        bar->priv->symmetric = symmetric;
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group,
+                                           bar->priv->start_box);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group,
+                                                   bar->priv->end_box);
+                }
+        }
+        gtk_widget_queue_draw (GTK_WIDGET (bar));
+}
+
+static const char *
+btype_to_string (guint btype)
+{
+        switch (btype) {
+        case BALANCE_TYPE_RL:
+                return "Balance";
+        case BALANCE_TYPE_FR:
+                return "Fade";
+                break;
+        case BALANCE_TYPE_LFE:
+                return "LFE";
+        default:
+                g_assert_not_reached ();
+        }
+        return NULL;
+}
+
+static void
+update_level_from_map (GvcBalanceBar *bar,
+                       GvcChannelMap *map)
+{
+        const gdouble *volumes;
+        gdouble val;
+
+        g_debug ("Volume changed (for %s bar)", btype_to_string (bar->priv->btype));
+
+        volumes = gvc_channel_map_get_volume (map);
+        switch (bar->priv->btype) {
+        case BALANCE_TYPE_RL:
+                val = volumes[BALANCE];
+                break;
+        case BALANCE_TYPE_FR:
+                val = volumes[FADE];
+                break;
+        case BALANCE_TYPE_LFE:
+                val = volumes[LFE];
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        gtk_adjustment_set_value (bar->priv->adjustment, val);
+}
+
+static void
+on_channel_map_volume_changed (GvcChannelMap  *map,
+                               gboolean        set,
+                               GvcBalanceBar  *bar)
+{
+        update_level_from_map (bar, map);
+}
+
+static void
+gvc_balance_bar_set_channel_map (GvcBalanceBar *bar,
+                                 GvcChannelMap *map)
+{
+        g_return_if_fail (GVC_BALANCE_BAR (bar));
+
+        if (bar->priv->channel_map != NULL) {
+                g_signal_handlers_disconnect_by_func (G_OBJECT (bar->priv->channel_map),
+                                                      on_channel_map_volume_changed, bar);
+                g_object_unref (bar->priv->channel_map);
+        }
+        bar->priv->channel_map = g_object_ref (map);
+
+        update_level_from_map (bar, map);
+
+        g_signal_connect (G_OBJECT (map), "volume-changed",
+                          G_CALLBACK (on_channel_map_volume_changed), bar);
+
+        g_object_notify (G_OBJECT (bar), "channel-map");
+}
+
+static void
+gvc_balance_bar_set_balance_type (GvcBalanceBar *bar,
+                                  GvcBalanceType btype)
+{
+        GtkWidget *frame;
+
+        g_return_if_fail (GVC_BALANCE_BAR (bar));
+
+        bar->priv->btype = btype;
+        if (bar->priv->btype != BALANCE_TYPE_LFE) {
+                bar->priv->adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                            -1.0,
+                                                                            1.0,
+                                                                            0.5,
+                                                                            0.5,
+                                                                            0.0));
+        } else {
+                bar->priv->adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                            0.0,
+                                                                            ADJUSTMENT_MAX_NORMAL,
+                                                                            ADJUSTMENT_MAX_NORMAL/100.0,
+                                                                            ADJUSTMENT_MAX_NORMAL/10.0,
+                                                                            0.0));
+        }
+
+        g_object_ref_sink (bar->priv->adjustment);
+        g_signal_connect (bar->priv->adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_adjustment_value_changed),
+                          bar);
+
+        switch (btype) {
+        case BALANCE_TYPE_RL:
+                bar->priv->label = gtk_label_new_with_mnemonic (_("_Balance:"));
+                break;
+        case BALANCE_TYPE_FR:
+                bar->priv->label = gtk_label_new_with_mnemonic (_("_Fade:"));
+                break;
+        case BALANCE_TYPE_LFE:
+                bar->priv->label = gtk_label_new_with_mnemonic (_("_Subwoofer:"));
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+        gtk_misc_set_alignment (GTK_MISC (bar->priv->label),
+                                0.0,
+                                0.0);
+        /* frame */
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+        gtk_container_add (GTK_CONTAINER (bar), frame);
+
+        /* box with scale */
+        bar->priv->scale_box = _scale_box_new (bar);
+        gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
+        gtk_widget_show_all (frame);
+
+        gtk_widget_set_direction (bar->priv->scale, GTK_TEXT_DIR_LTR);
+        gtk_label_set_mnemonic_widget (GTK_LABEL (bar->priv->label),
+                                       bar->priv->scale);
+
+        g_object_notify (G_OBJECT (bar), "balance-type");
+}
+
+static void
+gvc_balance_bar_set_property (GObject       *object,
+                              guint          prop_id,
+                              const GValue  *value,
+                              GParamSpec    *pspec)
+{
+        GvcBalanceBar *self = GVC_BALANCE_BAR (object);
+
+        switch (prop_id) {
+        case PROP_CHANNEL_MAP:
+                gvc_balance_bar_set_channel_map (self, g_value_get_object (value));
+                break;
+        case PROP_BALANCE_TYPE:
+                gvc_balance_bar_set_balance_type (self, g_value_get_int (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_balance_bar_get_property (GObject     *object,
+                              guint        prop_id,
+                              GValue      *value,
+                              GParamSpec  *pspec)
+{
+        GvcBalanceBar *self = GVC_BALANCE_BAR (object);
+
+        switch (prop_id) {
+        case PROP_CHANNEL_MAP:
+                g_value_set_object (value, self->priv->channel_map);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_balance_bar_constructor (GType                  type,
+                             guint                  n_construct_properties,
+                             GObjectConstructParam *construct_params)
+{
+        return G_OBJECT_CLASS (gvc_balance_bar_parent_class)->constructor (type, n_construct_properties, construct_params);
+}
+
+static void
+gvc_balance_bar_class_init (GvcBalanceBarClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_balance_bar_constructor;
+        object_class->finalize = gvc_balance_bar_finalize;
+        object_class->set_property = gvc_balance_bar_set_property;
+        object_class->get_property = gvc_balance_bar_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_CHANNEL_MAP,
+                                         g_param_spec_object ("channel-map",
+                                                              "channel map",
+                                                              "The channel map",
+                                                              GVC_TYPE_CHANNEL_MAP,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_BALANCE_TYPE,
+                                         g_param_spec_int ("balance-type",
+                                                           "balance type",
+                                                           "Whether the balance is right-left or front-rear",
+                                                           BALANCE_TYPE_RL, NUM_BALANCE_TYPES - 1, BALANCE_TYPE_RL,
+                                                           G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+
+        g_type_class_add_private (klass, sizeof (GvcBalanceBarPrivate));
+}
+
+
+static gboolean
+on_scale_button_press_event (GtkWidget      *widget,
+                             GdkEventButton *event,
+                             GvcBalanceBar  *bar)
+{
+        bar->priv->click_lock = TRUE;
+
+        return FALSE;
+}
+
+static gboolean
+on_scale_button_release_event (GtkWidget      *widget,
+                               GdkEventButton *event,
+                               GvcBalanceBar  *bar)
+{
+        bar->priv->click_lock = FALSE;
+
+        return FALSE;
+}
+
+static gboolean
+on_scale_scroll_event (GtkWidget      *widget,
+                       GdkEventScroll *event,
+                       GvcBalanceBar  *bar)
+{
+        gdouble value;
+
+        value = gtk_adjustment_get_value (bar->priv->adjustment);
+
+        if (bar->priv->btype == BALANCE_TYPE_LFE) {
+                if (event->direction == GDK_SCROLL_UP) {
+                        if (value + ADJUSTMENT_MAX_NORMAL/100.0 > ADJUSTMENT_MAX_NORMAL)
+                                value = ADJUSTMENT_MAX_NORMAL;
+                        else
+                                value = value + ADJUSTMENT_MAX_NORMAL/100.0;
+                } else if (event->direction == GDK_SCROLL_DOWN) {
+                        if (value - ADJUSTMENT_MAX_NORMAL/100.0 < 0)
+                                value = 0.0;
+                        else
+                                value = value - ADJUSTMENT_MAX_NORMAL/100.0;
+                }
+        } else {
+                if (event->direction == GDK_SCROLL_UP) {
+                        if (value + 0.01 > 1.0)
+                                value = 1.0;
+                        else
+                                value = value + 0.01;
+                } else if (event->direction == GDK_SCROLL_DOWN) {
+                        if (value - 0.01 < 0)
+                                value = 0.0;
+                        else
+                                value = value - 0.01;
+                }
+        }
+        gtk_adjustment_set_value (bar->priv->adjustment, value);
+
+        return TRUE;
+}
+
+/* FIXME remove when we depend on a newer PA */
+static pa_cvolume *
+gvc_pa_cvolume_set_position (pa_cvolume *cv, const pa_channel_map *map, pa_channel_position_t t, pa_volume_t v) {
+        unsigned c;
+        gboolean good = FALSE;
+
+        g_assert(cv);
+        g_assert(map);
+
+        g_return_val_if_fail(pa_cvolume_compatible_with_channel_map(cv, map), NULL);
+        g_return_val_if_fail(t < PA_CHANNEL_POSITION_MAX, NULL);
+
+        for (c = 0; c < map->channels; c++)
+                if (map->map[c] == t) {
+                        cv->values[c] = v;
+                        good = TRUE;
+                }
+
+        return good ? cv : NULL;
+}
+
+static void
+on_adjustment_value_changed (GtkAdjustment *adjustment,
+                             GvcBalanceBar *bar)
+{
+        gdouble                val;
+        pa_cvolume             cv;
+        const pa_channel_map  *pa_map;
+
+        if (bar->priv->channel_map == NULL)
+                return;
+
+        cv = *gvc_channel_map_get_cvolume (bar->priv->channel_map);
+        val = gtk_adjustment_get_value (adjustment);
+
+        pa_map = gvc_channel_map_get_pa_channel_map (bar->priv->channel_map);
+
+        switch (bar->priv->btype) {
+        case BALANCE_TYPE_RL:
+                pa_cvolume_set_balance (&cv, pa_map, val);
+                break;
+        case BALANCE_TYPE_FR:
+                pa_cvolume_set_fade (&cv, pa_map, val);
+                break;
+        case BALANCE_TYPE_LFE:
+                gvc_pa_cvolume_set_position (&cv, pa_map, PA_CHANNEL_POSITION_LFE, val);
+                break;
+        }
+
+        gvc_channel_map_volume_changed (bar->priv->channel_map, &cv, TRUE);
+}
+
+static void
+gvc_balance_bar_init (GvcBalanceBar *bar)
+{
+        bar->priv = GVC_BALANCE_BAR_GET_PRIVATE (bar);
+}
+
+static void
+gvc_balance_bar_finalize (GObject *object)
+{
+        GvcBalanceBar *bar;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_BALANCE_BAR (object));
+
+        bar = GVC_BALANCE_BAR (object);
+
+        g_return_if_fail (bar->priv != NULL);
+
+        if (bar->priv->channel_map != NULL) {
+                g_signal_handlers_disconnect_by_func (G_OBJECT (bar->priv->channel_map),
+                                                      on_channel_map_volume_changed, bar);
+                g_object_unref (bar->priv->channel_map);
+        }
+
+        G_OBJECT_CLASS (gvc_balance_bar_parent_class)->finalize (object);
+}
+
+void
+gvc_balance_bar_set_map (GvcBalanceBar* self,
+                         const GvcChannelMap *channel_map)
+{
+        g_object_set (G_OBJECT (self),
+                      "channel-map", channel_map, NULL);
+}                                   
+
+GtkWidget *
+gvc_balance_bar_new (GvcBalanceType btype)
+{
+        GObject *bar;
+        bar = g_object_new (GVC_TYPE_BALANCE_BAR,
+                            "balance-type", btype, NULL);
+
+        return GTK_WIDGET (bar);
+}
Index: gnome-control-center/panels/sound-nua/gvc-balance-bar.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-balance-bar.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,70 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_BALANCE_BAR_H
+#define __GVC_BALANCE_BAR_H
+
+#include <glib-object.h>
+
+#include "gvc-channel-map.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_BALANCE_BAR         (gvc_balance_bar_get_type ())
+#define GVC_BALANCE_BAR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_BALANCE_BAR, GvcBalanceBar))
+#define GVC_BALANCE_BAR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_BALANCE_BAR, GvcBalanceBarClass))
+#define GVC_IS_BALANCE_BAR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_BALANCE_BAR))
+#define GVC_IS_BALANCE_BAR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_BALANCE_BAR))
+#define GVC_BALANCE_BAR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_BALANCE_BAR, GvcBalanceBarClass))
+
+typedef enum {
+        BALANCE_TYPE_RL,
+        BALANCE_TYPE_FR,
+        BALANCE_TYPE_LFE,
+} GvcBalanceType;
+
+#define NUM_BALANCE_TYPES BALANCE_TYPE_LFE + 1
+
+typedef struct GvcBalanceBarPrivate GvcBalanceBarPrivate;
+
+typedef struct
+{
+        GtkHBox               parent;
+        GvcBalanceBarPrivate *priv;
+} GvcBalanceBar;
+
+typedef struct
+{
+        GtkHBoxClass          parent_class;
+} GvcBalanceBarClass;
+
+GType               gvc_balance_bar_get_type            (void);
+GtkWidget *         gvc_balance_bar_new                 (GvcBalanceType btype);
+
+void                gvc_balance_bar_set_size_group      (GvcBalanceBar *bar,
+                                                         GtkSizeGroup  *group,
+                                                         gboolean       symmetric);
+
+void                gvc_balance_bar_set_map (GvcBalanceBar *self,
+                                             const GvcChannelMap *channel_map);
+
+G_END_DECLS
+
+#endif /* __GVC_BALANCE_BAR_H */
Index: gnome-control-center/panels/sound-nua/gvc-channel-bar.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-channel-bar.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,963 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <pulse/pulseaudio.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+
+#include "gvc-channel-bar.h"
+#include "gvc-mixer-control.h"
+
+#define SCALE_SIZE 128
+#define ADJUSTMENT_MAX_NORMAL gvc_mixer_control_get_vol_max_norm(NULL)
+#define ADJUSTMENT_MAX_AMPLIFIED gvc_mixer_control_get_vol_max_amplified(NULL)
+#define ADJUSTMENT_MAX (bar->priv->is_amplified ? ADJUSTMENT_MAX_AMPLIFIED : ADJUSTMENT_MAX_NORMAL)
+#define SCROLLSTEP (ADJUSTMENT_MAX / 100.0 * 5.0)
+
+#define GVC_CHANNEL_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_CHANNEL_BAR, GvcChannelBarPrivate))
+
+struct GvcChannelBarPrivate
+{
+        GtkOrientation orientation;
+        GtkWidget     *scale_box;
+        GtkWidget     *start_box;
+        GtkWidget     *end_box;
+        GtkWidget     *image;
+        GtkWidget     *label;
+        GtkWidget     *low_image;
+        GtkWidget     *scale;
+        GtkWidget     *high_image;
+        GtkWidget     *mute_box;
+        GtkWidget     *mute_button;
+        GtkAdjustment *adjustment;
+        GtkAdjustment *zero_adjustment;
+        gboolean       show_mute;
+        gboolean       is_muted;
+        char          *name;
+        char          *icon_name;
+        char          *low_icon_name;
+        char          *high_icon_name;
+        GtkSizeGroup  *size_group;
+        gboolean       symmetric;
+        gboolean       click_lock;
+        gboolean       is_amplified;
+        guint32        base_volume;
+};
+
+enum
+{
+        PROP_0,
+        PROP_ORIENTATION,
+        PROP_SHOW_MUTE,
+        PROP_IS_MUTED,
+        PROP_ADJUSTMENT,
+        PROP_NAME,
+        PROP_ICON_NAME,
+        PROP_LOW_ICON_NAME,
+        PROP_HIGH_ICON_NAME,
+        PROP_IS_AMPLIFIED,
+        PROP_ELLIPSIZE
+};
+
+static void     gvc_channel_bar_class_init    (GvcChannelBarClass *klass);
+static void     gvc_channel_bar_init          (GvcChannelBar      *channel_bar);
+static void     gvc_channel_bar_finalize      (GObject            *object);
+
+static gboolean on_scale_button_press_event   (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcChannelBar  *bar);
+static gboolean on_scale_button_release_event (GtkWidget      *widget,
+                                               GdkEventButton *event,
+                                               GvcChannelBar  *bar);
+static gboolean on_scale_scroll_event         (GtkWidget      *widget,
+                                               GdkEventScroll *event,
+                                               GvcChannelBar  *bar);
+
+G_DEFINE_TYPE (GvcChannelBar, gvc_channel_bar, GTK_TYPE_HBOX)
+
+static GtkWidget *
+_scale_box_new (GvcChannelBar *bar)
+{
+        GvcChannelBarPrivate *priv = bar->priv;
+        GtkWidget            *box;
+        GtkWidget            *sbox;
+        GtkWidget            *ebox;
+
+        if (priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                bar->priv->scale_box = box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+
+                priv->scale = gtk_vscale_new (priv->adjustment);
+
+                gtk_widget_set_size_request (priv->scale, -1, SCALE_SIZE);
+                gtk_range_set_inverted (GTK_RANGE (priv->scale), TRUE);
+
+                bar->priv->start_box = sbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (sbox), priv->image, FALSE, FALSE, 0);
+                gtk_box_pack_start (GTK_BOX (sbox), priv->label, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (sbox), priv->high_image, FALSE, FALSE, 0);
+                gtk_widget_hide (priv->high_image);
+                gtk_box_pack_start (GTK_BOX (box), priv->scale, TRUE, TRUE, 0);
+
+                bar->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (ebox), priv->low_image, FALSE, FALSE, 0);
+                gtk_widget_hide (priv->low_image);
+
+                gtk_box_pack_start (GTK_BOX (ebox), priv->mute_box, FALSE, FALSE, 0);
+        } else {
+                bar->priv->scale_box = box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), priv->image, FALSE, FALSE, 0);
+
+                priv->scale = gtk_hscale_new (priv->adjustment);
+
+                gtk_widget_set_size_request (priv->scale, SCALE_SIZE, -1);
+
+                bar->priv->start_box = sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+                gtk_box_pack_end (GTK_BOX (sbox), priv->low_image, FALSE, FALSE, 0);
+                gtk_widget_show (priv->low_image);
+
+                gtk_box_pack_start (GTK_BOX (sbox), priv->label, TRUE, TRUE, 0);
+                gtk_box_pack_start (GTK_BOX (box), priv->scale, TRUE, TRUE, 0);
+
+                bar->priv->end_box = ebox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+                gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+                gtk_box_pack_start (GTK_BOX (ebox), priv->high_image, FALSE, FALSE, 0);
+                gtk_widget_show (priv->high_image);
+                gtk_box_pack_start (GTK_BOX (ebox), priv->mute_box, FALSE, FALSE, 0);
+        }
+
+        ca_gtk_widget_disable_sounds (bar->priv->scale, FALSE);
+        gtk_widget_add_events (bar->priv->scale, GDK_SCROLL_MASK);
+
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-press-event",
+                          G_CALLBACK (on_scale_button_press_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "button-release-event",
+                          G_CALLBACK (on_scale_button_release_event), bar);
+        g_signal_connect (G_OBJECT (bar->priv->scale), "scroll-event",
+                          G_CALLBACK (on_scale_scroll_event), bar);
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group, sbox);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group, ebox);
+                }
+        }
+
+        gtk_scale_set_draw_value (GTK_SCALE (priv->scale), FALSE);
+
+        return box;
+}
+
+static void
+update_image (GvcChannelBar *bar)
+{
+        gtk_image_set_from_icon_name (GTK_IMAGE (bar->priv->image),
+                                      bar->priv->icon_name,
+                                      GTK_ICON_SIZE_DIALOG);
+
+        if (bar->priv->icon_name != NULL) {
+                gtk_widget_show (bar->priv->image);
+        } else {
+                gtk_widget_hide (bar->priv->image);
+        }
+}
+
+static void
+update_label (GvcChannelBar *bar)
+{
+        if (bar->priv->name != NULL) {
+                gtk_label_set_text_with_mnemonic (GTK_LABEL (bar->priv->label),
+                                                  bar->priv->name);
+                gtk_label_set_mnemonic_widget (GTK_LABEL (bar->priv->label),
+                                               bar->priv->scale);
+                gtk_widget_show (bar->priv->label);
+        } else {
+                gtk_label_set_text (GTK_LABEL (bar->priv->label), NULL);
+                gtk_widget_hide (bar->priv->label);
+        }
+}
+
+static void
+update_layout (GvcChannelBar *bar)
+{
+        GtkWidget *box;
+        GtkWidget *frame;
+
+        if (bar->priv->scale == NULL) {
+                return;
+        }
+
+        box = bar->priv->scale_box;
+        frame = gtk_widget_get_parent (box);
+
+        g_object_ref (bar->priv->image);
+        g_object_ref (bar->priv->label);
+        g_object_ref (bar->priv->mute_box);
+        g_object_ref (bar->priv->low_image);
+        g_object_ref (bar->priv->high_image);
+
+        gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->image);
+        gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->label);
+        gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->mute_box);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->low_image);
+                gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->high_image);
+        } else {
+                gtk_container_remove (GTK_CONTAINER (bar->priv->end_box), bar->priv->low_image);
+                gtk_container_remove (GTK_CONTAINER (bar->priv->start_box), bar->priv->high_image);
+        }
+
+        gtk_container_remove (GTK_CONTAINER (box), bar->priv->start_box);
+        gtk_container_remove (GTK_CONTAINER (box), bar->priv->scale);
+        gtk_container_remove (GTK_CONTAINER (box), bar->priv->end_box);
+        gtk_container_remove (GTK_CONTAINER (frame), box);
+
+        bar->priv->scale_box = _scale_box_new (bar);
+        gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
+
+        g_object_unref (bar->priv->image);
+        g_object_unref (bar->priv->label);
+        g_object_unref (bar->priv->mute_box);
+        g_object_unref (bar->priv->low_image);
+        g_object_unref (bar->priv->high_image);
+
+        gtk_widget_show_all (frame);
+}
+
+void
+gvc_channel_bar_set_size_group (GvcChannelBar *bar,
+                                GtkSizeGroup  *group,
+                                gboolean       symmetric)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        bar->priv->size_group = group;
+        bar->priv->symmetric = symmetric;
+
+        if (bar->priv->size_group != NULL) {
+                gtk_size_group_add_widget (bar->priv->size_group,
+                                           bar->priv->start_box);
+
+                if (bar->priv->symmetric) {
+                        gtk_size_group_add_widget (bar->priv->size_group,
+                                                   bar->priv->end_box);
+                }
+        }
+        gtk_widget_queue_draw (GTK_WIDGET (bar));
+}
+
+void
+gvc_channel_bar_set_name (GvcChannelBar  *bar,
+                          const char     *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        g_free (bar->priv->name);
+        bar->priv->name = g_strdup (name);
+        update_label (bar);
+        g_object_notify (G_OBJECT (bar), "name");
+}
+
+void
+gvc_channel_bar_set_icon_name (GvcChannelBar  *bar,
+                               const char     *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        g_free (bar->priv->icon_name);
+        bar->priv->icon_name = g_strdup (name);
+        update_image (bar);
+        g_object_notify (G_OBJECT (bar), "icon-name");
+}
+
+void
+gvc_channel_bar_set_low_icon_name   (GvcChannelBar *bar,
+                                     const char    *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (name != NULL && strcmp (bar->priv->low_icon_name, name) != 0) {
+                g_free (bar->priv->low_icon_name);
+                bar->priv->low_icon_name = g_strdup (name);
+                gtk_image_set_from_icon_name (GTK_IMAGE (bar->priv->low_image),
+                                              bar->priv->low_icon_name,
+                                              GTK_ICON_SIZE_MENU);
+                g_object_notify (G_OBJECT (bar), "low-icon-name");
+        }
+}
+
+void
+gvc_channel_bar_set_high_icon_name  (GvcChannelBar *bar,
+                                     const char    *name)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (name != NULL && strcmp (bar->priv->high_icon_name, name) != 0) {
+                g_free (bar->priv->high_icon_name);
+                bar->priv->high_icon_name = g_strdup (name);
+                gtk_image_set_from_icon_name (GTK_IMAGE (bar->priv->high_image),
+                                              bar->priv->high_icon_name,
+                                              GTK_ICON_SIZE_MENU);
+                g_object_notify (G_OBJECT (bar), "high-icon-name");
+        }
+}
+
+void
+gvc_channel_bar_set_orientation (GvcChannelBar  *bar,
+                                 GtkOrientation  orientation)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (orientation != bar->priv->orientation) {
+                bar->priv->orientation = orientation;
+                update_layout (bar);
+                g_object_notify (G_OBJECT (bar), "orientation");
+        }
+}
+
+static void
+gvc_channel_bar_set_adjustment (GvcChannelBar *bar,
+                                GtkAdjustment *adjustment)
+{
+        g_return_if_fail (GVC_CHANNEL_BAR (bar));
+        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+        if (bar->priv->adjustment != NULL) {
+                g_object_unref (bar->priv->adjustment);
+        }
+        bar->priv->adjustment = g_object_ref_sink (adjustment);
+
+        if (bar->priv->scale != NULL) {
+                gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale), adjustment);
+        }
+
+        g_object_notify (G_OBJECT (bar), "adjustment");
+}
+
+GtkAdjustment *
+gvc_channel_bar_get_adjustment (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), NULL);
+
+        return bar->priv->adjustment;
+}
+
+static gboolean
+on_scale_button_press_event (GtkWidget      *widget,
+                             GdkEventButton *event,
+                             GvcChannelBar  *bar)
+{
+        /* HACK: we want the behaviour you get with the middle button, so we
+         * mangle the event.  clicking with other buttons moves the slider in
+         * step increments, clicking with the middle button moves the slider to
+         * the location of the click.
+         */
+        if (event->button == 1)
+                event->button = 2;
+
+        bar->priv->click_lock = TRUE;
+
+        return FALSE;
+}
+
+static gboolean
+on_scale_button_release_event (GtkWidget      *widget,
+                               GdkEventButton *event,
+                               GvcChannelBar  *bar)
+{
+        GtkAdjustment *adj;
+        gdouble value;
+
+        /* HACK: see on_scale_button_press_event() */
+        if (event->button == 1)
+                event->button = 2;
+
+        bar->priv->click_lock = FALSE;
+
+        adj = gtk_range_get_adjustment (GTK_RANGE (widget));
+
+        value = gtk_adjustment_get_value (adj);
+
+        /* this means the adjustment moved away from zero and
+         * therefore we should unmute and set the volume. */
+        gvc_channel_bar_set_is_muted (bar, (value == 0.0));
+
+        /* Play a sound! */
+        ca_gtk_play_for_widget (GTK_WIDGET (bar), 0,
+                                CA_PROP_EVENT_ID, "audio-volume-change",
+                                CA_PROP_EVENT_DESCRIPTION, "foobar event happened",
+                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+                                NULL);
+
+        return FALSE;
+}
+
+gboolean
+gvc_channel_bar_scroll (GvcChannelBar *bar, GdkScrollDirection direction)
+{
+        GtkAdjustment *adj;
+        gdouble value;
+
+        g_return_val_if_fail (bar != NULL, FALSE);
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                if (direction != GDK_SCROLL_UP && direction != GDK_SCROLL_DOWN)
+                        return FALSE;
+        } else {
+                /* Switch direction for RTL */
+                if (gtk_widget_get_direction (GTK_WIDGET (bar)) == GTK_TEXT_DIR_RTL) {
+                        if (direction == GDK_SCROLL_RIGHT)
+                                direction = GDK_SCROLL_LEFT;
+                        else if (direction == GDK_SCROLL_LEFT)
+                                direction = GDK_SCROLL_RIGHT;
+                }
+                /* Switch side scroll to vertical */
+                if (direction == GDK_SCROLL_RIGHT)
+                        direction = GDK_SCROLL_UP;
+                else if (direction == GDK_SCROLL_LEFT)
+                        direction = GDK_SCROLL_DOWN;
+        }
+
+        adj = gtk_range_get_adjustment (GTK_RANGE (bar->priv->scale));
+        if (adj == bar->priv->zero_adjustment) {
+                if (direction == GDK_SCROLL_UP)
+                        gvc_channel_bar_set_is_muted (bar, FALSE);
+                return TRUE;
+        }
+
+        value = gtk_adjustment_get_value (adj);
+
+        if (direction == GDK_SCROLL_UP) {
+                if (value + SCROLLSTEP > ADJUSTMENT_MAX)
+                        value = ADJUSTMENT_MAX;
+                else
+                        value = value + SCROLLSTEP;
+        } else if (direction == GDK_SCROLL_DOWN) {
+                if (value - SCROLLSTEP < 0)
+                        value = 0.0;
+                else
+                        value = value - SCROLLSTEP;
+        }
+
+        gvc_channel_bar_set_is_muted (bar, (value == 0.0));
+        adj = gtk_range_get_adjustment (GTK_RANGE (bar->priv->scale));
+        gtk_adjustment_set_value (adj, value);
+
+        return TRUE;
+}
+
+static gboolean
+on_scale_scroll_event (GtkWidget      *widget,
+                       GdkEventScroll *event,
+                       GvcChannelBar  *bar)
+{
+        return gvc_channel_bar_scroll (bar, event->direction);
+}
+
+static void
+on_zero_adjustment_value_changed (GtkAdjustment *adjustment,
+                                  GvcChannelBar *bar)
+{
+        gdouble value;
+
+        if (bar->priv->click_lock != FALSE) {
+                return;
+        }
+
+        value = gtk_adjustment_get_value (bar->priv->zero_adjustment);
+        gtk_adjustment_set_value (bar->priv->adjustment, value);
+
+
+        if (bar->priv->show_mute == FALSE) {
+                /* this means the adjustment moved away from zero and
+                 * therefore we should unmute and set the volume. */
+                gvc_channel_bar_set_is_muted (bar, value > 0.0);
+        }
+}
+
+static void
+update_mute_button (GvcChannelBar *bar)
+{
+        if (bar->priv->show_mute) {
+                gtk_widget_show (bar->priv->mute_button);
+                gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (bar->priv->mute_button),
+                                              bar->priv->is_muted);
+        } else {
+                gtk_widget_hide (bar->priv->mute_button);
+        }
+
+        if (bar->priv->is_muted) {
+                /* If we aren't showing the mute button then
+                 * move slider to the zero.  But we don't want to
+                 * change the adjustment.  */
+                g_signal_handlers_block_by_func (bar->priv->zero_adjustment,
+                                                 on_zero_adjustment_value_changed,
+                                                 bar);
+                gtk_adjustment_set_value (bar->priv->zero_adjustment, 0);
+                g_signal_handlers_unblock_by_func (bar->priv->zero_adjustment,
+                                                   on_zero_adjustment_value_changed,
+                                                   bar);
+                gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale),
+                                          bar->priv->zero_adjustment);
+        } else {
+                /* no longer muted so restore the original adjustment
+                 * and tell the front-end that the value changed */
+                gtk_range_set_adjustment (GTK_RANGE (bar->priv->scale),
+                                          bar->priv->adjustment);
+                gtk_adjustment_value_changed (bar->priv->adjustment);
+        }
+}
+
+void
+gvc_channel_bar_set_is_muted (GvcChannelBar *bar,
+                              gboolean       is_muted)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (is_muted != bar->priv->is_muted) {
+                /* Update our internal state before telling the
+                 * front-end about our changes */
+                bar->priv->is_muted = is_muted;
+                update_mute_button (bar);
+                g_object_notify (G_OBJECT (bar), "is-muted");
+        }
+}
+
+gboolean
+gvc_channel_bar_get_is_muted  (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+        return bar->priv->is_muted;
+}
+
+void
+gvc_channel_bar_set_show_mute (GvcChannelBar *bar,
+                               gboolean       show_mute)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (show_mute != bar->priv->show_mute) {
+                bar->priv->show_mute = show_mute;
+                g_object_notify (G_OBJECT (bar), "show-mute");
+                update_mute_button (bar);
+        }
+}
+
+gboolean
+gvc_channel_bar_get_show_mute (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+        return bar->priv->show_mute;
+}
+
+void
+gvc_channel_bar_set_is_amplified (GvcChannelBar *bar, gboolean amplified)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        bar->priv->is_amplified = amplified;
+        gtk_adjustment_set_upper (bar->priv->adjustment, ADJUSTMENT_MAX);
+        gtk_adjustment_set_upper (bar->priv->zero_adjustment, ADJUSTMENT_MAX);
+        gtk_scale_clear_marks (GTK_SCALE (bar->priv->scale));
+
+        if (amplified) {
+                char *str;
+
+                if (bar->priv->base_volume == ADJUSTMENT_MAX_NORMAL) {
+                        str = g_strdup_printf ("<small>%s</small>", C_("volume", "100%"));
+                        gtk_scale_add_mark (GTK_SCALE (bar->priv->scale), ADJUSTMENT_MAX_NORMAL,
+                                            GTK_POS_BOTTOM, str);
+                } else {
+                        str = g_strdup_printf ("<small>%s</small>", C_("volume", "Unamplified"));
+                        gtk_scale_add_mark (GTK_SCALE (bar->priv->scale), bar->priv->base_volume,
+                                            GTK_POS_BOTTOM, str);
+                        /* Only show 100% if it's higher than the base volume */
+                        if (bar->priv->base_volume < ADJUSTMENT_MAX_NORMAL) {
+                                str = g_strdup_printf ("<small>%s</small>", C_("volume", "100%"));
+                                gtk_scale_add_mark (GTK_SCALE (bar->priv->scale), ADJUSTMENT_MAX_NORMAL,
+                                                    GTK_POS_BOTTOM, str);
+                        }
+                }
+
+                g_free (str);
+                gtk_alignment_set (GTK_ALIGNMENT (bar->priv->mute_box), 0.5, 0, 0, 0);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->low_image), 0.5, 0.15);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->high_image), 0.5, 0.15);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->label), 0, 0);
+        } else {
+                gtk_alignment_set (GTK_ALIGNMENT (bar->priv->mute_box), 0.5, 0.5, 0, 0);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->low_image), 0.5, 0.5);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->high_image), 0.5, 0.5);
+                gtk_misc_set_alignment (GTK_MISC (bar->priv->label), 0, 0.5);
+        }
+}
+
+gboolean
+gvc_channel_bar_get_ellipsize (GvcChannelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_BAR (bar), FALSE);
+
+        return gtk_label_get_ellipsize (GTK_LABEL (bar->priv->label)) != PANGO_ELLIPSIZE_NONE;
+}
+
+void
+gvc_channel_bar_set_ellipsize (GvcChannelBar *bar,
+                               gboolean       ellipsized)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (ellipsized)
+                gtk_label_set_ellipsize (GTK_LABEL (bar->priv->label), PANGO_ELLIPSIZE_END);
+	else
+                gtk_label_set_ellipsize (GTK_LABEL (bar->priv->label), PANGO_ELLIPSIZE_NONE);
+}
+
+void
+gvc_channel_bar_set_base_volume (GvcChannelBar *bar,
+                                 pa_volume_t    base_volume)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (bar));
+
+        if (base_volume == 0) {
+                bar->priv->base_volume = ADJUSTMENT_MAX_NORMAL;
+                return;
+        }
+
+        /* Note that you need to call _is_amplified() afterwards to update the marks */
+        bar->priv->base_volume = base_volume;
+}
+
+static void
+gvc_channel_bar_set_property (GObject       *object,
+                              guint          prop_id,
+                              const GValue  *value,
+                              GParamSpec    *pspec)
+{
+        GvcChannelBar *self = GVC_CHANNEL_BAR (object);
+
+        switch (prop_id) {
+        case PROP_ORIENTATION:
+                gvc_channel_bar_set_orientation (self, g_value_get_enum (value));
+                break;
+        case PROP_IS_MUTED:
+                gvc_channel_bar_set_is_muted (self, g_value_get_boolean (value));
+                break;
+        case PROP_SHOW_MUTE:
+                gvc_channel_bar_set_show_mute (self, g_value_get_boolean (value));
+                break;
+        case PROP_NAME:
+                gvc_channel_bar_set_name (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAME:
+                gvc_channel_bar_set_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_LOW_ICON_NAME:
+                gvc_channel_bar_set_low_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_HIGH_ICON_NAME:
+                gvc_channel_bar_set_high_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_ADJUSTMENT:
+                gvc_channel_bar_set_adjustment (self, g_value_get_object (value));
+                break;
+        case PROP_IS_AMPLIFIED:
+                gvc_channel_bar_set_is_amplified (self, g_value_get_boolean (value));
+                break;
+        case PROP_ELLIPSIZE:
+                gvc_channel_bar_set_ellipsize (self, g_value_get_boolean (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_channel_bar_get_property (GObject     *object,
+                              guint        prop_id,
+                              GValue      *value,
+                              GParamSpec  *pspec)
+{
+        GvcChannelBar *self = GVC_CHANNEL_BAR (object);
+        GvcChannelBarPrivate *priv = self->priv;
+
+        switch (prop_id) {
+        case PROP_ORIENTATION:
+                g_value_set_enum (value, priv->orientation);
+                break;
+        case PROP_IS_MUTED:
+                g_value_set_boolean (value, priv->is_muted);
+                break;
+        case PROP_SHOW_MUTE:
+                g_value_set_boolean (value, priv->show_mute);
+                break;
+        case PROP_NAME:
+                g_value_set_string (value, priv->name);
+                break;
+        case PROP_ICON_NAME:
+                g_value_set_string (value, priv->icon_name);
+                break;
+        case PROP_LOW_ICON_NAME:
+                g_value_set_string (value, priv->low_icon_name);
+                break;
+        case PROP_HIGH_ICON_NAME:
+                g_value_set_string (value, priv->high_icon_name);
+                break;
+        case PROP_ADJUSTMENT:
+                g_value_set_object (value, gvc_channel_bar_get_adjustment (self));
+                break;
+        case PROP_IS_AMPLIFIED:
+                g_value_set_boolean (value, priv->is_amplified);
+                break;
+        case PROP_ELLIPSIZE:
+                g_value_set_boolean (value, gvc_channel_bar_get_ellipsize (self));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_channel_bar_constructor (GType                  type,
+                             guint                  n_construct_properties,
+                             GObjectConstructParam *construct_params)
+{
+        GObject       *object;
+        GvcChannelBar *self;
+
+        object = G_OBJECT_CLASS (gvc_channel_bar_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_CHANNEL_BAR (object);
+
+        update_mute_button (self);
+
+        return object;
+}
+
+static void
+gvc_channel_bar_class_init (GvcChannelBarClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_channel_bar_constructor;
+        object_class->finalize = gvc_channel_bar_finalize;
+        object_class->set_property = gvc_channel_bar_set_property;
+        object_class->get_property = gvc_channel_bar_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_ORIENTATION,
+                                         g_param_spec_enum ("orientation",
+                                                            "Orientation",
+                                                            "The orientation of the scale",
+                                                            GTK_TYPE_ORIENTATION,
+                                                            GTK_ORIENTATION_VERTICAL,
+                                                            G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_IS_MUTED,
+                                         g_param_spec_boolean ("is-muted",
+                                                               "is muted",
+                                                               "Whether stream is muted",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_SHOW_MUTE,
+                                         g_param_spec_boolean ("show-mute",
+                                                               "show mute",
+                                                               "Whether stream is muted",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_object_class_install_property (object_class,
+                                         PROP_ADJUSTMENT,
+                                         g_param_spec_object ("adjustment",
+                                                              "Adjustment",
+                                                              "The GtkAdjustment that contains the current value of this scale button object",
+                                                              GTK_TYPE_ADJUSTMENT,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_ICON_NAME,
+                                         g_param_spec_string ("icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_LOW_ICON_NAME,
+                                         g_param_spec_string ("low-icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              "audio-volume-low-symbolic",
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_HIGH_ICON_NAME,
+                                         g_param_spec_string ("high-icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              "audio-volume-high-symbolic",
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_IS_AMPLIFIED,
+                                         g_param_spec_boolean ("is-amplified",
+                                                               "Is amplified",
+                                                               "Whether the stream is digitally amplified",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_ELLIPSIZE,
+                                         g_param_spec_boolean ("ellipsize",
+                                                               "Label is ellipsized",
+                                                               "Whether the label is ellipsized",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_type_class_add_private (klass, sizeof (GvcChannelBarPrivate));
+}
+
+static void
+on_mute_button_toggled (GtkToggleButton *button,
+                        GvcChannelBar   *bar)
+{
+        gboolean is_muted;
+        is_muted = gtk_toggle_button_get_active (button);
+        gvc_channel_bar_set_is_muted (bar, is_muted);
+}
+
+static void
+gvc_channel_bar_init (GvcChannelBar *bar)
+{
+        GtkWidget *frame;
+
+        bar->priv = GVC_CHANNEL_BAR_GET_PRIVATE (bar);
+
+        bar->priv->base_volume = ADJUSTMENT_MAX_NORMAL;
+        bar->priv->low_icon_name = g_strdup ("audio-volume-low-symbolic");
+        bar->priv->high_icon_name = g_strdup ("audio-volume-high-symbolic");
+
+        bar->priv->orientation = GTK_ORIENTATION_VERTICAL;
+        bar->priv->adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                    0.0,
+                                                                    ADJUSTMENT_MAX_NORMAL,
+                                                                    ADJUSTMENT_MAX_NORMAL/100.0,
+                                                                    ADJUSTMENT_MAX_NORMAL/10.0,
+                                                                    0.0));
+        g_object_ref_sink (bar->priv->adjustment);
+
+        bar->priv->zero_adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                         0.0,
+                                                                         ADJUSTMENT_MAX_NORMAL,
+                                                                         ADJUSTMENT_MAX_NORMAL/100.0,
+                                                                         ADJUSTMENT_MAX_NORMAL/10.0,
+                                                                         0.0));
+        g_object_ref_sink (bar->priv->zero_adjustment);
+
+        g_signal_connect (bar->priv->zero_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_zero_adjustment_value_changed),
+                          bar);
+
+        bar->priv->mute_button = gtk_check_button_new_with_label (_("Mute"));
+        gtk_widget_set_no_show_all (bar->priv->mute_button, TRUE);
+        g_signal_connect (bar->priv->mute_button,
+                          "toggled",
+                          G_CALLBACK (on_mute_button_toggled),
+                          bar);
+        bar->priv->mute_box = gtk_alignment_new (0.5, 0.5, 0, 0);
+        gtk_container_add (GTK_CONTAINER (bar->priv->mute_box), bar->priv->mute_button);
+
+        bar->priv->low_image = gtk_image_new_from_icon_name ("audio-volume-low-symbolic",
+                                                             GTK_ICON_SIZE_MENU);
+        gtk_widget_set_no_show_all (bar->priv->low_image, TRUE);
+        bar->priv->high_image = gtk_image_new_from_icon_name ("audio-volume-high-symbolic",
+                                                              GTK_ICON_SIZE_MENU);
+        gtk_widget_set_no_show_all (bar->priv->high_image, TRUE);
+
+        bar->priv->image = gtk_image_new ();
+        gtk_widget_set_no_show_all (bar->priv->image, TRUE);
+
+        bar->priv->label = gtk_label_new (NULL);
+        gtk_misc_set_alignment (GTK_MISC (bar->priv->label), 0.0, 0.5);
+        gtk_widget_set_no_show_all (bar->priv->label, TRUE);
+
+        /* frame */
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+        gtk_container_add (GTK_CONTAINER (bar), frame);
+        gtk_widget_show_all (frame);
+
+        /* box with scale */
+        bar->priv->scale_box = _scale_box_new (bar);
+
+        gtk_container_add (GTK_CONTAINER (frame), bar->priv->scale_box);
+}
+
+static void
+gvc_channel_bar_finalize (GObject *object)
+{
+        GvcChannelBar *channel_bar;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_CHANNEL_BAR (object));
+
+        channel_bar = GVC_CHANNEL_BAR (object);
+
+        g_return_if_fail (channel_bar->priv != NULL);
+
+        g_free (channel_bar->priv->name);
+        g_free (channel_bar->priv->icon_name);
+        g_free (channel_bar->priv->low_icon_name);
+        g_free (channel_bar->priv->high_icon_name);
+
+        G_OBJECT_CLASS (gvc_channel_bar_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_channel_bar_new (void)
+{
+        GObject *bar;
+        bar = g_object_new (GVC_TYPE_CHANNEL_BAR,
+                            NULL);
+        return GTK_WIDGET (bar);
+}
Index: gnome-control-center/panels/sound-nua/gvc-channel-bar.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-channel-bar.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,89 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_CHANNEL_BAR_H
+#define __GVC_CHANNEL_BAR_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_CHANNEL_BAR         (gvc_channel_bar_get_type ())
+#define GVC_CHANNEL_BAR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_CHANNEL_BAR, GvcChannelBar))
+#define GVC_CHANNEL_BAR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_CHANNEL_BAR, GvcChannelBarClass))
+#define GVC_IS_CHANNEL_BAR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_CHANNEL_BAR))
+#define GVC_IS_CHANNEL_BAR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_CHANNEL_BAR))
+#define GVC_CHANNEL_BAR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_CHANNEL_BAR, GvcChannelBarClass))
+
+typedef struct GvcChannelBarPrivate GvcChannelBarPrivate;
+
+typedef struct
+{
+        GtkHBox               parent;
+        GvcChannelBarPrivate *priv;
+} GvcChannelBar;
+
+typedef struct
+{
+        GtkHBoxClass          parent_class;
+} GvcChannelBarClass;
+
+GType               gvc_channel_bar_get_type            (void);
+
+GtkWidget *         gvc_channel_bar_new                 (void);
+
+void                gvc_channel_bar_set_name            (GvcChannelBar *bar,
+                                                         const char    *name);
+void                gvc_channel_bar_set_icon_name       (GvcChannelBar *bar,
+                                                         const char    *icon_name);
+void                gvc_channel_bar_set_low_icon_name   (GvcChannelBar *bar,
+                                                         const char    *icon_name);
+void                gvc_channel_bar_set_high_icon_name  (GvcChannelBar *bar,
+                                                         const char    *icon_name);
+
+void                gvc_channel_bar_set_orientation     (GvcChannelBar *bar,
+                                                         GtkOrientation orientation);
+GtkOrientation      gvc_channel_bar_get_orientation     (GvcChannelBar *bar);
+
+GtkAdjustment *     gvc_channel_bar_get_adjustment      (GvcChannelBar *bar);
+
+gboolean            gvc_channel_bar_get_is_muted        (GvcChannelBar *bar);
+void                gvc_channel_bar_set_is_muted        (GvcChannelBar *bar,
+                                                         gboolean       is_muted);
+gboolean            gvc_channel_bar_get_show_mute       (GvcChannelBar *bar);
+void                gvc_channel_bar_set_show_mute       (GvcChannelBar *bar,
+                                                         gboolean       show_mute);
+void                gvc_channel_bar_set_size_group      (GvcChannelBar *bar,
+                                                         GtkSizeGroup  *group,
+                                                         gboolean       symmetric);
+void                gvc_channel_bar_set_is_amplified    (GvcChannelBar *bar,
+                                                         gboolean amplified);
+void                gvc_channel_bar_set_base_volume     (GvcChannelBar *bar,
+                                                         guint32        base_volume);
+gboolean            gvc_channel_bar_get_ellipsize       (GvcChannelBar *bar);
+void                gvc_channel_bar_set_ellipsize       (GvcChannelBar *bar,
+                                                         gboolean       ellipsized);
+
+gboolean            gvc_channel_bar_scroll              (GvcChannelBar *bar,
+                                                         GdkScrollDirection direction);
+
+G_END_DECLS
+
+#endif /* __GVC_CHANNEL_BAR_H */
Index: gnome-control-center/panels/sound-nua/gvc-channel-map-private.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-channel-map-private.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,39 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_CHANNEL_MAP_PRIVATE_H
+#define __GVC_CHANNEL_MAP_PRIVATE_H
+
+#include <glib-object.h>
+#include <pulse/pulseaudio.h>
+
+G_BEGIN_DECLS
+
+GvcChannelMap *         gvc_channel_map_new_from_pa_channel_map (const pa_channel_map *map);
+const pa_channel_map *  gvc_channel_map_get_pa_channel_map      (const GvcChannelMap  *map);
+
+void                    gvc_channel_map_volume_changed          (GvcChannelMap    *map,
+                                                                 const pa_cvolume *cv,
+                                                                 gboolean          set);
+const pa_cvolume *      gvc_channel_map_get_cvolume             (const GvcChannelMap  *map);
+
+G_END_DECLS
+
+#endif /* __GVC_CHANNEL_MAP_PRIVATE_H */
Index: gnome-control-center/panels/sound-nua/gvc-channel-map.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-channel-map.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,254 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-channel-map.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_CHANNEL_MAP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_CHANNEL_MAP, GvcChannelMapPrivate))
+
+struct GvcChannelMapPrivate
+{
+        pa_channel_map        pa_map;
+        gboolean              pa_volume_is_set;
+        pa_cvolume            pa_volume;
+        gdouble               extern_volume[NUM_TYPES]; /* volume, balance, fade, lfe */
+        gboolean              can_balance;
+        gboolean              can_fade;
+};
+
+enum {
+        VOLUME_CHANGED,
+        LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void     gvc_channel_map_class_init (GvcChannelMapClass *klass);
+static void     gvc_channel_map_init       (GvcChannelMap      *channel_map);
+static void     gvc_channel_map_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcChannelMap, gvc_channel_map, G_TYPE_OBJECT)
+
+guint
+gvc_channel_map_get_num_channels (const GvcChannelMap *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), 0);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return 0;
+
+        return map->priv->pa_map.channels;
+}
+
+const gdouble *
+gvc_channel_map_get_volume (GvcChannelMap *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        map->priv->extern_volume[VOLUME] = (gdouble) pa_cvolume_max (&map->priv->pa_volume);
+        if (gvc_channel_map_can_balance (map))
+                map->priv->extern_volume[BALANCE] = (gdouble) pa_cvolume_get_balance (&map->priv->pa_volume, &map->priv->pa_map);
+        else
+                map->priv->extern_volume[BALANCE] = 0;
+        if (gvc_channel_map_can_fade (map))
+                map->priv->extern_volume[FADE] = (gdouble) pa_cvolume_get_fade (&map->priv->pa_volume, &map->priv->pa_map);
+        else
+                map->priv->extern_volume[FADE] = 0;
+        if (gvc_channel_map_has_lfe (map))
+                map->priv->extern_volume[LFE] = (gdouble) pa_cvolume_get_position (&map->priv->pa_volume, &map->priv->pa_map, PA_CHANNEL_POSITION_LFE);
+        else
+                map->priv->extern_volume[LFE] = 0;
+
+        return map->priv->extern_volume;
+}
+
+gboolean
+gvc_channel_map_can_balance (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), FALSE);
+
+        return map->priv->can_balance;
+}
+
+gboolean
+gvc_channel_map_can_fade (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), FALSE);
+
+        return map->priv->can_fade;
+}
+
+const char *
+gvc_channel_map_get_mapping (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        return pa_channel_map_to_pretty_name (&map->priv->pa_map);
+}
+
+/**
+ * gvc_channel_map_has_position: (skip)
+ *
+ * @map:
+ * @position:
+ *
+ * Returns:
+ */
+gboolean
+gvc_channel_map_has_position (const GvcChannelMap  *map,
+                              pa_channel_position_t position)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), FALSE);
+
+        return pa_channel_map_has_position (&(map->priv->pa_map), position);
+}
+
+const pa_channel_map *
+gvc_channel_map_get_pa_channel_map (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        return &map->priv->pa_map;
+}
+
+const pa_cvolume *
+gvc_channel_map_get_cvolume (const GvcChannelMap  *map)
+{
+        g_return_val_if_fail (GVC_IS_CHANNEL_MAP (map), NULL);
+
+        if (!pa_channel_map_valid(&map->priv->pa_map))
+                return NULL;
+
+        return &map->priv->pa_volume;
+}
+
+static void
+gvc_channel_map_class_init (GvcChannelMapClass *klass)
+{
+        GObjectClass   *gobject_class = G_OBJECT_CLASS (klass);
+
+        gobject_class->finalize = gvc_channel_map_finalize;
+
+        signals [VOLUME_CHANGED] =
+                g_signal_new ("volume-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcChannelMapClass, volume_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__BOOLEAN,
+                              G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
+
+        g_type_class_add_private (klass, sizeof (GvcChannelMapPrivate));
+}
+
+void
+gvc_channel_map_volume_changed (GvcChannelMap     *map,
+                                const pa_cvolume  *cv,
+                                gboolean           set)
+{
+        g_return_if_fail (GVC_IS_CHANNEL_MAP (map));
+        g_return_if_fail (cv != NULL);
+        g_return_if_fail (pa_cvolume_compatible_with_channel_map(cv, &map->priv->pa_map));
+
+        if (pa_cvolume_equal(cv, &map->priv->pa_volume))
+                return;
+
+        map->priv->pa_volume = *cv;
+
+        if (map->priv->pa_volume_is_set == FALSE) {
+                map->priv->pa_volume_is_set = TRUE;
+                return;
+        }
+        g_signal_emit (map, signals[VOLUME_CHANGED], 0, set);
+}
+
+static void
+gvc_channel_map_init (GvcChannelMap *map)
+{
+        map->priv = GVC_CHANNEL_MAP_GET_PRIVATE (map);
+        map->priv->pa_volume_is_set = FALSE;
+}
+
+static void
+gvc_channel_map_finalize (GObject *object)
+{
+        GvcChannelMap *channel_map;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_CHANNEL_MAP (object));
+
+        channel_map = GVC_CHANNEL_MAP (object);
+
+        g_return_if_fail (channel_map->priv != NULL);
+
+        G_OBJECT_CLASS (gvc_channel_map_parent_class)->finalize (object);
+}
+
+GvcChannelMap *
+gvc_channel_map_new (void)
+{
+        GObject *map;
+        map = g_object_new (GVC_TYPE_CHANNEL_MAP, NULL);
+        return GVC_CHANNEL_MAP (map);
+}
+
+static void
+set_from_pa_map (GvcChannelMap        *map,
+                 const pa_channel_map *pa_map)
+{
+        g_assert (pa_channel_map_valid(pa_map));
+
+        map->priv->can_balance = pa_channel_map_can_balance (pa_map);
+        map->priv->can_fade = pa_channel_map_can_fade (pa_map);
+
+        map->priv->pa_map = *pa_map;
+        pa_cvolume_set(&map->priv->pa_volume, pa_map->channels, PA_VOLUME_NORM);
+}
+
+GvcChannelMap *
+gvc_channel_map_new_from_pa_channel_map (const pa_channel_map *pa_map)
+{
+        GObject *map;
+        map = g_object_new (GVC_TYPE_CHANNEL_MAP, NULL);
+
+        set_from_pa_map (GVC_CHANNEL_MAP (map), pa_map);
+
+        return GVC_CHANNEL_MAP (map);
+}
Index: gnome-control-center/panels/sound-nua/gvc-channel-map.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-channel-map.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,73 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_CHANNEL_MAP_H
+#define __GVC_CHANNEL_MAP_H
+
+#include <glib-object.h>
+#include <gvc-pulseaudio-fake.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_CHANNEL_MAP         (gvc_channel_map_get_type ())
+#define GVC_CHANNEL_MAP(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_CHANNEL_MAP, GvcChannelMap))
+#define GVC_CHANNEL_MAP_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_CHANNEL_MAP, GvcChannelMapClass))
+#define GVC_IS_CHANNEL_MAP(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_CHANNEL_MAP))
+#define GVC_IS_CHANNEL_MAP_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_CHANNEL_MAP))
+#define GVC_CHANNEL_MAP_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_CHANNEL_MAP, GvcChannelMapClass))
+
+typedef struct GvcChannelMapPrivate GvcChannelMapPrivate;
+
+typedef struct
+{
+        GObject               parent;
+        GvcChannelMapPrivate *priv;
+} GvcChannelMap;
+
+typedef struct
+{
+        GObjectClass           parent_class;
+        void (*volume_changed) (GvcChannelMap *channel_map, gboolean set);
+} GvcChannelMapClass;
+
+enum {
+        VOLUME,
+        BALANCE,
+        FADE,
+        LFE,
+        NUM_TYPES
+};
+
+GType                   gvc_channel_map_get_type                (void);
+
+GvcChannelMap *         gvc_channel_map_new                     (void);
+guint                   gvc_channel_map_get_num_channels        (const GvcChannelMap  *map);
+const gdouble *         gvc_channel_map_get_volume              (GvcChannelMap  *map);
+gboolean                gvc_channel_map_can_balance             (const GvcChannelMap  *map);
+gboolean                gvc_channel_map_can_fade                (const GvcChannelMap  *map);
+gboolean                gvc_channel_map_has_position            (const GvcChannelMap  *map,
+                                                                 pa_channel_position_t position);
+#define                 gvc_channel_map_has_lfe(x)              gvc_channel_map_has_position (x, PA_CHANNEL_POSITION_LFE)
+
+const char *            gvc_channel_map_get_mapping             (const GvcChannelMap  *map);
+
+G_END_DECLS
+
+#endif /* __GVC_CHANNEL_MAP_H */
Index: gnome-control-center/panels/sound-nua/gvc-combo-box.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-combo-box.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,398 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Bastien Nocera
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-combo-box.h"
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-card.h"
+
+#define GVC_COMBO_BOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_COMBO_BOX, GvcComboBoxPrivate))
+
+struct GvcComboBoxPrivate
+{
+        GtkWidget     *drop_box;
+        GtkWidget     *start_box;
+        GtkWidget     *end_box;
+        GtkWidget     *label;
+        GtkWidget     *button;
+        GtkTreeModel  *model;
+        GtkWidget     *combobox;
+        gboolean       set_called;
+        GtkSizeGroup  *size_group;
+        gboolean       symmetric;
+};
+
+enum {
+        COL_NAME,
+        COL_HUMAN_NAME,
+        NUM_COLS
+};
+
+enum {
+        CHANGED,
+        BUTTON_CLICKED,
+        LAST_SIGNAL
+};
+
+enum {
+        PROP_0,
+        PROP_LABEL,
+        PROP_SHOW_BUTTON,
+        PROP_BUTTON_LABEL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void     gvc_combo_box_class_init (GvcComboBoxClass *klass);
+static void     gvc_combo_box_init       (GvcComboBox      *combo_box);
+static void     gvc_combo_box_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcComboBox, gvc_combo_box, GTK_TYPE_HBOX)
+
+void
+gvc_combo_box_set_size_group (GvcComboBox *combo_box,
+                              GtkSizeGroup  *group,
+                              gboolean       symmetric)
+{
+        g_return_if_fail (GVC_IS_COMBO_BOX (combo_box));
+
+        combo_box->priv->size_group = group;
+        combo_box->priv->symmetric = symmetric;
+
+        if (combo_box->priv->size_group != NULL) {
+                gtk_size_group_add_widget (combo_box->priv->size_group,
+                                           combo_box->priv->start_box);
+
+                if (combo_box->priv->symmetric) {
+                        gtk_size_group_add_widget (combo_box->priv->size_group,
+                                                   combo_box->priv->end_box);
+                }
+        }
+        gtk_widget_queue_draw (GTK_WIDGET (combo_box));
+}
+
+static void
+gvc_combo_box_set_property (GObject       *object,
+                            guint          prop_id,
+                            const GValue  *value,
+                            GParamSpec    *pspec)
+{
+        GvcComboBox *self = GVC_COMBO_BOX (object);
+
+        switch (prop_id) {
+        case PROP_LABEL:
+                gtk_label_set_text_with_mnemonic (GTK_LABEL (self->priv->label), g_value_get_string (value));
+                break;
+        case PROP_BUTTON_LABEL:
+                gtk_button_set_label (GTK_BUTTON (self->priv->button), g_value_get_string (value));
+                break;
+        case PROP_SHOW_BUTTON:
+                gtk_widget_set_visible (self->priv->button, g_value_get_boolean (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_combo_box_get_property (GObject     *object,
+                            guint        prop_id,
+                            GValue      *value,
+                            GParamSpec  *pspec)
+{
+        GvcComboBox *self = GVC_COMBO_BOX (object);
+
+        switch (prop_id) {
+        case PROP_LABEL:
+                g_value_set_string (value,
+                                    gtk_label_get_text (GTK_LABEL (self->priv->label)));
+                break;
+        case PROP_BUTTON_LABEL:
+                g_value_set_string (value,
+                                    gtk_button_get_label (GTK_BUTTON (self->priv->button)));
+                break;
+        case PROP_SHOW_BUTTON:
+                g_value_set_boolean (value,
+                                     gtk_widget_get_visible (self->priv->button));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_combo_box_class_init (GvcComboBoxClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gvc_combo_box_finalize;
+        object_class->set_property = gvc_combo_box_set_property;
+        object_class->get_property = gvc_combo_box_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_LABEL,
+                                         g_param_spec_string ("label",
+                                                              "label",
+                                                              "The combo box label",
+                                                              _("_Profile:"),
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_SHOW_BUTTON,
+                                         g_param_spec_boolean ("show-button",
+                                                               "show-button",
+                                                               "Whether to show the button",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_BUTTON_LABEL,
+                                         g_param_spec_string ("button-label",
+                                                              "button-label",
+                                                              "The button's label",
+                                                              "APPLICATION BUG",
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        signals [CHANGED] =
+                g_signal_new ("changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcComboBoxClass, changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__STRING,
+                              G_TYPE_NONE, 1, G_TYPE_STRING);
+        signals [BUTTON_CLICKED] =
+                g_signal_new ("button-clicked",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcComboBoxClass, button_clicked),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__VOID,
+                              G_TYPE_NONE, 0, G_TYPE_NONE);
+
+        g_type_class_add_private (klass, sizeof (GvcComboBoxPrivate));
+}
+
+void
+gvc_combo_box_set_profiles (GvcComboBox *combo_box,
+                            const GList       *profiles)
+{
+        const GList *l;
+
+        g_return_if_fail (GVC_IS_COMBO_BOX (combo_box));
+        g_return_if_fail (combo_box->priv->set_called == FALSE);
+
+        for (l = profiles; l != NULL; l = l->next) {
+                GvcMixerCardProfile *p = l->data;
+
+                gtk_list_store_insert_with_values (GTK_LIST_STORE (combo_box->priv->model),
+                                                   NULL,
+                                                   G_MAXINT,
+                                                   COL_NAME, p->profile,
+                                                   COL_HUMAN_NAME, p->human_profile,
+                                                   -1);
+        }
+        combo_box->priv->set_called = TRUE;
+}
+
+void
+gvc_combo_box_set_ports (GvcComboBox *combo_box,
+                         const GList       *ports)
+{
+        const GList *l;
+
+        g_return_if_fail (GVC_IS_COMBO_BOX (combo_box));
+        g_return_if_fail (combo_box->priv->set_called == FALSE);
+
+        for (l = ports; l != NULL; l = l->next) {
+                GvcMixerStreamPort *p = l->data;
+
+                gtk_list_store_insert_with_values (GTK_LIST_STORE (combo_box->priv->model),
+                                                   NULL,
+                                                   G_MAXINT,
+                                                   COL_NAME, p->port,
+                                                   COL_HUMAN_NAME, p->human_port,
+                                                   -1);
+        }
+        combo_box->priv->set_called = TRUE;
+}
+
+void
+gvc_combo_box_set_active (GvcComboBox *combo_box,
+                          const char  *id)
+{
+        GtkTreeIter iter;
+        gboolean cont;
+
+        cont = gtk_tree_model_get_iter_first (combo_box->priv->model, &iter);
+        while (cont != FALSE) {
+                char *name;
+
+                gtk_tree_model_get (combo_box->priv->model, &iter,
+                                    COL_NAME, &name,
+                                    -1);
+                if (g_strcmp0 (name, id) == 0) {
+                        gtk_combo_box_set_active_iter (GTK_COMBO_BOX (combo_box->priv->combobox), &iter);
+                        return;
+                }
+                cont = gtk_tree_model_iter_next (combo_box->priv->model, &iter);
+        }
+        g_warning ("Could not find id '%s' in combo box", id);
+}
+
+static void
+on_combo_box_changed (GtkComboBox *widget,
+                      GvcComboBox *combo_box)
+{
+        GtkTreeIter          iter;
+        char                *profile;
+
+        if (gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter) == FALSE) {
+                g_warning ("Could not find an active profile or port");
+                return;
+        }
+
+        gtk_tree_model_get (combo_box->priv->model, &iter,
+                            COL_NAME, &profile,
+                            -1);
+        g_signal_emit (combo_box, signals[CHANGED], 0, profile);
+        g_free (profile);
+}
+
+static void
+on_combo_box_button_clicked (GtkButton   *button,
+                             GvcComboBox *combo_box)
+{
+        g_signal_emit (combo_box, signals[BUTTON_CLICKED], 0);
+}
+
+static void
+gvc_combo_box_init (GvcComboBox *combo_box)
+{
+        GtkWidget *frame;
+        GtkWidget            *box;
+        GtkWidget            *sbox;
+        GtkWidget            *ebox;
+        GtkCellRenderer      *renderer;
+
+        combo_box->priv = GVC_COMBO_BOX_GET_PRIVATE (combo_box);
+
+        combo_box->priv->model = GTK_TREE_MODEL (gtk_list_store_new (NUM_COLS,
+                                                                     G_TYPE_STRING,
+                                                                     G_TYPE_STRING));
+
+        combo_box->priv->label = gtk_label_new (NULL);
+        gtk_misc_set_alignment (GTK_MISC (combo_box->priv->label),
+                                0.0,
+                                0.5);
+
+        /* frame */
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+        gtk_container_add (GTK_CONTAINER (combo_box), frame);
+
+        combo_box->priv->drop_box = box = gtk_hbox_new (FALSE, 6);
+        combo_box->priv->combobox = gtk_combo_box_new_with_model (combo_box->priv->model);
+        renderer = gtk_cell_renderer_text_new ();
+        gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box->priv->combobox),
+                                    renderer, TRUE);
+        gtk_cell_layout_add_attribute (GTK_CELL_LAYOUT (combo_box->priv->combobox),
+                                       renderer,
+                                       "text", COL_HUMAN_NAME);
+
+        /* Make sure that the combo box isn't too wide when human names are overly long,
+         * but that we can still read the full length of it */
+        g_object_set (G_OBJECT (renderer), "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+        g_object_set (G_OBJECT (combo_box->priv->combobox), "popup-fixed-width", FALSE, NULL);
+
+        combo_box->priv->start_box = sbox = gtk_hbox_new (FALSE, 6);
+        gtk_box_pack_start (GTK_BOX (box), sbox, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (sbox), combo_box->priv->label, FALSE, FALSE, 0);
+
+        gtk_box_pack_start (GTK_BOX (box), combo_box->priv->combobox, TRUE, TRUE, 0);
+
+        combo_box->priv->button = gtk_button_new_with_label ("APPLICATION BUG");
+        gtk_button_set_use_underline (GTK_BUTTON (combo_box->priv->button), TRUE);
+        gtk_widget_set_no_show_all (combo_box->priv->button, TRUE);
+        gtk_box_pack_start (GTK_BOX (box), combo_box->priv->button, FALSE, FALSE, 0);
+
+
+        combo_box->priv->end_box = ebox = gtk_hbox_new (FALSE, 6);
+        gtk_box_pack_start (GTK_BOX (box), ebox, FALSE, FALSE, 0);
+
+        if (combo_box->priv->size_group != NULL) {
+                gtk_size_group_add_widget (combo_box->priv->size_group, sbox);
+
+                if (combo_box->priv->symmetric) {
+                        gtk_size_group_add_widget (combo_box->priv->size_group, ebox);
+                }
+        }
+
+        gtk_container_add (GTK_CONTAINER (frame), combo_box->priv->drop_box);
+        gtk_widget_show_all (frame);
+
+        gtk_label_set_mnemonic_widget (GTK_LABEL (combo_box->priv->label),
+                                       combo_box->priv->combobox);
+
+        g_signal_connect (G_OBJECT (combo_box->priv->combobox), "changed",
+                          G_CALLBACK (on_combo_box_changed), combo_box);
+        g_signal_connect (G_OBJECT (combo_box->priv->button), "clicked",
+                          G_CALLBACK (on_combo_box_button_clicked), combo_box);
+}
+
+static void
+gvc_combo_box_finalize (GObject *object)
+{
+        GvcComboBox *combo_box;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_COMBO_BOX (object));
+
+        combo_box = GVC_COMBO_BOX (object);
+
+        g_return_if_fail (combo_box->priv != NULL);
+
+        g_object_unref (combo_box->priv->model);
+        combo_box->priv->model = NULL;
+
+        G_OBJECT_CLASS (gvc_combo_box_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_combo_box_new (const char *label)
+{
+        GObject *combo_box;
+        combo_box = g_object_new (GVC_TYPE_COMBO_BOX,
+                                  "label", label,
+                                  NULL);
+        return GTK_WIDGET (combo_box);
+}
+
Index: gnome-control-center/panels/sound-nua/gvc-combo-box.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-combo-box.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,66 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_COMBO_BOX_H
+#define __GVC_COMBO_BOX_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_COMBO_BOX         (gvc_combo_box_get_type ())
+#define GVC_COMBO_BOX(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_COMBO_BOX, GvcComboBox))
+#define GVC_COMBO_BOX_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_COMBO_BOX, GvcComboBoxClass))
+#define GVC_IS_COMBO_BOX(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_COMBO_BOX))
+#define GVC_IS_COMBO_BOX_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_COMBO_BOX))
+#define GVC_COMBO_BOX_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_COMBO_BOX, GvcComboBoxClass))
+
+typedef struct GvcComboBoxPrivate GvcComboBoxPrivate;
+
+typedef struct
+{
+        GtkHBox               parent;
+        GvcComboBoxPrivate *priv;
+} GvcComboBox;
+
+typedef struct
+{
+        GtkHBoxClass            parent_class;
+        void (* changed)        (GvcComboBox *combobox, const char *name);
+        void (* button_clicked) (GvcComboBox *combobox);
+} GvcComboBoxClass;
+
+GType                   gvc_combo_box_get_type            (void);
+
+GtkWidget *             gvc_combo_box_new                 (const char   *label);
+
+void                   gvc_combo_box_set_size_group      (GvcComboBox  *combo_box,
+                                                           GtkSizeGroup *group,
+                                                           gboolean      symmetric);
+
+void                    gvc_combo_box_set_profiles        (GvcComboBox  *combo_box,
+                                                            const GList  *profiles);
+void                    gvc_combo_box_set_ports           (GvcComboBox  *combo_box,
+                                                            const GList  *ports);
+void                    gvc_combo_box_set_active          (GvcComboBox  *combo_box,
+                                                           const char   *id);
+G_END_DECLS
+
+#endif /* __GVC_COMBO_BOX_H */
Index: gnome-control-center/panels/sound-nua/gvc-level-bar.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-level-bar.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,770 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann <william.jon.mccann@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include "gvc-level-bar.h"
+
+#define NUM_BOXES 30
+
+#define GVC_LEVEL_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_LEVEL_BAR, GvcLevelBarPrivate))
+
+#define MIN_HORIZONTAL_BAR_WIDTH   150
+#define HORIZONTAL_BAR_HEIGHT      6
+#define VERTICAL_BAR_WIDTH         6
+#define MIN_VERTICAL_BAR_HEIGHT    400
+
+typedef struct {
+        int          peak_num;
+        int          max_peak_num;
+
+        GdkRectangle area;
+        int          delta;
+        int          box_width;
+        int          box_height;
+        int          box_radius;
+        double       bg_r;
+        double       bg_g;
+        double       bg_b;
+        double       bdr_r;
+        double       bdr_g;
+        double       bdr_b;
+        double       fl_r;
+        double       fl_g;
+        double       fl_b;
+} LevelBarLayout;
+
+struct GvcLevelBarPrivate
+{
+        GtkOrientation orientation;
+        GtkAdjustment *peak_adjustment;
+        GtkAdjustment *rms_adjustment;
+        int            scale;
+        gdouble        peak_fraction;
+        gdouble        rms_fraction;
+        gdouble        max_peak;
+        guint          max_peak_id;
+        LevelBarLayout layout;
+};
+
+enum
+{
+        PROP_0,
+        PROP_PEAK_ADJUSTMENT,
+        PROP_RMS_ADJUSTMENT,
+        PROP_SCALE,
+        PROP_ORIENTATION,
+};
+
+static void     gvc_level_bar_class_init (GvcLevelBarClass *klass);
+static void     gvc_level_bar_init       (GvcLevelBar      *level_bar);
+static void     gvc_level_bar_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcLevelBar, gvc_level_bar, GTK_TYPE_WIDGET)
+
+#define check_rectangle(rectangle1, rectangle2)                          \
+        {                                                                \
+                /* .x and .y are always 0 */                             \
+                if (rectangle1.width  != rectangle2.width)  return TRUE; \
+                if (rectangle1.height != rectangle2.height) return TRUE; \
+        }
+
+static gboolean
+layout_changed (LevelBarLayout *layout1,
+                LevelBarLayout *layout2)
+{
+        check_rectangle (layout1->area, layout2->area);
+        if (layout1->delta != layout2->delta) return TRUE;
+        if (layout1->peak_num != layout2->peak_num) return TRUE;
+        if (layout1->max_peak_num != layout2->max_peak_num) return TRUE;
+        if (layout1->bg_r != layout2->bg_r
+            || layout1->bg_g != layout2->bg_g
+            || layout1->bg_b != layout2->bg_b)
+                return TRUE;
+        if (layout1->bdr_r != layout2->bdr_r
+            || layout1->bdr_g != layout2->bdr_g
+            || layout1->bdr_b != layout2->bdr_b)
+                return TRUE;
+        if (layout1->fl_r != layout2->fl_r
+            || layout1->fl_g != layout2->fl_g
+            || layout1->fl_b != layout2->fl_b)
+                return TRUE;
+
+        return FALSE;
+}
+
+static gdouble
+fraction_from_adjustment (GvcLevelBar   *bar,
+                          GtkAdjustment *adjustment)
+{
+        gdouble level;
+        gdouble fraction;
+        gdouble min;
+        gdouble max;
+
+        level = gtk_adjustment_get_value (adjustment);
+
+        min = gtk_adjustment_get_lower (adjustment);
+        max = gtk_adjustment_get_upper (adjustment);
+
+        switch (bar->priv->scale) {
+        case GVC_LEVEL_SCALE_LINEAR:
+                fraction = (level - min) / (max - min);
+                break;
+        case GVC_LEVEL_SCALE_LOG:
+                fraction = log10 ((level - min + 1) / (max - min + 1));
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        return fraction;
+}
+
+static gboolean
+reset_max_peak (GvcLevelBar *bar)
+{
+        gdouble min;
+
+        min = gtk_adjustment_get_lower (bar->priv->peak_adjustment);
+        bar->priv->max_peak = min;
+        bar->priv->layout.max_peak_num = 0;
+        gtk_widget_queue_draw (GTK_WIDGET (bar));
+        bar->priv->max_peak_id = 0;
+        return FALSE;
+}
+
+static void
+bar_calc_layout (GvcLevelBar *bar)
+{
+        GdkColor color;
+        int      peak_level;
+        int      max_peak_level;
+        GtkAllocation allocation;
+        GtkStyle *style;
+
+        gtk_widget_get_allocation (GTK_WIDGET (bar), &allocation);
+        bar->priv->layout.area.width = allocation.width - 2;
+        bar->priv->layout.area.height = allocation.height - 2;
+
+        style = gtk_widget_get_style (GTK_WIDGET (bar));
+        color = style->bg [GTK_STATE_NORMAL];
+        bar->priv->layout.bg_r = (float)color.red / 65535.0;
+        bar->priv->layout.bg_g = (float)color.green / 65535.0;
+        bar->priv->layout.bg_b = (float)color.blue / 65535.0;
+        color = style->dark [GTK_STATE_NORMAL];
+        bar->priv->layout.bdr_r = (float)color.red / 65535.0;
+        bar->priv->layout.bdr_g = (float)color.green / 65535.0;
+        bar->priv->layout.bdr_b = (float)color.blue / 65535.0;
+        color = style->bg [GTK_STATE_SELECTED];
+        bar->priv->layout.fl_r = (float)color.red / 65535.0;
+        bar->priv->layout.fl_g = (float)color.green / 65535.0;
+        bar->priv->layout.fl_b = (float)color.blue / 65535.0;
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                peak_level = bar->priv->peak_fraction * bar->priv->layout.area.height;
+                max_peak_level = bar->priv->max_peak * bar->priv->layout.area.height;
+
+                bar->priv->layout.delta = bar->priv->layout.area.height / NUM_BOXES;
+                bar->priv->layout.area.x = 0;
+                bar->priv->layout.area.y = 0;
+                bar->priv->layout.box_height = bar->priv->layout.delta / 2;
+                bar->priv->layout.box_width = bar->priv->layout.area.width;
+                bar->priv->layout.box_radius = bar->priv->layout.box_width / 2;
+        } else {
+                peak_level = bar->priv->peak_fraction * bar->priv->layout.area.width;
+                max_peak_level = bar->priv->max_peak * bar->priv->layout.area.width;
+
+                bar->priv->layout.delta = bar->priv->layout.area.width / NUM_BOXES;
+                bar->priv->layout.area.x = 0;
+                bar->priv->layout.area.y = 0;
+                bar->priv->layout.box_width = bar->priv->layout.delta / 2;
+                bar->priv->layout.box_height = bar->priv->layout.area.height;
+                bar->priv->layout.box_radius = bar->priv->layout.box_height / 2;
+        }
+
+        /* This can happen if the level bar isn't realized */
+        if (bar->priv->layout.delta == 0)
+                return;
+
+        bar->priv->layout.peak_num = peak_level / bar->priv->layout.delta;
+        bar->priv->layout.max_peak_num = max_peak_level / bar->priv->layout.delta;
+}
+
+static void
+update_peak_value (GvcLevelBar *bar)
+{
+        gdouble        val;
+        LevelBarLayout layout;
+
+        layout = bar->priv->layout;
+
+        val = fraction_from_adjustment (bar, bar->priv->peak_adjustment);
+        bar->priv->peak_fraction = val;
+
+        if (val > bar->priv->max_peak) {
+                if (bar->priv->max_peak_id > 0) {
+                        g_source_remove (bar->priv->max_peak_id);
+                }
+                bar->priv->max_peak_id = g_timeout_add_seconds (1, (GSourceFunc)reset_max_peak, bar);
+                bar->priv->max_peak = val;
+        }
+
+        bar_calc_layout (bar);
+
+        if (layout_changed (&bar->priv->layout, &layout)) {
+                gtk_widget_queue_draw (GTK_WIDGET (bar));
+        }
+}
+
+static void
+update_rms_value (GvcLevelBar *bar)
+{
+        gdouble val;
+
+        val = fraction_from_adjustment (bar, bar->priv->rms_adjustment);
+        bar->priv->rms_fraction = val;
+}
+
+GtkOrientation
+gvc_level_bar_get_orientation (GvcLevelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (bar), 0);
+        return bar->priv->orientation;
+}
+
+void
+gvc_level_bar_set_orientation (GvcLevelBar   *bar,
+                               GtkOrientation orientation)
+{
+        g_return_if_fail (GVC_IS_LEVEL_BAR (bar));
+
+        if (orientation != bar->priv->orientation) {
+                bar->priv->orientation = orientation;
+                gtk_widget_queue_draw (GTK_WIDGET (bar));
+                g_object_notify (G_OBJECT (bar), "orientation");
+        }
+}
+
+static void
+on_peak_adjustment_value_changed (GtkAdjustment *adjustment,
+                                  GvcLevelBar   *bar)
+{
+        update_peak_value (bar);
+}
+
+static void
+on_rms_adjustment_value_changed (GtkAdjustment *adjustment,
+                                 GvcLevelBar   *bar)
+{
+        update_rms_value (bar);
+}
+
+void
+gvc_level_bar_set_peak_adjustment (GvcLevelBar   *bar,
+                                   GtkAdjustment *adjustment)
+{
+        g_return_if_fail (GVC_LEVEL_BAR (bar));
+        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+        if (bar->priv->peak_adjustment != NULL) {
+                g_signal_handlers_disconnect_by_func (bar->priv->peak_adjustment,
+                                                      G_CALLBACK (on_peak_adjustment_value_changed),
+                                                      bar);
+                g_object_unref (bar->priv->peak_adjustment);
+        }
+
+        bar->priv->peak_adjustment = g_object_ref_sink (adjustment);
+
+        g_signal_connect (bar->priv->peak_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_peak_adjustment_value_changed),
+                          bar);
+
+        update_peak_value (bar);
+
+        g_object_notify (G_OBJECT (bar), "peak-adjustment");
+}
+
+void
+gvc_level_bar_set_rms_adjustment (GvcLevelBar   *bar,
+                                  GtkAdjustment *adjustment)
+{
+        g_return_if_fail (GVC_LEVEL_BAR (bar));
+        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+        if (bar->priv->rms_adjustment != NULL) {
+                g_signal_handlers_disconnect_by_func (bar->priv->peak_adjustment,
+                                                      G_CALLBACK (on_rms_adjustment_value_changed),
+                                                      bar);
+                g_object_unref (bar->priv->rms_adjustment);
+        }
+
+        bar->priv->rms_adjustment = g_object_ref_sink (adjustment);
+
+
+        g_signal_connect (bar->priv->peak_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_peak_adjustment_value_changed),
+                          bar);
+
+        update_rms_value (bar);
+
+        g_object_notify (G_OBJECT (bar), "rms-adjustment");
+}
+
+GtkAdjustment *
+gvc_level_bar_get_peak_adjustment (GvcLevelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (bar), NULL);
+
+        return bar->priv->peak_adjustment;
+}
+
+GtkAdjustment *
+gvc_level_bar_get_rms_adjustment (GvcLevelBar *bar)
+{
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (bar), NULL);
+
+        return bar->priv->rms_adjustment;
+}
+
+void
+gvc_level_bar_set_scale (GvcLevelBar  *bar,
+                         GvcLevelScale scale)
+{
+        g_return_if_fail (GVC_IS_LEVEL_BAR (bar));
+
+        if (scale != bar->priv->scale) {
+                bar->priv->scale = scale;
+
+                update_peak_value (bar);
+                update_rms_value (bar);
+
+                g_object_notify (G_OBJECT (bar), "scale");
+        }
+}
+
+static void
+gvc_level_bar_set_property (GObject       *object,
+                              guint          prop_id,
+                              const GValue  *value,
+                              GParamSpec    *pspec)
+{
+        GvcLevelBar *self = GVC_LEVEL_BAR (object);
+
+        switch (prop_id) {
+        case PROP_SCALE:
+                gvc_level_bar_set_scale (self, g_value_get_int (value));
+                break;
+        case PROP_ORIENTATION:
+                gvc_level_bar_set_orientation (self, g_value_get_enum (value));
+                break;
+        case PROP_PEAK_ADJUSTMENT:
+                gvc_level_bar_set_peak_adjustment (self, g_value_get_object (value));
+                break;
+        case PROP_RMS_ADJUSTMENT:
+                gvc_level_bar_set_rms_adjustment (self, g_value_get_object (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_level_bar_get_property (GObject     *object,
+                              guint        prop_id,
+                              GValue      *value,
+                              GParamSpec  *pspec)
+{
+        GvcLevelBar *self = GVC_LEVEL_BAR (object);
+
+        switch (prop_id) {
+        case PROP_SCALE:
+                g_value_set_int (value, self->priv->scale);
+                break;
+        case PROP_ORIENTATION:
+                g_value_set_enum (value, self->priv->orientation);
+                break;
+        case PROP_PEAK_ADJUSTMENT:
+                g_value_set_object (value, self->priv->peak_adjustment);
+                break;
+        case PROP_RMS_ADJUSTMENT:
+                g_value_set_object (value, self->priv->rms_adjustment);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_level_bar_constructor (GType                  type,
+                           guint                  n_construct_properties,
+                           GObjectConstructParam *construct_params)
+{
+        return G_OBJECT_CLASS (gvc_level_bar_parent_class)->constructor (type, n_construct_properties, construct_params);
+}
+
+static void
+gvc_level_bar_size_request (GtkWidget      *widget,
+                            GtkRequisition *requisition)
+{
+        GvcLevelBar *bar = GVC_LEVEL_BAR (widget);
+
+        switch (bar->priv->orientation) {
+        case GTK_ORIENTATION_VERTICAL:
+                requisition->width = VERTICAL_BAR_WIDTH;
+                requisition->height = MIN_VERTICAL_BAR_HEIGHT;
+                break;
+        case GTK_ORIENTATION_HORIZONTAL:
+                requisition->width = MIN_HORIZONTAL_BAR_WIDTH;
+                requisition->height = HORIZONTAL_BAR_HEIGHT;
+                break;
+        default:
+                g_assert_not_reached ();
+                break;
+        }
+}
+
+static void
+gvc_level_bar_get_preferred_width (GtkWidget *widget,
+                                   gint      *minimum,
+                                   gint      *natural)
+{
+        GtkRequisition requisition;
+
+        gvc_level_bar_size_request (widget, &requisition);
+
+        if (minimum != NULL) {
+                *minimum = requisition.width;
+        }
+        if (natural != NULL) {
+                *natural = requisition.width;
+        }
+}
+
+static void
+gvc_level_bar_get_preferred_height (GtkWidget *widget,
+                                    gint      *minimum,
+                                    gint      *natural)
+{
+        GtkRequisition requisition;
+
+        gvc_level_bar_size_request (widget, &requisition);
+
+        if (minimum != NULL) {
+                *minimum = requisition.height;
+        }
+        if (natural != NULL) {
+                *natural = requisition.height;
+        }
+}
+
+static void
+gvc_level_bar_size_allocate (GtkWidget     *widget,
+                             GtkAllocation *allocation)
+{
+        GvcLevelBar *bar;
+
+        g_return_if_fail (GVC_IS_LEVEL_BAR (widget));
+        g_return_if_fail (allocation != NULL);
+
+        bar = GVC_LEVEL_BAR (widget);
+
+        /* FIXME: add height property, labels, etc */
+        GTK_WIDGET_CLASS (gvc_level_bar_parent_class)->size_allocate (widget, allocation);
+
+        gtk_widget_set_allocation (widget, allocation);
+        gtk_widget_get_allocation (widget, allocation);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                allocation->height = MIN (allocation->height, MIN_VERTICAL_BAR_HEIGHT);
+                allocation->width = MAX (allocation->width, VERTICAL_BAR_WIDTH);
+        } else {
+                allocation->width = MIN (allocation->width, MIN_HORIZONTAL_BAR_WIDTH);
+                allocation->height = MAX (allocation->height, HORIZONTAL_BAR_HEIGHT);
+        }
+
+        bar_calc_layout (bar);
+}
+
+static void
+curved_rectangle (cairo_t *cr,
+                  double   x0,
+                  double   y0,
+                  double   width,
+                  double   height,
+                  double   radius)
+{
+        double x1;
+        double y1;
+
+        x1 = x0 + width;
+        y1 = y0 + height;
+
+        if (!width || !height) {
+                return;
+        }
+
+        if (width / 2 < radius) {
+                if (height / 2 < radius) {
+                        cairo_move_to  (cr, x0, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x0 ,y0, x0, y0, (x0 + x1) / 2, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x1, y1, x1, y1, (x1 + x0) / 2, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, (y0 + y1) / 2);
+                } else {
+                        cairo_move_to  (cr, x0, y0 + radius);
+                        cairo_curve_to (cr, x0, y0, x0, y0, (x0 + x1) / 2, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, y0 + radius);
+                        cairo_line_to (cr, x1, y1 - radius);
+                        cairo_curve_to (cr, x1, y1, x1, y1, (x1 + x0) / 2, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, y1 - radius);
+                }
+        } else {
+                if (height / 2 < radius) {
+                        cairo_move_to  (cr, x0, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x0, y0, x0 , y0, x0 + radius, y0);
+                        cairo_line_to (cr, x1 - radius, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, (y0 + y1) / 2);
+                        cairo_curve_to (cr, x1, y1, x1, y1, x1 - radius, y1);
+                        cairo_line_to (cr, x0 + radius, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, (y0 + y1) / 2);
+                } else {
+                        cairo_move_to  (cr, x0, y0 + radius);
+                        cairo_curve_to (cr, x0 , y0, x0 , y0, x0 + radius, y0);
+                        cairo_line_to (cr, x1 - radius, y0);
+                        cairo_curve_to (cr, x1, y0, x1, y0, x1, y0 + radius);
+                        cairo_line_to (cr, x1, y1 - radius);
+                        cairo_curve_to (cr, x1, y1, x1, y1, x1 - radius, y1);
+                        cairo_line_to (cr, x0 + radius, y1);
+                        cairo_curve_to (cr, x0, y1, x0, y1, x0, y1 - radius);
+                }
+        }
+
+        cairo_close_path (cr);
+}
+
+static int
+gvc_level_bar_draw (GtkWidget *widget,
+                    cairo_t   *cr)
+{
+        GvcLevelBar     *bar;
+
+        g_return_val_if_fail (GVC_IS_LEVEL_BAR (widget), FALSE);
+
+        bar = GVC_LEVEL_BAR (widget);
+
+        if (bar->priv->orientation == GTK_ORIENTATION_VERTICAL) {
+                int i;
+                int by;
+
+                for (i = 0; i < NUM_BOXES; i++) {
+                        by = i * bar->priv->layout.delta;
+                        curved_rectangle (cr,
+                                          bar->priv->layout.area.x + 0.5,
+                                          by + 0.5,
+                                          bar->priv->layout.box_width - 1,
+                                          bar->priv->layout.box_height - 1,
+                                          bar->priv->layout.box_radius);
+                        if ((bar->priv->layout.max_peak_num - 1) == i) {
+                                /* fill peak foreground */
+                                cairo_set_source_rgb (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b);
+                                cairo_fill_preserve (cr);
+                        } else if ((bar->priv->layout.peak_num - 1) >= i) {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                                /* fill foreground */
+                                cairo_set_source_rgba (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b, 0.5);
+                                cairo_fill_preserve (cr);
+                        } else {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                        }
+
+                        /* stroke border */
+                        cairo_set_source_rgb (cr, bar->priv->layout.bdr_r, bar->priv->layout.bdr_g, bar->priv->layout.bdr_b);
+                        cairo_set_line_width (cr, 1);
+                        cairo_stroke (cr);
+                }
+
+        } else {
+                int i;
+                int bx;
+
+                for (i = 0; i < NUM_BOXES; i++) {
+                        bx = i * bar->priv->layout.delta;
+                        curved_rectangle (cr,
+                                          bx + 0.5,
+                                          bar->priv->layout.area.y + 0.5,
+                                          bar->priv->layout.box_width - 1,
+                                          bar->priv->layout.box_height - 1,
+                                          bar->priv->layout.box_radius);
+
+                        if ((bar->priv->layout.max_peak_num - 1) == i) {
+                                /* fill peak foreground */
+                                cairo_set_source_rgb (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b);
+                                cairo_fill_preserve (cr);
+                        } else if ((bar->priv->layout.peak_num - 1) >= i) {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                                /* fill foreground */
+                                cairo_set_source_rgba (cr, bar->priv->layout.fl_r, bar->priv->layout.fl_g, bar->priv->layout.fl_b, 0.5);
+                                cairo_fill_preserve (cr);
+                        } else {
+                                /* fill background */
+                                cairo_set_source_rgb (cr, bar->priv->layout.bg_r, bar->priv->layout.bg_g, bar->priv->layout.bg_b);
+                                cairo_fill_preserve (cr);
+                        }
+
+                        /* stroke border */
+                        cairo_set_source_rgb (cr, bar->priv->layout.bdr_r, bar->priv->layout.bdr_g, bar->priv->layout.bdr_b);
+                        cairo_set_line_width (cr, 1);
+                        cairo_stroke (cr);
+                }
+        }
+
+        return FALSE;
+}
+
+static void
+gvc_level_bar_class_init (GvcLevelBarClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+        GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
+
+        object_class->constructor = gvc_level_bar_constructor;
+        object_class->finalize = gvc_level_bar_finalize;
+        object_class->set_property = gvc_level_bar_set_property;
+        object_class->get_property = gvc_level_bar_get_property;
+
+        widget_class->draw = gvc_level_bar_draw;
+        widget_class->get_preferred_width = gvc_level_bar_get_preferred_width;
+        widget_class->get_preferred_height = gvc_level_bar_get_preferred_height;
+        widget_class->size_allocate = gvc_level_bar_size_allocate;
+
+        g_object_class_install_property (object_class,
+                                         PROP_ORIENTATION,
+                                         g_param_spec_enum ("orientation",
+                                                            "Orientation",
+                                                            "The orientation of the bar",
+                                                            GTK_TYPE_ORIENTATION,
+                                                            GTK_ORIENTATION_HORIZONTAL,
+                                                            G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_PEAK_ADJUSTMENT,
+                                         g_param_spec_object ("peak-adjustment",
+                                                              "Peak Adjustment",
+                                                              "The GtkAdjustment that contains the current peak value",
+                                                              GTK_TYPE_ADJUSTMENT,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_RMS_ADJUSTMENT,
+                                         g_param_spec_object ("rms-adjustment",
+                                                              "RMS Adjustment",
+                                                              "The GtkAdjustment that contains the current rms value",
+                                                              GTK_TYPE_ADJUSTMENT,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (object_class,
+                                         PROP_SCALE,
+                                         g_param_spec_int ("scale",
+                                                           "Scale",
+                                                           "Scale",
+                                                           0,
+                                                           G_MAXINT,
+                                                           GVC_LEVEL_SCALE_LINEAR,
+                                                           G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcLevelBarPrivate));
+}
+
+static void
+gvc_level_bar_init (GvcLevelBar *bar)
+{
+        bar->priv = GVC_LEVEL_BAR_GET_PRIVATE (bar);
+
+        bar->priv->peak_adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                         0.0,
+                                                                         1.0,
+                                                                         0.05,
+                                                                         0.1,
+                                                                         0.1));
+        g_object_ref_sink (bar->priv->peak_adjustment);
+        g_signal_connect (bar->priv->peak_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_peak_adjustment_value_changed),
+                          bar);
+
+        bar->priv->rms_adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0,
+                                                                        0.0,
+                                                                        1.0,
+                                                                        0.05,
+                                                                        0.1,
+                                                                        0.1));
+        g_object_ref_sink (bar->priv->rms_adjustment);
+        g_signal_connect (bar->priv->rms_adjustment,
+                          "value-changed",
+                          G_CALLBACK (on_rms_adjustment_value_changed),
+                          bar);
+
+        gtk_widget_set_has_window (GTK_WIDGET (bar), FALSE);
+}
+
+static void
+gvc_level_bar_finalize (GObject *object)
+{
+        GvcLevelBar *bar;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_LEVEL_BAR (object));
+
+        bar = GVC_LEVEL_BAR (object);
+
+        if (bar->priv->max_peak_id > 0) {
+                g_source_remove (bar->priv->max_peak_id);
+        }
+
+        g_return_if_fail (bar->priv != NULL);
+
+        G_OBJECT_CLASS (gvc_level_bar_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_level_bar_new (void)
+{
+        GObject *bar;
+        bar = g_object_new (GVC_TYPE_LEVEL_BAR,
+                            NULL);
+        return GTK_WIDGET (bar);
+}
Index: gnome-control-center/panels/sound-nua/gvc-level-bar.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-level-bar.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann <william.jon.mccann@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_LEVEL_BAR_H
+#define __GVC_LEVEL_BAR_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_LEVEL_BAR         (gvc_level_bar_get_type ())
+#define GVC_LEVEL_BAR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_LEVEL_BAR, GvcLevelBar))
+#define GVC_LEVEL_BAR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_LEVEL_BAR, GvcLevelBarClass))
+#define GVC_IS_LEVEL_BAR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_LEVEL_BAR))
+#define GVC_IS_LEVEL_BAR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_LEVEL_BAR))
+#define GVC_LEVEL_BAR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_LEVEL_BAR, GvcLevelBarClass))
+
+typedef struct GvcLevelBarPrivate GvcLevelBarPrivate;
+
+typedef struct
+{
+        GtkWidget           parent;
+        GvcLevelBarPrivate *priv;
+} GvcLevelBar;
+
+typedef struct
+{
+        GtkWidgetClass      parent_class;
+} GvcLevelBarClass;
+
+typedef enum
+{
+    GVC_LEVEL_SCALE_LINEAR,
+    GVC_LEVEL_SCALE_LOG,
+    GVC_LEVEL_SCALE_LAST
+} GvcLevelScale;
+
+GType               gvc_level_bar_get_type            (void);
+
+GtkWidget *         gvc_level_bar_new                 (void);
+void                gvc_level_bar_set_orientation     (GvcLevelBar   *bar,
+                                                       GtkOrientation orientation);
+GtkOrientation      gvc_level_bar_get_orientation     (GvcLevelBar   *bar);
+
+void                gvc_level_bar_set_peak_adjustment (GvcLevelBar   *bar,
+                                                       GtkAdjustment *adjustment);
+GtkAdjustment *     gvc_level_bar_get_peak_adjustment (GvcLevelBar   *bar);
+void                gvc_level_bar_set_rms_adjustment  (GvcLevelBar   *bar,
+                                                       GtkAdjustment *adjustment);
+GtkAdjustment *     gvc_level_bar_get_rms_adjustment  (GvcLevelBar   *bar);
+void                gvc_level_bar_set_scale           (GvcLevelBar   *bar,
+                                                       GvcLevelScale  scale);
+
+
+G_END_DECLS
+
+#endif /* __GVC_LEVEL_BAR_H */
Index: gnome-control-center/panels/sound-nua/gvc-log.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-log.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,64 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gstdio.h>
+
+#include "gvc-log.h"
+
+
+static int log_levels = G_LOG_LEVEL_CRITICAL |
+                        G_LOG_LEVEL_ERROR    |
+                        G_LOG_LEVEL_WARNING  |
+                        G_LOG_LEVEL_MESSAGE  |
+                        G_LOG_LEVEL_INFO     |
+                        G_LOG_LEVEL_DEBUG;
+
+static void
+gvc_log_default_handler (const gchar    *log_domain,
+                         GLogLevelFlags  log_level,
+                         const gchar    *message,
+                         gpointer        unused_data)
+{
+        if ((log_level & log_levels) == 0)
+                return;
+
+        g_log_default_handler (log_domain, log_level, message, unused_data);
+}
+
+void
+gvc_log_init (void)
+{
+        g_log_set_default_handler (gvc_log_default_handler, NULL);
+}
+
+void
+gvc_log_set_debug (gboolean debug)
+{
+        if (debug) {
+                log_levels |= (G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO);
+                g_debug ("Enabling debugging");
+        } else {
+                log_levels &= ~ (G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO);
+        }
+}
Index: gnome-control-center/panels/sound-nua/gvc-log.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-log.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_LOG_H
+#define __GVC_LOG_H
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+
+void gvc_log_init      (void);
+void gvc_log_set_debug (gboolean debug);
+
+
+G_END_DECLS
+
+#endif /* __GVC_LOG_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-card-private.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-card-private.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CARD_PRIVATE_H
+#define __GVC_MIXER_CARD_PRIVATE_H
+
+#include <pulse/pulseaudio.h>
+#include "gvc-mixer-card.h"
+
+G_BEGIN_DECLS
+
+GvcMixerCard *        gvc_mixer_card_new               (pa_context   *context,
+                                                        guint         index);
+pa_context *          gvc_mixer_card_get_pa_context    (GvcMixerCard *card);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CARD_PRIVATE_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-card.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-card.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,549 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ * Copyright (C) 2009 Bastien Nocera
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-card-private.h"
+
+#define GVC_MIXER_CARD_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_CARD, GvcMixerCardPrivate))
+
+static guint32 card_serial = 1;
+
+struct GvcMixerCardPrivate
+{
+        pa_context    *pa_context;
+        guint          id;
+        guint          index;
+        char          *name;
+        char          *icon_name;
+        char          *profile;
+        char          *target_profile;
+        char          *human_profile;
+        GList         *profiles;
+        pa_operation  *profile_op;
+        GList	      *ports;        
+};
+
+enum
+{
+        PROP_0,
+        PROP_ID,
+        PROP_PA_CONTEXT,
+        PROP_INDEX,
+        PROP_NAME,
+        PROP_ICON_NAME,
+        PROP_PROFILE,
+        PROP_HUMAN_PROFILE,
+};
+
+static void     gvc_mixer_card_class_init (GvcMixerCardClass *klass);
+static void     gvc_mixer_card_init       (GvcMixerCard      *mixer_card);
+static void     gvc_mixer_card_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerCard, gvc_mixer_card, G_TYPE_OBJECT)
+
+static guint32
+get_next_card_serial (void)
+{
+        guint32 serial;
+
+        serial = card_serial++;
+
+        if ((gint32)card_serial < 0) {
+                card_serial = 1;
+        }
+
+        return serial;
+}
+
+pa_context *
+gvc_mixer_card_get_pa_context (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), 0);
+        return card->priv->pa_context;
+}
+
+guint
+gvc_mixer_card_get_index (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), 0);
+        return card->priv->index;
+}
+
+guint
+gvc_mixer_card_get_id (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), 0);
+        return card->priv->id;
+}
+
+const char *
+gvc_mixer_card_get_name (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->name;
+}
+
+gboolean
+gvc_mixer_card_set_name (GvcMixerCard *card,
+                         const char     *name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+
+        g_free (card->priv->name);
+        card->priv->name = g_strdup (name);
+        g_object_notify (G_OBJECT (card), "name");
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_card_get_icon_name (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->icon_name;
+}
+
+gboolean
+gvc_mixer_card_set_icon_name (GvcMixerCard *card,
+                              const char     *icon_name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+
+        g_free (card->priv->icon_name);
+        card->priv->icon_name = g_strdup (icon_name);
+        g_object_notify (G_OBJECT (card), "icon-name");
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_card_get_profile: (skip)
+ *
+ * @card:
+ *
+ * Returns:
+ */
+GvcMixerCardProfile *
+gvc_mixer_card_get_profile (GvcMixerCard *card)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        g_return_val_if_fail (card->priv->profiles != NULL, NULL);
+
+        for (l = card->priv->profiles; l != NULL; l = l->next) {
+                GvcMixerCardProfile *p = l->data;
+                if (g_str_equal (card->priv->profile, p->profile)) {
+                        return p;
+                }
+        }
+
+        g_assert_not_reached ();
+
+        return NULL;
+}
+
+gboolean
+gvc_mixer_card_set_profile (GvcMixerCard *card,
+                            const char     *profile)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->profiles != NULL, FALSE);
+
+        g_free (card->priv->profile);
+        card->priv->profile = g_strdup (profile);
+
+        g_free (card->priv->human_profile);
+        card->priv->human_profile = NULL;
+
+        for (l = card->priv->profiles; l != NULL; l = l->next) {
+                GvcMixerCardProfile *p = l->data;
+                if (g_str_equal (card->priv->profile, p->profile)) {
+                        card->priv->human_profile = g_strdup (p->human_profile);
+                        break;
+                }
+        }
+
+        g_object_notify (G_OBJECT (card), "profile");
+
+        return TRUE;
+}
+
+static void
+_pa_context_set_card_profile_by_index_cb (pa_context                       *context,
+                                          int                               success,
+                                          void                             *userdata)
+{
+        GvcMixerCard *card = GVC_MIXER_CARD (userdata);
+
+        g_assert (card->priv->target_profile);
+
+        if (success > 0) {
+                gvc_mixer_card_set_profile (card, card->priv->target_profile);
+        } else {
+                g_debug ("Failed to switch profile on '%s' from '%s' to '%s'",
+                         card->priv->name,
+                         card->priv->profile,
+                         card->priv->target_profile);
+        }
+        g_free (card->priv->target_profile);
+        card->priv->target_profile = NULL;
+
+        pa_operation_unref (card->priv->profile_op);
+        card->priv->profile_op = NULL;
+}
+
+gboolean
+gvc_mixer_card_change_profile (GvcMixerCard *card,
+                               const char *profile)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->profiles != NULL, FALSE);
+
+        /* Same profile, or already requested? */
+        if (g_strcmp0 (card->priv->profile, profile) == 0)
+                return TRUE;
+        if (g_strcmp0 (profile, card->priv->target_profile) == 0)
+                return TRUE;
+        if (card->priv->profile_op != NULL) {
+                pa_operation_cancel (card->priv->profile_op);
+                pa_operation_unref (card->priv->profile_op);
+                card->priv->profile_op = NULL;
+        }
+
+        if (card->priv->profile != NULL) {
+                g_free (card->priv->target_profile);
+                card->priv->target_profile = g_strdup (profile);
+
+                card->priv->profile_op = pa_context_set_card_profile_by_index (card->priv->pa_context,
+                                                                               card->priv->index,
+                                                                               card->priv->target_profile,
+                                                                               _pa_context_set_card_profile_by_index_cb,
+                                                                               card);
+
+                if (card->priv->profile_op == NULL) {
+                        g_warning ("pa_context_set_card_profile_by_index() failed");
+                        return FALSE;
+                }
+        } else {
+                g_assert (card->priv->human_profile == NULL);
+                card->priv->profile = g_strdup (profile);
+        }
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_card_get_profiles:
+ *
+ * Return value: (transfer none) (element-type GvcMixerCardProfile):
+ */
+const GList *
+gvc_mixer_card_get_profiles (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->profiles;
+}
+
+
+/**
+ * gvc_mixer_card_get_ports:
+ *
+ * Return value: (transfer none) (element-type GvcMixerCardPort):
+ */
+const GList *
+gvc_mixer_card_get_ports (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        return card->priv->ports;
+}
+
+/**
+ * gvc_mixer_card_set_profiles:
+ * @profiles: (transfer full) (element-type GvcMixerCardProfile):
+ */
+gboolean
+gvc_mixer_card_set_profiles (GvcMixerCard *card,
+                             GList        *profiles)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->profiles == NULL, FALSE);
+
+        card->priv->profiles = g_list_sort (profiles, (GCompareFunc) sort_profiles);
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_card_get_gicon:
+ *
+ * Return value: (transfer full) (element-type GIcon):
+ */
+GIcon *
+gvc_mixer_card_get_gicon (GvcMixerCard *card)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), NULL);
+        if (card->priv->icon_name == NULL)
+                return NULL;
+        return g_themed_icon_new_with_default_fallbacks (card->priv->icon_name);
+}
+
+/**
+ * gvc_mixer_card_set_ports:
+ * @profiles: (transfer full) (element-type GvcMixerCardPort):
+ */
+gboolean              
+gvc_mixer_card_set_ports (GvcMixerCard *card,
+                          GList          *ports)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CARD (card), FALSE);
+        g_return_val_if_fail (card->priv->ports == NULL, FALSE);
+
+        card->priv->ports = ports;
+
+        return TRUE;	
+}                                                     
+
+static void
+gvc_mixer_card_set_property (GObject       *object,
+                             guint          prop_id,
+                             const GValue  *value,
+                             GParamSpec    *pspec)
+{
+        GvcMixerCard *self = GVC_MIXER_CARD (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                self->priv->pa_context = g_value_get_pointer (value);
+                break;
+        case PROP_INDEX:
+                self->priv->index = g_value_get_ulong (value);
+                break;
+        case PROP_ID:
+                self->priv->id = g_value_get_ulong (value);
+                break;
+        case PROP_NAME:
+                gvc_mixer_card_set_name (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAME:
+                gvc_mixer_card_set_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_PROFILE:
+                gvc_mixer_card_set_profile (self, g_value_get_string (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_card_get_property (GObject     *object,
+                             guint        prop_id,
+                             GValue      *value,
+                             GParamSpec  *pspec)
+{
+        GvcMixerCard *self = GVC_MIXER_CARD (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                g_value_set_pointer (value, self->priv->pa_context);
+                break;
+        case PROP_INDEX:
+                g_value_set_ulong (value, self->priv->index);
+                break;
+        case PROP_ID:
+                g_value_set_ulong (value, self->priv->id);
+                break;
+        case PROP_NAME:
+                g_value_set_string (value, self->priv->name);
+                break;
+        case PROP_ICON_NAME:
+                g_value_set_string (value, self->priv->icon_name);
+                break;
+        case PROP_PROFILE:
+                g_value_set_string (value, self->priv->profile);
+                break;
+        case PROP_HUMAN_PROFILE:
+                g_value_set_string (value, self->priv->human_profile);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_mixer_card_constructor (GType                  type,
+                            guint                  n_construct_properties,
+                            GObjectConstructParam *construct_params)
+{
+        GObject       *object;
+        GvcMixerCard *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_card_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_CARD (object);
+
+        self->priv->id = get_next_card_serial ();
+
+        return object;
+}
+
+static void
+gvc_mixer_card_class_init (GvcMixerCardClass *klass)
+{
+        GObjectClass   *gobject_class = G_OBJECT_CLASS (klass);
+
+        gobject_class->constructor = gvc_mixer_card_constructor;
+        gobject_class->finalize = gvc_mixer_card_finalize;
+
+        gobject_class->set_property = gvc_mixer_card_set_property;
+        gobject_class->get_property = gvc_mixer_card_get_property;
+
+        g_object_class_install_property (gobject_class,
+                                         PROP_INDEX,
+                                         g_param_spec_ulong ("index",
+                                                             "Index",
+                                                             "The index for this card",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ID,
+                                         g_param_spec_ulong ("id",
+                                                             "id",
+                                                             "The id for this card",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PA_CONTEXT,
+                                         g_param_spec_pointer ("pa-context",
+                                                               "PulseAudio context",
+                                                               "The PulseAudio context for this card",
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this card",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ICON_NAME,
+                                         g_param_spec_string ("icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this card",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PROFILE,
+                                         g_param_spec_string ("profile",
+                                                              "Profile",
+                                                              "Name of current profile for this card",
+                                                              NULL,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (gobject_class,
+                                         PROP_HUMAN_PROFILE,
+                                         g_param_spec_string ("human-profile",
+                                                              "Profile (Human readable)",
+                                                              "Name of current profile for this card in human readable form",
+                                                              NULL,
+                                                              G_PARAM_READABLE));
+
+        g_type_class_add_private (klass, sizeof (GvcMixerCardPrivate));
+}
+
+static void
+gvc_mixer_card_init (GvcMixerCard *card)
+{
+        card->priv = GVC_MIXER_CARD_GET_PRIVATE (card);
+}
+
+
+GvcMixerCard *
+gvc_mixer_card_new (pa_context *context,
+                    guint       index)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_CARD,
+                               "index", index,
+                               "pa-context", context,
+                               NULL);
+        return GVC_MIXER_CARD (object);
+}
+
+static void
+free_profile (GvcMixerCardProfile *p)
+{
+        g_free (p->profile);
+        g_free (p->human_profile);
+        g_free (p->status);
+        g_free (p);
+}
+
+static void
+gvc_mixer_card_finalize (GObject *object)
+{
+        GvcMixerCard *mixer_card;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_CARD (object));
+
+        mixer_card = GVC_MIXER_CARD (object);
+
+        g_return_if_fail (mixer_card->priv != NULL);
+
+        g_free (mixer_card->priv->name);
+        mixer_card->priv->name = NULL;
+
+        g_free (mixer_card->priv->icon_name);
+        mixer_card->priv->icon_name = NULL;
+
+        g_free (mixer_card->priv->target_profile);
+        mixer_card->priv->target_profile = NULL;
+
+        g_free (mixer_card->priv->profile);
+        mixer_card->priv->profile = NULL;
+
+        g_free (mixer_card->priv->human_profile);
+        mixer_card->priv->human_profile = NULL;
+
+        g_list_foreach (mixer_card->priv->profiles, (GFunc) free_profile, NULL);
+        g_list_free (mixer_card->priv->profiles);
+        mixer_card->priv->profiles = NULL;
+
+        G_OBJECT_CLASS (gvc_mixer_card_parent_class)->finalize (object);
+}
+
Index: gnome-control-center/panels/sound-nua/gvc-mixer-card.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-card.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,108 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CARD_H
+#define __GVC_MIXER_CARD_H
+
+#include <glib-object.h>
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_CARD         (gvc_mixer_card_get_type ())
+#define GVC_MIXER_CARD(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_CARD, GvcMixerCard))
+#define GVC_MIXER_CARD_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_CARD, GvcMixerCardClass))
+#define GVC_IS_MIXER_CARD(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_CARD))
+#define GVC_IS_MIXER_CARD_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_CARD))
+#define GVC_MIXER_CARD_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_CARD, GvcMixerCardClass))
+
+typedef struct GvcMixerCardPrivate GvcMixerCardPrivate;
+
+typedef struct
+{
+        GObject                parent;
+        GvcMixerCardPrivate   *priv;
+} GvcMixerCard;
+
+typedef struct
+{
+        GObjectClass           parent_class;
+
+        /* vtable */
+} GvcMixerCardClass;
+
+typedef struct
+{
+        char *profile;
+        char *human_profile;
+        char *status;
+        guint priority;
+        guint n_sinks, n_sources;
+} GvcMixerCardProfile;
+
+typedef struct
+{
+        char *port;
+        char *human_port;
+        guint priority;
+        gint  available;
+        gint  direction;
+        GList *profiles;
+} GvcMixerCardPort;
+
+GType                 gvc_mixer_card_get_type          (void);
+
+guint                 gvc_mixer_card_get_id            (GvcMixerCard *card);
+guint                 gvc_mixer_card_get_index         (GvcMixerCard *card);
+const char *          gvc_mixer_card_get_name          (GvcMixerCard *card);
+const char *          gvc_mixer_card_get_icon_name     (GvcMixerCard *card);
+GvcMixerCardProfile * gvc_mixer_card_get_profile       (GvcMixerCard *card);
+const GList *         gvc_mixer_card_get_profiles      (GvcMixerCard *card);
+const GList *         gvc_mixer_card_get_ports         (GvcMixerCard *card);
+gboolean              gvc_mixer_card_change_profile    (GvcMixerCard *card,
+                                                        const char *profile);
+GIcon *		      gvc_mixer_card_get_gicon 	       (GvcMixerCard *card);
+
+/* private */
+gboolean              gvc_mixer_card_set_name          (GvcMixerCard *card,
+                                                        const char   *name);
+gboolean              gvc_mixer_card_set_icon_name     (GvcMixerCard *card,
+                                                        const char   *name);
+gboolean              gvc_mixer_card_set_profile       (GvcMixerCard *card,
+                                                        const char   *profile);
+gboolean              gvc_mixer_card_set_profiles      (GvcMixerCard *card,
+                                                        GList        *profiles);
+gboolean              gvc_mixer_card_set_ports         (GvcMixerCard *stream,
+                                                        GList        *ports);
+
+static int
+sort_profiles (GvcMixerCardProfile *a,
+               GvcMixerCardProfile *b)
+{
+        if (a->priority == b->priority)
+                return 0;
+        if (a->priority > b->priority)
+                return 1;
+        return -1;
+}
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CARD_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-control-private.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-control-private.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CONTROL_PRIVATE_H
+#define __GVC_MIXER_CONTROL_PRIVATE_H
+
+#include <glib-object.h>
+#include <pulse/pulseaudio.h>
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-card.h"
+
+G_BEGIN_DECLS
+
+pa_context *        gvc_mixer_control_get_pa_context      (GvcMixerControl *control);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CONTROL_PRIVATE_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-control.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-control.c	2012-02-10 14:40:47.385282961 -0500
@@ -0,0 +1,3342 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2008 Lennart Poettering
+ * Copyright (C) 2008 Sjoerd Simons <sjoerd@luon.net>
+ * Copyright (C) 2008 William Jon McCann
+ * Copyright (C) 2012 Conor Curran
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+#include <pulse/glib-mainloop.h>
+#include <pulse/ext-stream-restore.h>
+
+#include "gvc-mixer-control.h"
+#include "gvc-mixer-sink.h"
+#include "gvc-mixer-source.h"
+#include "gvc-mixer-sink-input.h"
+#include "gvc-mixer-source-output.h"
+#include "gvc-mixer-event-role.h"
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-card-private.h"
+#include "gvc-channel-map-private.h"
+#include "gvc-mixer-control-private.h"
+
+#define GVC_MIXER_CONTROL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_CONTROL, GvcMixerControlPrivate))
+
+#define RECONNECT_DELAY 5
+
+enum {
+        PROP_0,
+        PROP_NAME
+};
+
+struct GvcMixerControlPrivate
+{
+        pa_glib_mainloop *pa_mainloop;
+        pa_mainloop_api  *pa_api;
+        pa_context       *pa_context;
+        int               n_outstanding;
+        guint             reconnect_id;
+        char             *name;
+
+        gboolean          default_sink_is_set;
+        guint             default_sink_id;
+        guint             active_output_id;
+        char             *default_sink_name;
+        gboolean          default_source_is_set;
+        guint             default_source_id;
+        char             *default_source_name;
+
+        gboolean          event_sink_input_is_set;
+        guint             event_sink_input_id;
+
+        GHashTable       *all_streams;
+        GHashTable       *sinks; /* fixed outputs */
+        GHashTable       *sources; /* fixed inputs */
+        GHashTable       *sink_inputs; /* routable output streams */
+        GHashTable       *source_outputs; /* routable input streams */
+        GHashTable       *clients;
+        GHashTable       *cards;
+        GHashTable       *ui_outputs; /* Ui visible outputs */
+        GHashTable       *ui_inputs; /* Ui visible inputs */
+        guint            cached_desired_output_id;
+        guint            cached_desired_input_id;
+        GvcMixerStream   *new_default_stream; /* new default stream, used in gvc_mixer_control_set_default_sink () */
+        guint            profile_swapping_device_id;
+        GvcMixerControlState state;
+};
+
+enum {
+        STATE_CHANGED,
+        STREAM_ADDED,
+        STREAM_REMOVED,
+        CARD_ADDED,
+        CARD_REMOVED,
+        DEFAULT_SINK_CHANGED,
+        DEFAULT_SOURCE_CHANGED,
+        OUTPUT_ADDED,
+        ACTIVE_OUTPUT_UPDATE,        
+        ACTIVE_INPUT_UPDATE,        
+        INPUT_ADDED,
+        OUTPUT_REMOVED,
+        INPUT_REMOVED,
+        LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void                     gvc_mixer_control_class_init (GvcMixerControlClass *klass);
+static void                     gvc_mixer_control_init       (GvcMixerControl      *mixer_control);
+static void                     gvc_mixer_control_finalize   (GObject              *object);
+
+G_DEFINE_TYPE (GvcMixerControl, gvc_mixer_control, G_TYPE_OBJECT)
+
+pa_context *
+gvc_mixer_control_get_pa_context (GvcMixerControl *control)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+        return control->priv->pa_context;
+}
+
+/**
+ * gvc_mixer_control_get_event_sink_input:
+ *
+ * @control:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_get_event_sink_input (GvcMixerControl *control)
+{
+        GvcMixerStream *stream;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        stream = g_hash_table_lookup (control->priv->all_streams,
+                                      GUINT_TO_POINTER (control->priv->event_sink_input_id));
+
+        return stream;
+}
+
+static void
+gvc_mixer_control_stream_restore_cb (pa_context *c,
+                                     const pa_ext_stream_restore_info *info,
+                                     int eol,
+                                     void *userdata)
+{
+        pa_operation *o;
+        GvcMixerControl *control = (GvcMixerControl *) userdata;
+        pa_ext_stream_restore_info new_info;
+
+        if (eol || control->priv->new_default_stream == NULL)
+                return;
+
+        new_info.name = info->name;
+        new_info.channel_map = info->channel_map;
+        new_info.volume = info->volume;
+        new_info.mute = info->mute;
+
+        new_info.device = gvc_mixer_stream_get_name (control->priv->new_default_stream);
+
+        o = pa_ext_stream_restore_write (control->priv->pa_context,
+                                         PA_UPDATE_REPLACE,
+                                         &new_info, 1,
+                                         TRUE, NULL, NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_write() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return;
+        }
+
+        g_debug ("Changed default device for %s to %s", info->name, info->device);
+
+        pa_operation_unref (o);
+}
+
+/**
+ * TODO : make utililty methods for common needs. 
+        * Fetching the appropriate array 
+        * Determining whether the stream is a network stream
+ * gvc_mixer_control_lookup_device_from_stream:
+ * @control:
+ * @stream:
+ * Returns: GvcUIDevice (transfer none) or NULL:
+ */
+static GvcMixerUIDevice *
+gvc_mixer_control_lookup_device_from_stream (GvcMixerControl *control,
+                                             GvcMixerStream *stream)
+{
+	GList 		        *devices;
+	GList 		        *d;
+	GvcMixerUIDevice	*device;			
+
+        if (GVC_IS_MIXER_SOURCE (stream))
+               devices = g_hash_table_get_values (control->priv->ui_inputs);                
+        else{
+               devices = g_hash_table_get_values (control->priv->ui_outputs);
+        }
+
+        gboolean is_network_stream;
+        const GList *ports;
+        ports = gvc_mixer_stream_get_ports (stream);
+
+        is_network_stream = ports == NULL;
+        //g_print ("\n is_network or bluetooth stream = %i \n", is_network_stream);
+
+	for (d = devices; d != NULL; d = d->next) {		
+		device = d->data;
+		gint stream_id = -2;
+
+		g_object_get (G_OBJECT (device),
+			     "stream-id", &stream_id,
+			      NULL);
+
+                if (is_network_stream) {
+                        if (stream_id == gvc_mixer_stream_get_id (stream)) {
+                                g_print ("\n lookup device from stream - %s - it is a network_stream \n",
+                                        gvc_mixer_ui_device_get_description (device));
+                                return device;
+                        }       
+                }
+                else {
+                        const GvcMixerStreamPort *port;
+                        port = gvc_mixer_stream_get_port (stream);
+
+                        //g_print ("\n \n lookup device from stream - get port from stream %s", gvc_mixer_stream_get_description (stream));
+
+        		if (stream_id == gvc_mixer_stream_get_id (stream) &&
+                            g_strcmp0 (gvc_mixer_ui_device_get_port(device),
+                                       port->port) == 0) {
+                                g_print ("\n \n lookup-device-from-stream found device  \n device description %s \n device port = %s \n device stream id %i \n AND \n stream port = %s stream id %u and stream description %s \n",
+                                         gvc_mixer_ui_device_get_description (device),
+                                         gvc_mixer_ui_device_get_port(device),                                 
+                                         stream_id,
+                                         port->port,
+                                         gvc_mixer_stream_get_id (stream),
+                                         gvc_mixer_stream_get_description (stream));
+        			return device;
+        		}
+                }
+	}
+	g_print ("\n gvc_mixer_control_lookup_device_from_stream - Could not find a device ?  %s \n", gvc_mixer_stream_get_description (stream));		 
+	return NULL;
+}
+
+gboolean
+gvc_mixer_control_set_default_sink (GvcMixerControl *control,
+                                    GvcMixerStream  *stream)
+{
+        pa_operation *o;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_print ("\n about to set default sink on server \n");
+        o = pa_context_set_default_sink (control->priv->pa_context,
+                                         gvc_mixer_stream_get_name (stream),
+                                         NULL,
+                                         NULL);
+        if (o == NULL) {
+                g_warning ("pa_context_set_default_sink() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+
+        control->priv->new_default_stream = stream;
+        g_object_add_weak_pointer (G_OBJECT (stream), (gpointer *) &control->priv->new_default_stream);
+
+        o = pa_ext_stream_restore_read (control->priv->pa_context,
+                                        gvc_mixer_control_stream_restore_cb,
+                                        control);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_read() failed: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+        
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_control_set_default_source (GvcMixerControl *control,
+                                      GvcMixerStream  *stream)
+{
+        pa_operation *o;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        o = pa_context_set_default_source (control->priv->pa_context,
+                                           gvc_mixer_stream_get_name (stream),
+                                           NULL,
+                                           NULL);
+        if (o == NULL) {
+                g_warning ("pa_context_set_default_source() failed");
+                return FALSE;
+        }
+
+        pa_operation_unref (o);
+        // source change successfull => update the UI.
+        GvcMixerUIDevice* input;
+        input = gvc_mixer_control_lookup_device_from_stream (control, stream);
+        g_signal_emit (G_OBJECT (control),
+                       signals[ACTIVE_INPUT_UPDATE],
+                       0,
+                       gvc_mixer_ui_device_get_id (input));             
+
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_control_get_default_sink:
+ *
+ * @control:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_get_default_sink (GvcMixerControl *control)
+{
+        GvcMixerStream *stream;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        if (control->priv->default_sink_is_set) {
+                stream = g_hash_table_lookup (control->priv->all_streams,
+                                              GUINT_TO_POINTER (control->priv->default_sink_id));
+        } else {
+                stream = NULL;
+        }
+
+        return stream;
+}
+
+/**
+ * gvc_mixer_control_get_default_source:
+ *
+ * @control:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_get_default_source (GvcMixerControl *control)
+{
+        GvcMixerStream *stream;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        if (control->priv->default_source_is_set) {
+                stream = g_hash_table_lookup (control->priv->all_streams,
+                                              GUINT_TO_POINTER (control->priv->default_source_id));
+        } else {
+                stream = NULL;
+        }
+
+        return stream;
+}
+
+static gpointer
+gvc_mixer_control_lookup_id (GHashTable *hash_table,
+                             guint       id)
+{
+        return g_hash_table_lookup (hash_table,
+                                    GUINT_TO_POINTER (id));
+}
+
+/**
+ * gvc_mixer_control_lookup_stream_id:
+ *
+ * @control:
+ * @id:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerStream *
+gvc_mixer_control_lookup_stream_id (GvcMixerControl *control,
+                                    guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        return gvc_mixer_control_lookup_id (control->priv->all_streams, id);
+}
+
+/**
+ * gvc_mixer_control_lookup_card_id:
+ *
+ * @control:
+ * @id:
+ *
+ * Returns: (transfer none):
+ */
+GvcMixerCard *
+gvc_mixer_control_lookup_card_id (GvcMixerControl *control,
+                                  guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+        return gvc_mixer_control_lookup_id (control->priv->cards, id);
+}
+
+/**
+ * gvc_mixer_control_lookup_output_id:
+ * @control:
+ * @id:
+ * Returns: (transfer none):
+ */
+GvcMixerUIDevice*	
+gvc_mixer_control_lookup_output_id (GvcMixerControl *control,
+				    guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        return gvc_mixer_control_lookup_id (control->priv->ui_outputs, id);	
+}
+
+/**
+ * gvc_mixer_control_lookup_input_id:
+ * @control:
+ * @id:
+ * Returns: (transfer none):
+ */
+GvcMixerUIDevice*       
+gvc_mixer_control_lookup_input_id (GvcMixerControl *control,
+                                    guint            id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        return gvc_mixer_control_lookup_id (control->priv->ui_inputs, id);     
+}
+
+gchar*
+gvc_mixer_control_get_active_profile_from_ui_device (GvcMixerControl* control,
+                                                     GvcMixerUIDevice* device)
+{
+        guint card_id;
+        g_object_get (G_OBJECT (device), "card-id", &card_id, NULL);
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID){
+                g_warning ("device did not have an appropriate card id");
+                return NULL;
+        }
+        GvcMixerCard *card;
+        card = gvc_mixer_control_lookup_card_id (control, card_id);
+        GvcMixerCardProfile *profile;
+        profile = gvc_mixer_card_get_profile (card);
+        return profile->profile;
+}
+
+/**
+ * gvc_mixer_control_get_stream_from_device:
+ * @control:
+ * @dev
+ * Returns: (transfer container) (element-type Gvc.MixerStream):
+ */
+GvcMixerStream*
+gvc_mixer_control_get_stream_from_device (GvcMixerControl *control,
+                                          GvcMixerUIDevice *dev)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+        g_return_val_if_fail (GVC_IS_MIXER_UI_DEVICE (dev), NULL);
+        
+        gint stream_id = gvc_mixer_ui_device_get_stream_id (dev);
+        
+        if (stream_id == GVC_MIXER_UI_DEVICE_INVALID) {
+                g_debug ("gvc_mixer_control_get_stream_from_device - device has a null stream");
+                return NULL;
+        }       
+        return gvc_mixer_control_lookup_stream_id (control, stream_id);
+}                                                             
+
+gboolean
+gvc_mixer_control_change_profile_on_selected_device (GvcMixerControl *control,
+                                                     GvcMixerUIDevice *device,
+                                                     const gchar* profile)                                                    
+{
+        guint card_id;
+        g_object_get ( G_OBJECT(device), "card-id", &card_id, NULL);
+        
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID){
+                g_warning ("gvc_mixer_control_change_profile - no card => different profile but cant find a valid card id ?");
+                return;
+        }
+        GvcMixerCard *card;
+        card = gvc_mixer_control_lookup_card_id (control, card_id);     
+        g_print ("\n Trying to move to profile %s on card %s on stream id %i \n",
+                profile,
+                gvc_mixer_card_get_name (card),
+                gvc_mixer_ui_device_get_stream_id (device));
+
+        
+        g_print ("\n default sink name = %s \n and default sink id %u",
+                 control->priv->default_sink_name,
+                 control->priv->default_sink_id);
+
+        if (gvc_mixer_card_change_profile (card, profile)) {
+                gvc_mixer_ui_device_set_user_preferred_profile (device, profile);
+                control->priv->profile_swapping_device_id = gvc_mixer_ui_device_get_id (device);
+                return TRUE;
+        }
+        return FALSE;
+}                                                     
+
+// TODO refactor - this should return a boolean determining as much as it can the success of the change
+// => the UI on the frontend can be reset to its previous entry if for any reason the change should fail. 
+/**
+ * gvc_mixer_control_change_output:
+ * @control:
+ * @output:
+ */						     
+void
+gvc_mixer_control_change_output (GvcMixerControl *control,
+                                 GvcMixerUIDevice* output)
+{
+        g_print ("\n control change output \n");
+        GvcMixerStream *stream;
+        GvcMixerStream *default_stream;
+
+        stream = gvc_mixer_control_get_stream_from_device (control, output);
+        if (stream == NULL){
+                guint card_id;
+                g_object_get ( G_OBJECT(output), "card-id", &card_id, NULL);
+                
+                if (card_id == GVC_MIXER_UI_DEVICE_INVALID){
+                        g_warning ("gvc_mixer_control_change_output - no stream => different profile but cant find a valid card id ?");
+                        return;
+                }
+
+                const gchar* profile_name = NULL;
+                profile_name = gvc_mixer_ui_device_get_user_preferred_profile (output);
+
+                if (profile_name == NULL){
+                        // Otherwise move to the highest priority profile on that device
+                        profile_name = gvc_mixer_ui_device_get_top_priority_profile (output);
+                }
+
+                g_print ("\n Trying to move to profile %s \n", profile_name);
+                GvcMixerCard *card;
+                card = gvc_mixer_control_lookup_card_id (control, card_id);
+                
+                control->priv->cached_desired_output_id = gvc_mixer_ui_device_get_id (output);
+
+                gvc_mixer_card_change_profile (card, profile_name);
+                return;
+        }
+
+        // Handle a network sink => a portless/cardless device
+        if (gvc_mixer_ui_device_get_port (output) == NULL){
+                g_print ("Did we try to move to a network sink ? \n");
+                if (gvc_mixer_control_set_default_sink (control, stream)) {
+                        // sink change successfull => update the UI.
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[ACTIVE_OUTPUT_UPDATE],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (output));             
+                }
+                else{
+                        g_warning ("Failed to set default sink with stream from output %s \n",
+                                   gvc_mixer_ui_device_get_description (output));
+                }
+                return;
+        }
+
+	const GvcMixerStreamPort* active_port = gvc_mixer_stream_get_port (stream);
+	const gchar* output_port = gvc_mixer_ui_device_get_port (output);
+        // First ensure the correct port is active on the sink
+	if (g_strcmp0 (active_port->port, output_port) != 0){
+		g_print ("\n Port change, switch to = %s \n", 
+			  output_port); 
+		if (gvc_mixer_stream_change_port (stream, output_port) == FALSE){
+                        g_warning ("\n Could not change port ! \n");
+                        return;
+		}
+        }
+
+        default_stream = gvc_mixer_control_get_default_sink (control);	 
+        
+        // Finally if we are not on the correct stream, swap over.
+	if (stream != default_stream){
+                g_print ("\n\n !!!!Attempting to swap over to stream %s \n",
+                         gvc_mixer_stream_get_description(stream));
+                if (gvc_mixer_control_set_default_sink (control, stream)){
+                        GvcMixerUIDevice* output;
+                        output = gvc_mixer_control_lookup_device_from_stream (control, stream);
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[ACTIVE_OUTPUT_UPDATE],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (output));                                  
+                }
+        }
+}
+
+
+/**
+ * gvc_mixer_control_change_input:
+ * @control:
+ * @input:
+ */                                                
+void
+gvc_mixer_control_change_input (GvcMixerControl *control,
+                                GvcMixerUIDevice* input)
+{
+        GvcMixerStream *stream;
+        GvcMixerStream *default_stream;
+
+        stream = gvc_mixer_control_get_stream_from_device (control, input);
+        if (stream == NULL){
+                // TODO - make a method - swap_profile_card
+                guint card_id;
+                g_object_get ( G_OBJECT(input), "card-id", &card_id, NULL);
+                
+                if (card_id == GVC_MIXER_UI_DEVICE_INVALID){
+                        g_warning ("gvc_mixer_control_change_input -no stream => different profile but cant find a valid card id ?");
+                        return;
+                }
+
+                const gchar* profile_name = NULL;
+                profile_name = gvc_mixer_ui_device_get_user_preferred_profile (input);
+
+                if (profile_name == NULL){
+                        // Otherwise move to the highest priority profile on that device
+                        profile_name = gvc_mixer_ui_device_get_top_priority_profile (input);
+                }
+
+                g_print ("\n trying to move to profile %s \n", profile_name);
+                GvcMixerCard *card;
+                card = gvc_mixer_control_lookup_card_id (control, card_id);
+                
+                control->priv->cached_desired_input_id = gvc_mixer_ui_device_get_id (input);
+
+                gvc_mixer_card_change_profile (card, profile_name);
+                return;
+        }
+
+        // Handle a network sink => a portless/cardless device
+        if (gvc_mixer_ui_device_get_port (input) == NULL){
+                g_print ("Did we try to move to a network source ? \n");
+                if (gvc_mixer_control_set_default_source (control, stream)) {
+                        // source change successfull => update the UI.
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[ACTIVE_INPUT_UPDATE],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (input));             
+                }
+                else{
+                        g_warning ("Failed to set default source with stream from input %s \n",
+                                   gvc_mixer_ui_device_get_description (input));
+                }
+                return;
+        }
+
+        const GvcMixerStreamPort* active_port = gvc_mixer_stream_get_port (stream);
+        const gchar* input_port = gvc_mixer_ui_device_get_port (input);
+        // First ensure the correct port is active on the sink
+        if (g_strcmp0 (active_port->port, input_port) != 0){
+                g_print ("\n Port change, switch to = %s \n", 
+                          input_port); 
+                if (gvc_mixer_stream_change_port (stream, input_port) == FALSE){
+                        g_warning ("\n Could not change port ! \n");
+                        return;
+                }
+        }
+
+        default_stream = gvc_mixer_control_get_default_source (control);   
+        
+        // Finally if we are not on the correct stream, swap over.              
+        if (stream != default_stream){
+                g_print ("\n change-input - attempting to swap over to stream %s \n",
+                         gvc_mixer_stream_get_description(stream));
+                gvc_mixer_control_set_default_source (control, stream);
+        }
+}
+
+
+static void
+listify_hash_values_hfunc (gpointer key,
+                           gpointer value,
+                           gpointer user_data)
+{
+        GSList **list = user_data;
+
+        *list = g_slist_prepend (*list, value);
+}
+
+static int
+gvc_name_collate (const char *namea,
+                  const char *nameb)
+{
+        if (nameb == NULL && namea == NULL)
+                return 0;
+        if (nameb == NULL)
+                return 1;
+        if (namea == NULL)
+                return -1;
+
+        return g_utf8_collate (namea, nameb);
+}
+
+static int
+gvc_card_collate (GvcMixerCard *a,
+                  GvcMixerCard *b)
+{
+        const char *namea;
+        const char *nameb;
+
+        g_return_val_if_fail (a == NULL || GVC_IS_MIXER_CARD (a), 0);
+        g_return_val_if_fail (b == NULL || GVC_IS_MIXER_CARD (b), 0);
+
+        namea = gvc_mixer_card_get_name (a);
+        nameb = gvc_mixer_card_get_name (b);
+
+        return gvc_name_collate (namea, nameb);
+}
+
+/**
+ * gvc_mixer_control_get_cards:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerCard):
+ */
+GSList *
+gvc_mixer_control_get_cards (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->cards,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_card_collate);
+}
+
+static int
+gvc_stream_collate (GvcMixerStream *a,
+                    GvcMixerStream *b)
+{
+        const char *namea;
+        const char *nameb;
+
+        g_return_val_if_fail (a == NULL || GVC_IS_MIXER_STREAM (a), 0);
+        g_return_val_if_fail (b == NULL || GVC_IS_MIXER_STREAM (b), 0);
+
+        namea = gvc_mixer_stream_get_name (a);
+        nameb = gvc_mixer_stream_get_name (b);
+
+        return gvc_name_collate (namea, nameb);
+}
+
+/**
+ * gvc_mixer_control_get_streams:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerStream):
+ */
+GSList *
+gvc_mixer_control_get_streams (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->all_streams,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+
+/**
+ * gvc_mixer_control_get_sinks:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSink):
+ */
+GSList *
+gvc_mixer_control_get_sinks (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->sinks,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+/**
+ * gvc_mixer_control_get_sources:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSource):
+ */
+GSList *
+gvc_mixer_control_get_sources (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->sources,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+/**
+ * gvc_mixer_control_get_sink_inputs:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSinkInput):
+ */
+GSList *
+gvc_mixer_control_get_sink_inputs (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->sink_inputs,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+/**
+ * gvc_mixer_control_get_source_outputs:
+ *
+ * @control:
+ *
+ * Returns: (transfer container) (element-type Gvc.MixerSourceOutput):
+ */
+GSList *
+gvc_mixer_control_get_source_outputs (GvcMixerControl *control)
+{
+        GSList *retval;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), NULL);
+
+        retval = NULL;
+        g_hash_table_foreach (control->priv->source_outputs,
+                              listify_hash_values_hfunc,
+                              &retval);
+        return g_slist_sort (retval, (GCompareFunc) gvc_stream_collate);
+}
+
+static void
+dec_outstanding (GvcMixerControl *control)
+{
+        if (control->priv->n_outstanding <= 0) {
+                return;
+        }
+
+        if (--control->priv->n_outstanding <= 0) {
+                control->priv->state = GVC_STATE_READY;
+                g_signal_emit (G_OBJECT (control), signals[STATE_CHANGED], 0, GVC_STATE_READY);
+        }
+}
+
+GvcMixerControlState
+gvc_mixer_control_get_state (GvcMixerControl *control)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+
+        return control->priv->state;
+}
+
+static void
+on_default_source_port_notify (GObject        *object,
+                               GParamSpec     *pspec,
+                               GvcMixerControl *control)
+{
+        char *port;
+        g_object_get (object, "port", &port, NULL);
+        GvcMixerUIDevice* input;
+        input = gvc_mixer_control_lookup_device_from_stream (control,
+                                                             gvc_mixer_control_get_default_source (control));
+                                                                      
+        g_print ("\n\n on_default_source_port_notify - moved to port %s \n which SHOULD ?? correspond to output \n %s \n",
+                 port,
+                 gvc_mixer_ui_device_get_description (input));
+        g_signal_emit (G_OBJECT (control),
+                       signals[ACTIVE_INPUT_UPDATE],
+                       0,
+                       gvc_mixer_ui_device_get_id (input));       
+
+        g_free (port);
+}
+
+
+static void
+_set_default_source (GvcMixerControl *control,
+                     GvcMixerStream  *stream)
+{
+        guint new_id;
+
+        if (stream == NULL) {
+                control->priv->default_source_id = 0;
+                control->priv->default_source_is_set = FALSE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SOURCE_CHANGED],
+                               0,
+                               PA_INVALID_INDEX);
+                return;
+        }
+
+        new_id = gvc_mixer_stream_get_id (stream);
+
+        if (control->priv->default_source_id != new_id) {
+                control->priv->default_source_id = new_id;
+                control->priv->default_source_is_set = TRUE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SOURCE_CHANGED],
+                               0,
+                               new_id);
+
+                if (control->priv->default_sink_is_set){
+                        g_signal_handlers_disconnect_by_func (gvc_mixer_control_get_default_source (control),
+                                                              on_default_source_port_notify,
+                                                              control);                        
+                }
+
+                g_signal_connect (stream,
+                                  "notify::port",
+                                  G_CALLBACK (on_default_source_port_notify),
+                                  control);
+
+                GvcMixerUIDevice* input;
+                input = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+                g_signal_emit (G_OBJECT (control),
+                               signals[ACTIVE_INPUT_UPDATE],
+                               0,
+                               gvc_mixer_ui_device_get_id (input));
+
+        }
+}
+
+static void
+on_default_sink_port_notify (GObject        *object,
+                             GParamSpec     *pspec,
+                             GvcMixerControl *control)
+{
+        char *port;
+        g_object_get (object, "port", &port, NULL);
+        GvcMixerUIDevice* output;
+        output = gvc_mixer_control_lookup_device_from_stream (control,
+                                                              gvc_mixer_control_get_default_sink (control));
+                                                                      
+        g_print ("\n\n on_default_sink_port_notify - moved to port %s \n which SHOULD correspond to output %s \n",
+                 port,
+                 gvc_mixer_ui_device_get_description (output));
+        g_signal_emit (G_OBJECT (control),
+                       signals[ACTIVE_OUTPUT_UPDATE],
+                       0,
+                       gvc_mixer_ui_device_get_id (output));       
+
+        g_free (port);
+}
+
+
+static void
+_set_default_sink (GvcMixerControl *control,
+                   GvcMixerStream  *stream)
+{
+        guint new_id;
+
+        if (stream == NULL) {
+                /* Don't tell front-ends about an unset default
+                 * sink if it's already unset */
+                if (control->priv->default_sink_is_set == FALSE)
+                        return;
+                control->priv->default_sink_id = 0;
+                control->priv->default_sink_is_set = FALSE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SINK_CHANGED],
+                               0,
+                               PA_INVALID_INDEX);
+                return;
+        }
+
+        new_id = gvc_mixer_stream_get_id (stream);
+
+        if (control->priv->default_sink_id != new_id) {                
+                if (control->priv->default_sink_is_set){
+                        g_signal_handlers_disconnect_by_func (gvc_mixer_control_get_default_sink (control),
+                                                              on_default_sink_port_notify,
+                                                              control);                        
+                }
+
+                control->priv->default_sink_id = new_id;
+
+                control->priv->default_sink_is_set = TRUE;
+                g_signal_emit (control,
+                               signals[DEFAULT_SINK_CHANGED],
+                               0,
+                               new_id);
+                               
+                g_signal_connect (stream,
+                                  "notify::port",
+                                  G_CALLBACK (on_default_sink_port_notify),
+                                  control);
+
+                GvcMixerUIDevice* output;                
+                output = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+                g_print ("active_sink change \n");
+
+                g_signal_emit (G_OBJECT (control),
+                               signals[ACTIVE_OUTPUT_UPDATE],
+                               0,
+                               gvc_mixer_ui_device_get_id (output));                       
+        }
+}
+
+static gboolean
+_stream_has_name (gpointer        key,
+                  GvcMixerStream *stream,
+                  const char     *name)
+{
+        const char *t_name;
+
+        t_name = gvc_mixer_stream_get_name (stream);
+
+        if (t_name != NULL
+            && name != NULL
+            && strcmp (t_name, name) == 0) {
+                return TRUE;
+        }
+
+        return FALSE;
+}
+
+static GvcMixerStream  *
+find_stream_for_name (GvcMixerControl *control,
+                      const char      *name)
+{
+        GvcMixerStream *stream;
+
+        stream = g_hash_table_find (control->priv->all_streams,
+                                    (GHRFunc)_stream_has_name,
+                                    (char *)name);
+        return stream;
+}
+
+static void
+update_default_source_from_name (GvcMixerControl *control,
+                                 const char      *name)
+{
+        gboolean changed = FALSE;
+
+        if ((control->priv->default_source_name == NULL
+             && name != NULL)
+            || (control->priv->default_source_name != NULL
+                && name == NULL)
+            || (name != NULL && strcmp (control->priv->default_source_name, name) != 0)) {
+                changed = TRUE;
+        }
+
+        if (changed) {
+                GvcMixerStream *stream;
+
+                g_free (control->priv->default_source_name);
+                control->priv->default_source_name = g_strdup (name);
+
+                stream = find_stream_for_name (control, name);
+                _set_default_source (control, stream);
+        }
+}
+
+static void
+update_default_sink_from_name (GvcMixerControl *control,
+                               const char      *name)
+{
+        gboolean changed = FALSE;
+
+        if ((control->priv->default_sink_name == NULL
+             && name != NULL)
+            || (control->priv->default_sink_name != NULL
+                && name == NULL)
+            || (name != NULL && strcmp (control->priv->default_sink_name, name) != 0)) {
+                changed = TRUE;
+        }
+
+        if (changed) {
+                GvcMixerStream *stream;
+                g_free (control->priv->default_sink_name);
+                control->priv->default_sink_name = g_strdup (name);
+
+                stream = find_stream_for_name (control, name);
+                _set_default_sink (control, stream);
+        }
+}
+
+static void
+update_server (GvcMixerControl      *control,
+               const pa_server_info *info)
+{
+        if (info->default_source_name != NULL) {
+                update_default_source_from_name (control, info->default_source_name);
+        }
+        if (info->default_sink_name != NULL) {
+                g_print ("\n update server");
+                update_default_sink_from_name (control, info->default_sink_name);
+        }
+}
+
+static void
+remove_stream (GvcMixerControl *control,
+               GvcMixerStream  *stream)
+{
+        guint id;
+
+        g_object_ref (stream);
+
+        id = gvc_mixer_stream_get_id (stream);
+                
+        if (id == control->priv->default_sink_id) {
+                _set_default_sink (control, NULL);
+        } else if (id == control->priv->default_source_id) {
+                _set_default_source (control, NULL);
+        }
+
+        g_hash_table_remove (control->priv->all_streams,
+                             GUINT_TO_POINTER (id));
+        g_signal_emit (G_OBJECT (control),
+                       signals[STREAM_REMOVED],
+                       0,
+                       gvc_mixer_stream_get_id (stream));
+        g_object_unref (stream);
+}
+
+static void
+add_stream (GvcMixerControl *control,
+            GvcMixerStream  *stream)
+{
+        g_hash_table_insert (control->priv->all_streams,
+                             GUINT_TO_POINTER (gvc_mixer_stream_get_id (stream)),
+                             stream);
+        g_signal_emit (G_OBJECT (control),
+                       signals[STREAM_ADDED],
+                       0,
+                       gvc_mixer_stream_get_id (stream));
+}
+
+static gboolean
+match_stream_with_devices (GvcMixerControl *control,
+        		   GvcMixerStreamPort* stream_port,
+                           GvcMixerStream* stream)
+{
+	GList 			*devices;
+	GList 			*d;
+	GvcMixerUIDevice	*device;
+        guint                   stream_card_id;
+        guint                   stream_id;
+        			
+	stream_id      =  gvc_mixer_stream_get_id (stream);
+        stream_card_id =  gvc_mixer_stream_get_card_index (stream);
+
+        if (GVC_IS_MIXER_SOURCE (stream)){
+               devices  = g_hash_table_get_values (control->priv->ui_inputs);                       
+        }
+        else{
+               devices  = g_hash_table_get_values (control->priv->ui_outputs);
+        }
+
+	gboolean in_possession 	= FALSE;
+
+	for (d = devices; d != NULL; d = d->next) {				
+		device = d->data;
+
+		gint  device_stream_id;
+		gchar *device_port_name;
+		gchar *origin;
+		gchar *description;
+		gint  card_id;
+		
+		g_object_get (G_OBJECT (device),
+			     "stream-id", &device_stream_id,
+			     "card-id", &card_id,
+			     "origin", &origin,
+			     "description", &description,
+			     "port-name", &device_port_name,
+			      NULL);
+
+		/*g_print ("\n Attempt to match_stream update_with_existing_outputs \n Try description : %s \n, origin : %s \n device port name : %s \n card id : %i \n AGAINST stream port: %s \n sink card id %i \n\n ",
+			 description,
+			 origin,
+			 device_port_name,
+			 card_id, 
+			 stream_port->port,
+			 stream_card_id);*/
+
+		if ( stream_card_id == card_id &&
+		     g_strcmp0 (device_port_name, stream_port->port) == 0) {					     
+			g_print ("\n Match device with stream \n We have a match with description : %s  \n origin : %s \n cached already with device id %u, \n => set stream id to %i \n\n ",
+ 				 description,
+				 origin,
+				 gvc_mixer_ui_device_get_id (device),
+                                 stream_id);
+			
+			g_object_set (G_OBJECT (device),
+    				      "stream-id", (gint)stream_id,
+				      NULL);		      								     
+			in_possession = TRUE;						    
+		}
+									      
+		g_free (device_port_name);				
+		g_free (origin);						
+		g_free (description);
+		
+		if (in_possession == TRUE)
+			break;
+	}
+	return in_possession;	
+}
+
+static void
+sync_devices (GvcMixerControl *control,
+	      GvcMixerStream* stream, int is_output)
+{
+
+	// Go through ports to see what outputs can be created.
+	const GList *stream_ports = NULL;
+	const GList *n = NULL;
+	
+        stream_ports = gvc_mixer_stream_get_ports (stream);
+	gint stream_port_count = 0;
+		
+        if (g_list_length (stream_ports) == 0){                       
+                g_print (" \n \n !!! Just found a %s without ports - creating a UI device \n", is_output ? "sink" : "source");
+                GObject *object;
+
+                object = g_object_new (GVC_TYPE_MIXER_UI_DEVICE,
+                                       "stream-id", (gint)gvc_mixer_stream_get_id (stream),
+                                       "description", gvc_mixer_stream_get_description (stream),
+                                       "origin", "", /*Leave it empty for these special cases*/
+                                       "port-name", NULL,
+                                       "port-available", TRUE,
+                                       NULL);
+                GvcMixerUIDevice* out = GVC_MIXER_UI_DEVICE (object);
+
+                if (gvc_mixer_stream_get_card_index (stream) != PA_INVALID_INDEX) {
+                        // Detecting bluetooth device !
+                        g_object_set ( object,
+                                      "card-id",
+                                       gvc_mixer_stream_get_card_index (stream), NULL);
+                        GvcMixerCard* card = NULL;
+                        card = gvc_mixer_control_lookup_card_id (control,
+                                                                 gvc_mixer_stream_get_card_index (stream));
+                        const GList *profiles = NULL;
+                        profiles = gvc_mixer_card_get_profiles (card);
+                        if (profiles == NULL){
+                                g_warning ("Card has no profiles");
+                        }
+                        else{
+                                g_print ("\n Is this a bluetooth device, portless yet a card with profiles \n");
+                                gvc_mixer_ui_device_set_profiles (out, profiles);                        
+                        }
+                }
+
+                g_hash_table_insert (is_output ? control->priv->ui_outputs : control->priv->ui_inputs,
+                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (out)),
+                                     g_object_ref (out));
+                                
+                g_signal_emit (G_OBJECT (control),
+                               signals[is_output ? OUTPUT_ADDED : INPUT_ADDED],
+                               0,
+                               gvc_mixer_ui_device_get_id (out));
+                return;
+        }
+
+        // Go ahead and make sure to match each port against a previously created device
+	for (n = stream_ports; n != NULL; n = n->next) {
+
+		GvcMixerStreamPort *stream_port;
+		stream_port = n->data;		
+		stream_port_count ++;
+							
+		if ( TRUE == match_stream_with_devices (control,
+							stream_port,
+							stream))
+			continue;		
+		
+		g_warning ("\n\n\n\n\n !!!!!!!!!!!!!!!!! why am I here  !!! \n\n");
+		g_print ("\n Failed to match \n stream id: %u \n description : %s \n origin : %s \n \n ",
+				 gvc_mixer_stream_get_id (stream),
+				 stream_port->human_port,				 	 
+				 gvc_mixer_stream_get_description (stream));		
+	}		
+}
+
+static void
+set_icon_name_from_proplist (GvcMixerStream *stream,
+                             pa_proplist    *l,
+                             const char     *default_icon_name)
+{
+        const char *t;
+
+        if ((t = pa_proplist_gets (l, PA_PROP_DEVICE_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_MEDIA_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_WINDOW_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_APPLICATION_ICON_NAME))) {
+                goto finish;
+        }
+
+        if ((t = pa_proplist_gets (l, PA_PROP_MEDIA_ROLE))) {
+
+                if (strcmp (t, "video") == 0 ||
+                    strcmp (t, "phone") == 0) {
+                        goto finish;
+                }
+
+                if (strcmp (t, "music") == 0) {
+                        t = "audio";
+                        goto finish;
+                }
+
+                if (strcmp (t, "game") == 0) {
+                        t = "applications-games";
+                        goto finish;
+                }
+
+                if (strcmp (t, "event") == 0) {
+                        t = "dialog-information";
+                        goto finish;
+                }
+        }
+
+        t = default_icon_name;
+
+ finish:
+        gvc_mixer_stream_set_icon_name (stream, t);
+}
+
+static void
+update_sink (GvcMixerControl    *control,
+             const pa_sink_info *info)
+{
+        GvcMixerStream  *stream;
+        gboolean        is_new;
+        pa_volume_t     max_volume;
+        GvcChannelMap   *map;
+        char            map_buff[PA_CHANNEL_MAP_SNPRINT_MAX];
+
+        pa_channel_map_snprint (map_buff, PA_CHANNEL_MAP_SNPRINT_MAX, &info->channel_map);
+#if 1
+        g_debug ("Updating sink: index=%u name='%s' description='%s' map='%s'",
+                 info->index,
+                 info->name,
+                 info->description,
+                 map_buff);
+#endif
+
+        map = NULL;
+        is_new = FALSE;
+        stream = g_hash_table_lookup (control->priv->sinks,
+                                      GUINT_TO_POINTER (info->index));
+
+
+        if (stream == NULL) {
+
+
+                GList *list = NULL;
+                guint i;
+
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_sink_new (control->priv->pa_context,
+                                             info->index,
+                                             map);
+
+                for (i = 0; i < info->n_ports; i++) {
+                        GvcMixerStreamPort *port;
+
+                        port = g_new0 (GvcMixerStreamPort, 1);
+                        port->port = g_strdup (info->ports[i]->name);
+                        port->human_port = g_strdup (info->ports[i]->description);
+                        port->priority = info->ports[i]->priority;
+                        port->available = info->ports[i]->available == 0 ||
+                                            info->ports[i]->available == 2;
+                        
+                        list = g_list_prepend (list, port);
+                }
+                gvc_mixer_stream_set_ports (stream, list);
+
+                g_object_unref (map);
+                is_new = TRUE;
+
+        } else if (gvc_mixer_stream_is_running (stream)) {
+                /* Ignore events if volume changes are outstanding */
+                g_debug ("Ignoring event, volume changes are outstanding");
+                return;
+        }   
+
+        max_volume = pa_cvolume_max (&info->volume);
+        gvc_mixer_stream_set_name (stream, info->name);
+        gvc_mixer_stream_set_card_index (stream, info->card);
+        gvc_mixer_stream_set_description (stream, info->description);
+        set_icon_name_from_proplist (stream, info->proplist, "audio-card");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+        gvc_mixer_stream_set_can_decibel (stream, !!(info->flags & PA_SINK_DECIBEL_VOLUME));
+        gvc_mixer_stream_set_base_volume (stream, (guint32) info->base_volume);
+
+        // Messy I know but to set the port everytime regardless of whether it has changed will cost us a 
+        // port change notify signal which caused the frontend to resync. 
+        // Only update the UI when something has changed.
+        if (info->active_port != NULL){
+                if (is_new){
+                        gvc_mixer_stream_set_port (stream, info->active_port->name);                        
+                }
+                else{
+                        GvcMixerStreamPort* active_port;
+                        active_port = gvc_mixer_stream_get_port (stream);
+                        if (active_port == NULL || 
+                            g_strcmp0 (active_port->port, info->active_port->name) != 0){                
+                                g_print ("\n update sink - apparently a port update");
+                                gvc_mixer_stream_set_port (stream, info->active_port->name);
+                        }
+                }
+	}
+        
+        if (is_new) {
+                g_print ("\n update sink - is new \n");
+
+                g_hash_table_insert (control->priv->sinks,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+                // Always sink on a new stream to able to assign the right stream id 
+                // to the appropriate outputs (=>multiple potential outputs per stream).
+                sync_devices (control, stream, TRUE);	
+        }
+
+
+        // Handle the edge case whereby inorder to satisfy a user instruction to swap
+        // to an output which was on a different profile we first need to swap profile,
+        // this will then trigger the sink/stream creation. 
+        // At this point catch the stream, if necessary swap the port and return.
+        // anticipating another update sink call from the port change to finish the volume mapping.
+        if (control->priv->cached_desired_output_id != GVC_MIXER_UI_DEVICE_INVALID){
+                GvcMixerUIDevice *output = NULL;
+                output = gvc_mixer_control_lookup_output_id (control,
+                                                             control->priv->cached_desired_output_id);
+                if (gvc_mixer_stream_get_ports (stream) != NULL && output != NULL){
+                        
+                        g_print ("\n Apparently we have a cached desired output, \n we should be on port %s \n",
+                                gvc_mixer_ui_device_get_port (output)); 
+                        GvcMixerStreamPort* active_port = gvc_mixer_stream_get_port (stream);
+                        
+                        if (g_strcmp0(active_port->port, gvc_mixer_ui_device_get_port (output)) == 0){
+                                g_print ("\n no need to change port, its already active \n");                       
+                        }
+                        else{                                                                              
+                                if (gvc_mixer_stream_change_port (stream, gvc_mixer_ui_device_get_port (output)) == FALSE){
+                                        g_warning ("\n Tried to swap port to previously cache port but failed");
+                                }
+                                else{
+                                        g_print ("\n Swap port to previously cached port %s - return \n",
+                                                 gvc_mixer_ui_device_get_port (output)); 
+                                        control->priv->cached_desired_output_id = GVC_MIXER_UI_DEVICE_INVALID;
+                                        return;               
+                                }
+                        }                         
+                }
+                control->priv->cached_desired_output_id = GVC_MIXER_UI_DEVICE_INVALID;
+        }        
+        
+        /*
+        When we change profile on a device that is not the server default sink,
+        it will jump back to the default sink set by the server to prevent the audio setup from being 'outputless'.
+        All well and good but then when we get the new stream created for the new profile how do we know 
+        that this is the intended default or selected device the user wishes to use.
+        This is messy but it's the only reliable way that it can be done without ripping the whole thing apart.
+        */
+        gboolean default_set = FALSE;
+
+        if (control->priv->profile_swapping_device_id != GVC_MIXER_UI_DEVICE_INVALID){
+                GvcMixerUIDevice *dev = NULL;
+                dev = gvc_mixer_control_lookup_output_id (control, control->priv->profile_swapping_device_id);
+                if (dev != NULL){
+                        // now check to make sure this new stream is the same stream just matched and set on the device object
+                        if (gvc_mixer_ui_device_get_stream_id (dev) == gvc_mixer_stream_get_id (stream)){
+                                g_print ("Looks like we profile swapped on a non server default sink");
+                                gvc_mixer_control_set_default_sink (control, stream);
+                                default_set = TRUE;                   
+                        }  
+                }
+                control->priv->profile_swapping_device_id = GVC_MIXER_UI_DEVICE_INVALID;                
+        }
+
+        if (!default_set && control->priv->default_sink_name != NULL
+            && info->name != NULL
+            && strcmp (control->priv->default_sink_name, info->name) == 0) {
+                _set_default_sink (control, stream);
+        }
+
+        if (map == NULL)
+                map = (GvcChannelMap *) gvc_mixer_stream_get_channel_map (stream);
+        
+        gvc_channel_map_volume_changed (map, &info->volume, FALSE);
+              
+}
+
+static void
+update_source (GvcMixerControl      *control,
+               const pa_source_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        gboolean        port_change;
+        pa_volume_t     max_volume;
+
+#if 1
+        g_debug ("Updating source: index=%u name='%s' description='%s'",
+                 info->index,
+                 info->name,
+                 info->description);
+#endif
+
+        /* completely ignore monitors, they're not real sources */
+        if (info->monitor_of_sink != PA_INVALID_INDEX) {
+                return;
+        }
+
+        is_new = FALSE;
+
+        stream = g_hash_table_lookup (control->priv->sources,
+                                      GUINT_TO_POINTER (info->index));
+        if (stream == NULL) {
+                GList *list = NULL;
+                guint i;
+                GvcChannelMap *map;
+
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_source_new (control->priv->pa_context,
+                                               info->index,
+                                               map);
+
+                for (i = 0; i < info->n_ports; i++) {
+                        GvcMixerStreamPort *port;
+
+                        port = g_new0 (GvcMixerStreamPort, 1);
+                        port->port = g_strdup (info->ports[i]->name);
+                        port->human_port = g_strdup (info->ports[i]->description);
+                        port->priority = info->ports[i]->priority;
+                        list = g_list_prepend (list, port);
+                }
+                gvc_mixer_stream_set_ports (stream, list);
+
+                g_object_unref (map);
+                is_new = TRUE;
+        } else if (gvc_mixer_stream_is_running (stream)) {
+                /* Ignore events if volume changes are outstanding */
+                g_debug ("Ignoring event, volume changes are outstanding");
+                return;
+        }
+
+        max_volume = pa_cvolume_max (&info->volume);
+
+        gvc_mixer_stream_set_name (stream, info->name);
+        gvc_mixer_stream_set_card_index (stream, info->card);
+        gvc_mixer_stream_set_description (stream, info->description);
+        set_icon_name_from_proplist (stream, info->proplist, "audio-input-microphone");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+        gvc_mixer_stream_set_can_decibel (stream, !!(info->flags & PA_SOURCE_DECIBEL_VOLUME));
+        gvc_mixer_stream_set_base_volume (stream, (guint32) info->base_volume);
+
+        if (info->active_port != NULL){
+                if (is_new){
+                        gvc_mixer_stream_set_port (stream, info->active_port->name);                        
+                }
+                else{
+                        GvcMixerStreamPort* active_port;
+                        active_port = gvc_mixer_stream_get_port (stream);
+                        if (active_port == NULL || 
+                            g_strcmp0 (active_port->port, info->active_port->name) != 0){                
+                                g_print ("\n update source - apparently a port update \n");
+                                gvc_mixer_stream_set_port (stream, info->active_port->name);
+                        }
+                }
+        }
+        
+        if (is_new) {
+                g_hash_table_insert (control->priv->sources,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+
+                sync_devices (control, stream, FALSE);
+        }
+
+        if (control->priv->default_source_name != NULL
+            && info->name != NULL
+            && strcmp (control->priv->default_source_name, info->name) == 0) {
+                _set_default_source (control, stream);
+        }
+
+        // make sure to update the UI!
+/*        if (port_change) {
+                GvcMixerUIDevice* input;
+                input = gvc_mixer_control_lookup_device_from_stream (control, stream);
+                g_print ("port change detected in the update source 2\n");
+                g_signal_emit (G_OBJECT (control),
+                               signals[ACTIVE_INPUT_UPDATE],
+                               0,
+                               gvc_mixer_ui_device_get_id (input));
+        }        
+*/
+}
+
+static void
+set_is_event_stream_from_proplist (GvcMixerStream *stream,
+                                   pa_proplist    *l)
+{
+        const char *t;
+        gboolean is_event_stream;
+
+        is_event_stream = FALSE;
+
+        if ((t = pa_proplist_gets (l, PA_PROP_MEDIA_ROLE))) {
+                if (g_str_equal (t, "event"))
+                        is_event_stream = TRUE;
+        }
+
+        gvc_mixer_stream_set_is_event_stream (stream, is_event_stream);
+}
+
+static void
+set_application_id_from_proplist (GvcMixerStream *stream,
+                                  pa_proplist    *l)
+{
+        const char *t;
+
+        if ((t = pa_proplist_gets (l, PA_PROP_APPLICATION_ID))) {
+                gvc_mixer_stream_set_application_id (stream, t);
+        }
+}
+
+static void
+update_sink_input (GvcMixerControl          *control,
+                   const pa_sink_input_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        pa_volume_t     max_volume;
+        const char     *name;
+
+#if 0
+        g_debug ("Updating sink input: index=%u name='%s' client=%u sink=%u",
+                 info->index,
+                 info->name,
+                 info->client,
+                 info->sink);
+#endif
+
+        is_new = FALSE;
+
+        stream = g_hash_table_lookup (control->priv->sink_inputs,
+                                      GUINT_TO_POINTER (info->index));
+        if (stream == NULL) {
+                GvcChannelMap *map;
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_sink_input_new (control->priv->pa_context,
+                                                   info->index,
+                                                   map);
+                g_object_unref (map);
+                is_new = TRUE;
+        } else if (gvc_mixer_stream_is_running (stream)) {
+                /* Ignore events if volume changes are outstanding */
+                g_debug ("Ignoring event, volume changes are outstanding");
+                return;
+        }
+
+        max_volume = pa_cvolume_max (&info->volume);
+
+        name = (const char *)g_hash_table_lookup (control->priv->clients,
+                                                  GUINT_TO_POINTER (info->client));
+        gvc_mixer_stream_set_name (stream, name);
+        gvc_mixer_stream_set_description (stream, info->name);
+
+        set_application_id_from_proplist (stream, info->proplist);
+        set_is_event_stream_from_proplist (stream, info->proplist);
+        set_icon_name_from_proplist (stream, info->proplist, "applications-multimedia");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+        gvc_mixer_stream_set_is_virtual (stream, info->client == PA_INVALID_INDEX);
+
+        if (is_new) {
+                g_hash_table_insert (control->priv->sink_inputs,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+        }
+}
+
+static void
+update_source_output (GvcMixerControl             *control,
+                      const pa_source_output_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        const char     *name;
+
+#if 1
+        g_debug ("Updating source output: index=%u name='%s' client=%u source=%u",
+                 info->index,
+                 info->name,
+                 info->client,
+                 info->source);
+#endif
+
+        is_new = FALSE;
+        stream = g_hash_table_lookup (control->priv->source_outputs,
+                                      GUINT_TO_POINTER (info->index));
+        if (stream == NULL) {
+                GvcChannelMap *map;
+                map = gvc_channel_map_new_from_pa_channel_map (&info->channel_map);
+                stream = gvc_mixer_source_output_new (control->priv->pa_context,
+                                                      info->index,
+                                                      map);
+                g_object_unref (map);
+                is_new = TRUE;
+        }
+
+        name = (const char *)g_hash_table_lookup (control->priv->clients,
+                                                  GUINT_TO_POINTER (info->client));
+
+        gvc_mixer_stream_set_name (stream, name);
+        gvc_mixer_stream_set_description (stream, info->name);
+        set_application_id_from_proplist (stream, info->proplist);
+        set_is_event_stream_from_proplist (stream, info->proplist);
+        set_icon_name_from_proplist (stream, info->proplist, "audio-input-microphone");
+
+        if (is_new) {
+                g_hash_table_insert (control->priv->source_outputs,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (stream));
+                add_stream (control, stream);
+        }
+}
+
+static void
+update_client (GvcMixerControl      *control,
+               const pa_client_info *info)
+{
+#if 1
+        g_debug ("Updating client: index=%u name='%s'",
+                 info->index,
+                 info->name);
+#endif
+        g_hash_table_insert (control->priv->clients,
+                             GUINT_TO_POINTER (info->index),
+                             g_strdup (info->name));
+}
+
+static char *
+card_num_streams_to_status (guint sinks,
+                            guint sources)
+{
+        char *sinks_str;
+        char *sources_str;
+        char *ret;
+
+        if (sinks == 0 && sources == 0) {
+                /* translators:
+                 * The device has been disabled */
+                return g_strdup (_("Disabled"));
+        }
+        if (sinks == 0) {
+                sinks_str = NULL;
+        } else {
+                /* translators:
+                 * The number of sound outputs on a particular device */
+                sinks_str = g_strdup_printf (ngettext ("%u Output",
+                                                       "%u Outputs",
+                                                       sinks),
+                                             sinks);
+        }
+        if (sources == 0) {
+                sources_str = NULL;
+        } else {
+                /* translators:
+                 * The number of sound inputs on a particular device */
+                sources_str = g_strdup_printf (ngettext ("%u Input",
+                                                         "%u Inputs",
+                                                         sources),
+                                               sources);
+        }
+        if (sources_str == NULL)
+                return sinks_str;
+        if (sinks_str == NULL)
+                return sources_str;
+        ret = g_strdup_printf ("%s / %s", sinks_str, sources_str);
+        g_free (sinks_str);
+        g_free (sources_str);
+        return ret;
+}
+
+//TODO - does this not belong with the ui-device
+static GList* 
+determine_profiles_for_port (pa_card_port_info *port,
+			     GList* card_profiles)
+{
+	gint i;
+	GList *supported_profiles = NULL;
+	GList *p;
+	for (i = 0; i < port->n_profiles; i++) {
+		for ( p = card_profiles; p != NULL; p = p->next) {
+			GvcMixerCardProfile *prof;
+			prof = p->data;
+			if (g_strcmp0 (port->profiles[i]->name, prof->profile) == 0) {
+				supported_profiles = g_list_append (supported_profiles, prof);	
+			}
+		}
+	}
+	g_print ("\n %i profiles supported on port %s \n",
+		 g_list_length (supported_profiles),
+		 port->description);
+	return g_list_sort (supported_profiles, (GCompareFunc) sort_profiles);
+}
+
+static gboolean
+is_card_port_an_output (GvcMixerCardPort* port)
+{
+	return port->direction == PA_DIRECTION_OUTPUT ? TRUE : FALSE;
+} 
+
+static void
+create_ui_device_from_port (GvcMixerControl* control,
+			    GvcMixerCardPort* port,
+			    GvcMixerCard* card)
+{
+	UiDeviceDirection direction;
+	
+	direction = (is_card_port_an_output(port) == TRUE) ? UiDeviceOutput : UiDeviceInput;
+	GObject *object;
+	gboolean available = port->available == 0 || port->available == 2;
+
+	object = g_object_new (GVC_TYPE_MIXER_UI_DEVICE,
+			       "type", (uint)direction,
+			       "card-id", (gint)gvc_mixer_card_get_index (card),
+			       "port-name", port->port,
+			       "description", port->human_port,
+			       "origin", gvc_mixer_card_get_name (card),
+			       "port-available", available,
+			       NULL);
+			       
+	GvcMixerUIDevice* uidevice = GVC_MIXER_UI_DEVICE (object);
+	gvc_mixer_ui_device_set_profiles (uidevice, port->profiles);
+
+
+	if (is_card_port_an_output (port)) {
+                g_hash_table_insert (control->priv->ui_outputs,
+                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (uidevice)),
+                                     g_object_ref (uidevice));
+
+		if (available) {
+			g_signal_emit (G_OBJECT (control),
+				       signals[OUTPUT_ADDED],
+				       0,
+				       gvc_mixer_ui_device_get_id (uidevice));
+		}	
+				     
+	}
+	else{
+                g_hash_table_insert (control->priv->ui_inputs,
+                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (uidevice)),
+                                     g_object_ref (uidevice));
+
+		if (available) {
+			g_signal_emit (G_OBJECT (control),
+				       signals[INPUT_ADDED],
+				       0,
+				       gvc_mixer_ui_device_get_id (uidevice));
+		}					     
+	}
+
+	g_print ("\n create_ui_device_from_port, direction %u \n description %s \n origin %s \n port available %i \n \n", 
+		 direction,
+		 port->human_port,
+		 gvc_mixer_card_get_name (card),
+		 available);
+}
+
+static void
+match_card_port_with_existing_device (GvcMixerControl *control,
+				      GvcMixerCardPort* card_port,
+				      GvcMixerCard* card,
+				      gboolean available)
+{
+        GList 			*d;
+        GList                   *devices;
+        GvcMixerUIDevice	*device;			
+        gboolean in_possession 	= FALSE;
+        gboolean is_output      = is_card_port_an_output (card_port);
+
+        if (is_output){
+               devices  = g_hash_table_get_values (control->priv->ui_outputs);
+        }
+        else{
+               devices  = g_hash_table_get_values (control->priv->ui_inputs);       
+        }
+
+	for (d = devices; d != NULL; d = d->next) {					
+                device = d->data;
+                gint     card_id;
+                gchar    *device_port_name;
+		
+                g_object_get (G_OBJECT (device),
+                             "card-id", &card_id,
+                             "port-name", &device_port_name,
+                              NULL);
+
+                if (g_strcmp0 (card_port->port, device_port_name) == 0 && 
+                        card_id == gvc_mixer_card_get_index (card)) { 
+                        g_print ("\n Found the relevant device %s \n update it's port availability flag to %i \n is_output %i",
+                        	 device_port_name,
+                                 available,
+                                 is_output);
+                        g_object_set ( G_OBJECT (device),
+                                       "port-available", available, NULL);
+                        if (is_output) {
+                                if (available) {
+                                        g_signal_emit (G_OBJECT (control),
+                                                       signals[OUTPUT_ADDED],
+                                                       0,
+                                                       gvc_mixer_ui_device_get_id (device));	
+                                }
+                                else{
+                                        g_signal_emit (G_OBJECT (control),
+                                                       signals[OUTPUT_REMOVED],
+                                                       0,
+                                                       gvc_mixer_ui_device_get_id (device));	
+                                }
+                        }
+                        else{
+                                if (available) {
+                                        g_signal_emit (G_OBJECT (control),
+                                                       signals[INPUT_ADDED],
+                                                       0,
+                                                       gvc_mixer_ui_device_get_id (device)); 
+                                }
+                                else{
+                                        g_signal_emit (G_OBJECT (control),
+                                                       signals[INPUT_REMOVED],
+                                                       0,
+                                                       gvc_mixer_ui_device_get_id (device)); 
+                                }                                
+                        }
+	       }
+	       g_free (device_port_name);
+	}
+}
+		    
+static void
+update_card (GvcMixerControl      *control,
+             const pa_card_info   *info)
+{
+        GvcMixerCard *card;
+        gboolean      is_new = FALSE;
+#if 1
+        guint i,t;
+        const char *key;
+        void *state;
+
+        /*g_print ("Udpating card %s (index: %u driver: %s):",
+                 info->name, info->index, info->driver);*/
+
+        for (i = 0; i < info->n_profiles; i++) {
+                struct pa_card_profile_info pi = info->profiles[i];
+                gboolean is_default;
+
+                is_default = (g_strcmp0 (pi.name, info->active_profile->name) == 0);
+                g_debug ("\tProfile '%s': %d sources %d sinks%s",
+                         pi.name, pi.n_sources, pi.n_sinks,
+                         is_default ? " (Current)" : "");
+        }
+        state = NULL;
+        key = pa_proplist_iterate (info->proplist, &state);
+        while (key != NULL) {
+                g_debug ("\tProperty: '%s' = '%s'",
+                        key, pa_proplist_gets (info->proplist, key));
+                key = pa_proplist_iterate (info->proplist, &state);
+        }
+#endif
+        card = g_hash_table_lookup (control->priv->cards,
+                                    GUINT_TO_POINTER (info->index));
+        if (card == NULL) {
+                GList *profile_list = NULL;
+
+                for (i = 0; i < info->n_profiles; i++) {
+                        struct pa_card_profile_info pi = info->profiles[i];
+                        GvcMixerCardProfile *profile;
+
+                        profile = g_new0 (GvcMixerCardProfile, 1);
+                        profile->profile = g_strdup (pi.name);
+                        profile->human_profile = g_strdup (pi.description);
+                        profile->status = card_num_streams_to_status (pi.n_sinks, pi.n_sources);
+                        profile->n_sinks = pi.n_sinks;
+                        profile->n_sources = pi.n_sources;
+                        profile->priority = pi.priority;
+                        profile_list = g_list_prepend (profile_list, profile);
+                }
+                card = gvc_mixer_card_new (control->priv->pa_context,
+                                           info->index);
+                gvc_mixer_card_set_profiles (card, profile_list);
+
+		GList *port_list = NULL;
+                for (i = 0; i < info->n_ports; i++) {
+                        GvcMixerCardPort *port;
+                        port = g_new0 (GvcMixerCardPort, 1);
+                        port->port = g_strdup (info->ports[i]->name);
+                        port->human_port = g_strdup (info->ports[i]->description);
+                        port->priority = info->ports[i]->priority;
+                        port->available = info->ports[i]->available;
+                        port->direction = info->ports[i]->direction;
+			port->profiles = determine_profiles_for_port (info->ports[i], profile_list);
+                        port_list = g_list_prepend (port_list, port);
+                        
+                }                
+                gvc_mixer_card_set_ports (card, port_list);                
+                is_new = TRUE;
+        }
+
+        gvc_mixer_card_set_name (card, pa_proplist_gets (info->proplist, "device.description"));
+        gvc_mixer_card_set_icon_name (card, pa_proplist_gets (info->proplist, "device.icon_name"));
+        gvc_mixer_card_set_profile (card, info->active_profile->name);
+
+        if (is_new) {
+                g_hash_table_insert (control->priv->cards,
+                                     GUINT_TO_POINTER (info->index),
+                                     g_object_ref (card));
+        }
+        
+        const GList *card_ports = NULL;
+        const GList *m = NULL;
+        
+        card_ports = gvc_mixer_card_get_ports (card);
+        
+        for (m = card_ports; m != NULL; m = m->next) {
+                GvcMixerCardPort *card_port;
+                card_port = m->data;
+                if (is_new) {
+                        create_ui_device_from_port (control, card_port, card);
+                }
+                else{
+                        for (i = 0; i < info->n_ports; i++) {
+                                if (g_strcmp0 (card_port->port, info->ports[i]->name) == 0){
+                                        if (card_port->available != info->ports[i]->available) {
+                                                card_port->available = info->ports[i]->available;
+                                                g_print ("\n !!! sync port availability on card %i \n card port name %s \n new available value %i \n",
+                                                          gvc_mixer_card_get_index (card),
+                                                          card_port->port,
+                                                          card_port->available);
+                                                match_card_port_with_existing_device (control,
+                                                                                      card_port,
+                                                                                      card,
+                                                                                      card_port->available == 0 ||
+                                                                                      card_port->available == 2);	
+                                        }
+                                }				
+                        }
+                }
+        }
+        g_signal_emit (G_OBJECT (control),
+                       signals[CARD_ADDED],
+                       0,
+                       info->index);
+}
+
+
+
+static void
+_pa_context_get_sink_info_cb (pa_context         *context,
+                              const pa_sink_info *i,
+                              int                 eol,
+                              void               *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Sink callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_sink (control, i);
+}
+
+static void
+_pa_context_get_source_info_cb (pa_context           *context,
+                                const pa_source_info *i,
+                                int                   eol,
+                                void                 *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Source callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_source (control, i);
+}
+
+static void
+_pa_context_get_sink_input_info_cb (pa_context               *context,
+                                    const pa_sink_input_info *i,
+                                    int                       eol,
+                                    void                     *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Sink input callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_sink_input (control, i);
+}
+
+static void
+_pa_context_get_source_output_info_cb (pa_context                  *context,
+                                       const pa_source_output_info *i,
+                                       int                          eol,
+                                       void                        *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Source output callback failure");
+                return;
+        }
+
+        if (eol > 0)  {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_source_output (control, i);
+}
+
+static void
+_pa_context_get_client_info_cb (pa_context           *context,
+                                const pa_client_info *i,
+                                int                   eol,
+                                void                 *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY) {
+                        return;
+                }
+
+                g_warning ("Client callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_client (control, i);
+}
+
+static void
+_pa_context_get_card_info_by_index_cb (pa_context *context,
+                                       const pa_card_info *i,
+                                       int eol,
+                                       void *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                if (pa_context_errno (context) == PA_ERR_NOENTITY)
+                        return;
+
+                g_warning ("Card callback failure");
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                return;
+        }
+
+        update_card (control, i);
+}
+
+static void
+_pa_context_get_server_info_cb (pa_context           *context,
+                                const pa_server_info *i,
+                                void                 *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (i == NULL) {
+                g_warning ("Server info callback failure");
+                return;
+        }
+        g_print ("\n get server info \n");
+        update_server (control, i);
+        dec_outstanding (control);
+}
+
+static void
+remove_event_role_stream (GvcMixerControl *control)
+{
+        g_debug ("Removing event role");
+}
+
+static void
+update_event_role_stream (GvcMixerControl                  *control,
+                          const pa_ext_stream_restore_info *info)
+{
+        GvcMixerStream *stream;
+        gboolean        is_new;
+        pa_volume_t     max_volume;
+
+        if (strcmp (info->name, "sink-input-by-media-role:event") != 0) {
+                return;
+        }
+
+#if 0
+        g_debug ("Updating event role: name='%s' device='%s'",
+                 info->name,
+                 info->device);
+#endif
+
+        is_new = FALSE;
+
+        if (!control->priv->event_sink_input_is_set) {
+                pa_channel_map pa_map;
+                GvcChannelMap *map;
+
+                pa_map.channels = 1;
+                pa_map.map[0] = PA_CHANNEL_POSITION_MONO;
+                map = gvc_channel_map_new_from_pa_channel_map (&pa_map);
+
+                stream = gvc_mixer_event_role_new (control->priv->pa_context,
+                                                   info->device,
+                                                   map);
+                control->priv->event_sink_input_id = gvc_mixer_stream_get_id (stream);
+                control->priv->event_sink_input_is_set = TRUE;
+
+                is_new = TRUE;
+        } else {
+                stream = g_hash_table_lookup (control->priv->all_streams,
+                                              GUINT_TO_POINTER (control->priv->event_sink_input_id));
+        }
+
+        max_volume = pa_cvolume_max (&info->volume);
+
+        gvc_mixer_stream_set_name (stream, _("System Sounds"));
+        gvc_mixer_stream_set_icon_name (stream, "multimedia-volume-control");
+        gvc_mixer_stream_set_volume (stream, (guint)max_volume);
+        gvc_mixer_stream_set_is_muted (stream, info->mute);
+
+        if (is_new) {
+                add_stream (control, stream);
+        }
+}
+
+static void
+_pa_ext_stream_restore_read_cb (pa_context                       *context,
+                                const pa_ext_stream_restore_info *i,
+                                int                               eol,
+                                void                             *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        if (eol < 0) {
+                g_debug ("Failed to initialized stream_restore extension: %s",
+                         pa_strerror (pa_context_errno (context)));
+                remove_event_role_stream (control);
+                return;
+        }
+
+        if (eol > 0) {
+                dec_outstanding (control);
+                /* If we don't have an event stream to restore, then
+                 * set one up with a default 100% volume */
+                if (!control->priv->event_sink_input_is_set) {
+                        pa_ext_stream_restore_info info;
+
+                        memset (&info, 0, sizeof(info));
+                        info.name = "sink-input-by-media-role:event";
+                        info.volume.channels = 1;
+                        info.volume.values[0] = PA_VOLUME_NORM;
+                        update_event_role_stream (control, &info);
+                }
+                return;
+        }
+
+        update_event_role_stream (control, i);
+}
+
+static void
+_pa_ext_stream_restore_subscribe_cb (pa_context *context,
+                                     void       *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+        pa_operation    *o;
+
+        o = pa_ext_stream_restore_read (context,
+                                        _pa_ext_stream_restore_read_cb,
+                                        control);
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_read() failed");
+                return;
+        }
+
+        pa_operation_unref (o);
+}
+
+static void
+req_update_server_info (GvcMixerControl *control,
+                        int              index)
+{
+        pa_operation *o;
+
+        o = pa_context_get_server_info (control->priv->pa_context,
+                                        _pa_context_get_server_info_cb,
+                                        control);
+        if (o == NULL) {
+                g_warning ("pa_context_get_server_info() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_client_info (GvcMixerControl *control,
+                        int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_client_info_list (control->priv->pa_context,
+                                                     _pa_context_get_client_info_cb,
+                                                     control);
+        } else {
+                o = pa_context_get_client_info (control->priv->pa_context,
+                                                index,
+                                                _pa_context_get_client_info_cb,
+                                                control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_client_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_card (GvcMixerControl *control,
+                 int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_card_info_list (control->priv->pa_context,
+                                                   _pa_context_get_card_info_by_index_cb,
+                                                   control);
+        } else {
+                o = pa_context_get_card_info_by_index (control->priv->pa_context,
+                                                       index,
+                                                       _pa_context_get_card_info_by_index_cb,
+                                                       control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_card_info_by_index() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_sink_info (GvcMixerControl *control,
+                      int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_sink_info_list (control->priv->pa_context,
+                                                   _pa_context_get_sink_info_cb,
+                                                   control);
+        } else {
+                o = pa_context_get_sink_info_by_index (control->priv->pa_context,
+                                                       index,
+                                                       _pa_context_get_sink_info_cb,
+                                                       control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_sink_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_source_info (GvcMixerControl *control,
+                        int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_source_info_list (control->priv->pa_context,
+                                                     _pa_context_get_source_info_cb,
+                                                     control);
+        } else {
+                o = pa_context_get_source_info_by_index(control->priv->pa_context,
+                                                        index,
+                                                        _pa_context_get_source_info_cb,
+                                                        control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_source_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_sink_input_info (GvcMixerControl *control,
+                            int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_sink_input_info_list (control->priv->pa_context,
+                                                         _pa_context_get_sink_input_info_cb,
+                                                         control);
+        } else {
+                o = pa_context_get_sink_input_info (control->priv->pa_context,
+                                                    index,
+                                                    _pa_context_get_sink_input_info_cb,
+                                                    control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_sink_input_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+req_update_source_output_info (GvcMixerControl *control,
+                               int              index)
+{
+        pa_operation *o;
+
+        if (index < 0) {
+                o = pa_context_get_source_output_info_list (control->priv->pa_context,
+                                                            _pa_context_get_source_output_info_cb,
+                                                            control);
+        } else {
+                o = pa_context_get_source_output_info (control->priv->pa_context,
+                                                       index,
+                                                       _pa_context_get_source_output_info_cb,
+                                                       control);
+        }
+
+        if (o == NULL) {
+                g_warning ("pa_context_get_source_output_info_list() failed");
+                return;
+        }
+        pa_operation_unref (o);
+}
+
+static void
+remove_client (GvcMixerControl *control,
+               guint            index)
+{
+        g_hash_table_remove (control->priv->clients,
+                             GUINT_TO_POINTER (index));
+}
+
+static void
+remove_card (GvcMixerControl *control,
+             guint            index)
+{
+
+        GList *devices;
+        devices = g_list_concat (g_hash_table_get_values (control->priv->ui_inputs),
+                                 g_hash_table_get_values (control->priv->ui_outputs));
+
+        GList                   *d;
+        GvcMixerUIDevice *device;
+
+        for (d = devices; d != NULL; d = d->next) {
+                gint card_id = GVC_MIXER_UI_DEVICE_INVALID;
+                device = d->data;
+                g_object_get (G_OBJECT (device),
+                             "card-id", &card_id,
+                              NULL);
+                if (card_id == index) {
+                        if (gvc_mixer_ui_device_is_output (device)) {          
+                                g_signal_emit (G_OBJECT (control),
+                                               signals[OUTPUT_REMOVED],
+                                               0,
+                                               gvc_mixer_ui_device_get_id (device));
+                                g_print ("\n Card removal remove output device %s \n",
+                                         gvc_mixer_ui_device_get_description (device)); 
+                                g_hash_table_remove (control->priv->ui_outputs,
+                                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (device)));
+                        }
+                        else{
+                                g_signal_emit (G_OBJECT (control),
+                                               signals[INPUT_REMOVED],
+                                               0,
+                                               gvc_mixer_ui_device_get_id (device));
+                                g_print ("\n Card removal remove input device %s \n",
+                                         gvc_mixer_ui_device_get_description (device)); 
+                                g_hash_table_remove (control->priv->ui_inputs,
+                                                     GUINT_TO_POINTER (gvc_mixer_ui_device_get_id (device)));                                
+                        }                        
+                }
+        }
+        
+        g_hash_table_remove (control->priv->cards,
+                             GUINT_TO_POINTER (index));
+
+        g_signal_emit (G_OBJECT (control),
+                       signals[CARD_REMOVED],
+                       0,
+                       index);
+}
+
+static void
+remove_sink (GvcMixerControl *control,
+             guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing sink: index=%u", index);
+#endif
+
+        stream = g_hash_table_lookup (control->priv->sinks,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }   
+
+        GvcMixerUIDevice *device;
+        device = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+        if (device != NULL){
+                g_print ("\n invalidate stream on device - remove-sinks - %s \n", gvc_mixer_ui_device_get_description (device));        
+
+                gvc_mixer_ui_device_invalidate_stream (device);
+                // If its a software device - get rid of it
+                if (gvc_mixer_ui_device_is_software (device)) {
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[OUTPUT_REMOVED],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (device));                      
+                }
+                // otherwise check to make sure to invalidate other devices which may have that stream
+                else{
+
+                        GList                   *d;
+                        GList                   *devices;
+
+                        devices = g_hash_table_get_values (control->priv->ui_outputs);          
+
+                        for (d = devices; d != NULL; d = d->next) {             
+                                gint stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+                                device = d->data;
+                                g_object_get (G_OBJECT (device),
+                                             "stream-id", &stream_id,
+                                              NULL);
+                                if (stream_id == gvc_mixer_stream_get_id (stream)){
+                                        g_print ("\n invalidate stream on another relevant device - %s \n", gvc_mixer_ui_device_get_description (device)); 
+                                        gvc_mixer_ui_device_invalidate_stream (device);
+                                }
+                        }
+                }
+        }
+
+        g_hash_table_remove (control->priv->sinks,
+                             GUINT_TO_POINTER (index));
+        remove_stream (control, stream);
+}
+
+static void
+remove_source (GvcMixerControl *control,
+               guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing source: index=%u", index);
+#endif
+
+        stream = g_hash_table_lookup (control->priv->sources,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }
+
+        GvcMixerUIDevice *device;
+        device = gvc_mixer_control_lookup_device_from_stream (control, stream);
+
+        if (device != NULL){
+                g_print ("\n invalidate stream on device - %s \n", gvc_mixer_ui_device_get_description (device));        
+
+                gvc_mixer_ui_device_invalidate_stream (device);
+                // If its a software device - get rid of it
+                if (gvc_mixer_ui_device_is_software (device)) {
+                        g_signal_emit (G_OBJECT (control),
+                                       signals[INPUT_REMOVED],
+                                       0,
+                                       gvc_mixer_ui_device_get_id (device));                            
+                }
+                // otherwise check to make sure to invalidate other devices which may have that stream
+                else{
+
+                        GList                   *d;
+                        GList                   *devices;
+
+                        devices = g_hash_table_get_values (control->priv->ui_inputs);          
+
+                        for (d = devices; d != NULL; d = d->next) {             
+                                gint stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+                                device = d->data;
+                                g_object_get (G_OBJECT (device),
+                                             "stream-id", &stream_id,
+                                              NULL);
+                                if (stream_id == gvc_mixer_stream_get_id (stream)){
+                                        g_print ("\n invalidate stream on another relevant device - %s \n", gvc_mixer_ui_device_get_description (device)); 
+                                        gvc_mixer_ui_device_invalidate_stream (device);
+                                }
+                        }
+                }
+        }
+
+
+        g_hash_table_remove (control->priv->sources,
+                             GUINT_TO_POINTER (index));
+
+        remove_stream (control, stream);
+}
+
+static void
+remove_sink_input (GvcMixerControl *control,
+                   guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing sink input: index=%u", index);
+#endif
+        stream = g_hash_table_lookup (control->priv->sink_inputs,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }
+        g_hash_table_remove (control->priv->sink_inputs,
+                             GUINT_TO_POINTER (index));
+
+        remove_stream (control, stream);
+}
+
+static void
+remove_source_output (GvcMixerControl *control,
+                      guint            index)
+{
+        GvcMixerStream *stream;
+
+#if 0
+        g_debug ("Removing source output: index=%u", index);
+#endif
+
+        stream = g_hash_table_lookup (control->priv->source_outputs,
+                                      GUINT_TO_POINTER (index));
+        if (stream == NULL) {
+                return;
+        }
+        g_hash_table_remove (control->priv->source_outputs,
+                             GUINT_TO_POINTER (index));
+
+        remove_stream (control, stream);
+}
+
+static void
+_pa_context_subscribe_cb (pa_context                  *context,
+                          pa_subscription_event_type_t t,
+                          uint32_t                     index,
+                          void                        *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        switch (t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) {
+        case PA_SUBSCRIPTION_EVENT_SINK:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_sink (control, index);
+                } else {
+                        req_update_sink_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_source (control, index);
+                } else {
+                        req_update_source_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SINK_INPUT:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_sink_input (control, index);
+                } else {
+                        req_update_sink_input_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_source_output (control, index);
+                } else {
+                        req_update_source_output_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_CLIENT:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_client (control, index);
+                } else {
+                        req_update_client_info (control, index);
+                }
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_SERVER:
+                req_update_server_info (control, index);
+                break;
+
+        case PA_SUBSCRIPTION_EVENT_CARD:
+                if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                        remove_card (control, index);
+                } else {
+                        req_update_card (control, index);
+                }
+                break;
+        }
+}
+
+static void
+gvc_mixer_control_ready (GvcMixerControl *control)
+{
+        pa_operation *o;
+
+        pa_context_set_subscribe_callback (control->priv->pa_context,
+                                           _pa_context_subscribe_cb,
+                                           control);
+        o = pa_context_subscribe (control->priv->pa_context,
+                                  (pa_subscription_mask_t)
+                                  (PA_SUBSCRIPTION_MASK_SINK|
+                                   PA_SUBSCRIPTION_MASK_SOURCE|
+                                   PA_SUBSCRIPTION_MASK_SINK_INPUT|
+                                   PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT|
+                                   PA_SUBSCRIPTION_MASK_CLIENT|
+                                   PA_SUBSCRIPTION_MASK_SERVER|
+                                   PA_SUBSCRIPTION_MASK_CARD),
+                                  NULL,
+                                  NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_subscribe() failed");
+                return;
+        }
+        pa_operation_unref (o);
+
+        req_update_server_info (control, -1);
+        req_update_card (control, -1);
+        req_update_client_info (control, -1);
+        req_update_sink_info (control, -1);
+        req_update_source_info (control, -1);
+        req_update_sink_input_info (control, -1);
+        req_update_source_output_info (control, -1);
+
+        control->priv->n_outstanding = 6;
+
+        /* This call is not always supported */
+        o = pa_ext_stream_restore_read (control->priv->pa_context,
+                                        _pa_ext_stream_restore_read_cb,
+                                        control);
+        if (o != NULL) {
+                pa_operation_unref (o);
+                control->priv->n_outstanding++;
+
+                pa_ext_stream_restore_set_subscribe_cb (control->priv->pa_context,
+                                                        _pa_ext_stream_restore_subscribe_cb,
+                                                        control);
+
+                o = pa_ext_stream_restore_subscribe (control->priv->pa_context,
+                                                     1,
+                                                     NULL,
+                                                     NULL);
+                if (o != NULL) {
+                        pa_operation_unref (o);
+                }
+
+        } else {
+                g_debug ("Failed to initialized stream_restore extension: %s",
+                         pa_strerror (pa_context_errno (control->priv->pa_context)));
+        }
+}
+
+static void
+gvc_mixer_new_pa_context (GvcMixerControl *self)
+{
+        pa_proplist     *proplist;
+
+        g_return_if_fail (self);
+        g_return_if_fail (!self->priv->pa_context);
+
+        proplist = pa_proplist_new ();
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_NAME,
+                          self->priv->name);
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_ID,
+                          "org.gnome.VolumeControl");
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_ICON_NAME,
+                          "multimedia-volume-control");
+        pa_proplist_sets (proplist,
+                          PA_PROP_APPLICATION_VERSION,
+                          PACKAGE_VERSION);
+
+        self->priv->pa_context = pa_context_new_with_proplist (self->priv->pa_api, NULL, proplist);
+
+        pa_proplist_free (proplist);
+        g_assert (self->priv->pa_context);
+}
+
+static void
+remove_all_streams (GvcMixerControl *control, GHashTable *hash_table)
+{
+        GHashTableIter iter;
+        gpointer key, value;
+
+        g_hash_table_iter_init (&iter, hash_table);
+        while (g_hash_table_iter_next (&iter, &key, &value)) {
+                remove_stream (control, value);
+                g_hash_table_iter_remove (&iter);
+        }
+}
+
+static gboolean
+idle_reconnect (gpointer data)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (data);
+        GHashTableIter iter;
+        gpointer key, value;
+
+        g_return_val_if_fail (control, FALSE);
+
+        if (control->priv->pa_context) {
+                pa_context_unref (control->priv->pa_context);
+                control->priv->pa_context = NULL;
+                gvc_mixer_new_pa_context (control);
+        }
+
+        remove_all_streams (control, control->priv->sinks);
+        remove_all_streams (control, control->priv->sources);
+        remove_all_streams (control, control->priv->sink_inputs);
+        remove_all_streams (control, control->priv->source_outputs);
+
+        g_hash_table_iter_init (&iter, control->priv->clients);
+        while (g_hash_table_iter_next (&iter, &key, &value))
+                g_hash_table_iter_remove (&iter);
+
+        gvc_mixer_control_open (control); /* cannot fail */
+
+        control->priv->reconnect_id = 0;
+        return FALSE;
+}
+
+static void
+_pa_context_state_cb (pa_context *context,
+                      void       *userdata)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (userdata);
+
+        switch (pa_context_get_state (context)) {
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+                break;
+
+        case PA_CONTEXT_READY:
+                gvc_mixer_control_ready (control);
+                break;
+
+        case PA_CONTEXT_FAILED:
+                control->priv->state = GVC_STATE_FAILED;
+                g_signal_emit (control, signals[STATE_CHANGED], 0, GVC_STATE_FAILED);
+                if (control->priv->reconnect_id == 0)
+                        control->priv->reconnect_id = g_timeout_add_seconds (RECONNECT_DELAY, idle_reconnect, control);
+                break;
+
+        case PA_CONTEXT_TERMINATED:
+        default:
+                /* FIXME: */
+                break;
+        }
+}
+
+gboolean
+gvc_mixer_control_open (GvcMixerControl *control)
+{
+        int res;
+
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (control->priv->pa_context != NULL, FALSE);
+        g_return_val_if_fail (pa_context_get_state (control->priv->pa_context) == PA_CONTEXT_UNCONNECTED, FALSE);
+
+        pa_context_set_state_callback (control->priv->pa_context,
+                                       _pa_context_state_cb,
+                                       control);
+
+        control->priv->state = GVC_STATE_CONNECTING;
+        g_signal_emit (G_OBJECT (control), signals[STATE_CHANGED], 0, GVC_STATE_CONNECTING);
+        res = pa_context_connect (control->priv->pa_context, NULL, (pa_context_flags_t) PA_CONTEXT_NOFAIL, NULL);
+        if (res < 0) {
+                g_warning ("Failed to connect context: %s",
+                           pa_strerror (pa_context_errno (control->priv->pa_context)));
+        }
+
+        return res;
+}
+
+gboolean
+gvc_mixer_control_close (GvcMixerControl *control)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_CONTROL (control), FALSE);
+        g_return_val_if_fail (control->priv->pa_context != NULL, FALSE);
+
+        pa_context_disconnect (control->priv->pa_context);
+
+        control->priv->state = GVC_STATE_CLOSED;
+        g_signal_emit (G_OBJECT (control), signals[STATE_CHANGED], 0, GVC_STATE_CLOSED);
+        return TRUE;
+}
+
+static void
+gvc_mixer_control_dispose (GObject *object)
+{
+        GvcMixerControl *control = GVC_MIXER_CONTROL (object);
+
+        if (control->priv->reconnect_id != 0) {
+                g_source_remove (control->priv->reconnect_id);
+                control->priv->reconnect_id = 0;
+        }
+
+        if (control->priv->pa_context != NULL) {
+                pa_context_unref (control->priv->pa_context);
+                control->priv->pa_context = NULL;
+        }
+
+        if (control->priv->default_source_name != NULL) {
+                g_free (control->priv->default_source_name);
+                control->priv->default_source_name = NULL;
+        }
+        if (control->priv->default_sink_name != NULL) {
+                g_free (control->priv->default_sink_name);
+                control->priv->default_sink_name = NULL;
+        }
+
+        if (control->priv->pa_mainloop != NULL) {
+                pa_glib_mainloop_free (control->priv->pa_mainloop);
+                control->priv->pa_mainloop = NULL;
+        }
+
+        if (control->priv->all_streams != NULL) {
+                g_hash_table_destroy (control->priv->all_streams);
+                control->priv->all_streams = NULL;
+        }
+
+        if (control->priv->sinks != NULL) {
+                g_hash_table_destroy (control->priv->sinks);
+                control->priv->sinks = NULL;
+        }
+        if (control->priv->sources != NULL) {
+                g_hash_table_destroy (control->priv->sources);
+                control->priv->sources = NULL;
+        }
+        if (control->priv->sink_inputs != NULL) {
+                g_hash_table_destroy (control->priv->sink_inputs);
+                control->priv->sink_inputs = NULL;
+        }
+        if (control->priv->source_outputs != NULL) {
+                g_hash_table_destroy (control->priv->source_outputs);
+                control->priv->source_outputs = NULL;
+        }
+        if (control->priv->clients != NULL) {
+                g_hash_table_destroy (control->priv->clients);
+                control->priv->clients = NULL;
+        }
+        if (control->priv->cards != NULL) {
+                g_hash_table_destroy (control->priv->cards);
+                control->priv->cards = NULL;
+        }
+        if (control->priv->ui_outputs != NULL) {
+                g_hash_table_destroy (control->priv->ui_outputs);
+                control->priv->ui_outputs = NULL;
+        }
+        if (control->priv->ui_inputs != NULL) {
+                g_hash_table_destroy (control->priv->ui_inputs);
+                control->priv->ui_inputs = NULL;
+        }
+        
+
+        G_OBJECT_CLASS (gvc_mixer_control_parent_class)->dispose (object);
+}
+
+static void
+gvc_mixer_control_set_property (GObject       *object,
+                                guint          prop_id,
+                                const GValue  *value,
+                                GParamSpec    *pspec)
+{
+        GvcMixerControl *self = GVC_MIXER_CONTROL (object);
+
+        switch (prop_id) {
+        case PROP_NAME:
+                g_free (self->priv->name);
+                self->priv->name = g_value_dup_string (value);
+                g_object_notify (G_OBJECT (self), "name");
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_control_get_property (GObject     *object,
+                                guint        prop_id,
+                                GValue      *value,
+                                GParamSpec  *pspec)
+{
+        GvcMixerControl *self = GVC_MIXER_CONTROL (object);
+
+        switch (prop_id) {
+        case PROP_NAME:
+                g_value_set_string (value, self->priv->name);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+
+static GObject *
+gvc_mixer_control_constructor (GType                  type,
+                               guint                  n_construct_properties,
+                               GObjectConstructParam *construct_params)
+{
+        GObject         *object;
+        GvcMixerControl *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_control_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_CONTROL (object);
+
+        gvc_mixer_new_pa_context (self);
+        self->priv->cached_desired_output_id = GVC_MIXER_UI_DEVICE_INVALID;
+        self->priv->cached_desired_input_id = GVC_MIXER_UI_DEVICE_INVALID;
+        self->priv->profile_swapping_device_id = GVC_MIXER_UI_DEVICE_INVALID;
+
+        return object;
+}
+
+static void
+gvc_mixer_control_class_init (GvcMixerControlClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_mixer_control_constructor;
+        object_class->dispose = gvc_mixer_control_dispose;
+        object_class->finalize = gvc_mixer_control_finalize;
+        object_class->set_property = gvc_mixer_control_set_property;
+        object_class->get_property = gvc_mixer_control_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this mixer control",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+
+        signals [STATE_CHANGED] =
+                g_signal_new ("state-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, state_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [STREAM_ADDED] =
+                g_signal_new ("stream-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, stream_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [STREAM_REMOVED] =
+                g_signal_new ("stream-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, stream_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [CARD_ADDED] =
+                g_signal_new ("card-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, card_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [CARD_REMOVED] =
+                g_signal_new ("card-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, card_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [DEFAULT_SINK_CHANGED] =
+                g_signal_new ("default-sink-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, default_sink_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [DEFAULT_SOURCE_CHANGED] =
+                g_signal_new ("default-source-changed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, default_source_changed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [OUTPUT_ADDED] =
+                g_signal_new ("output-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, output_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+
+        signals [ACTIVE_OUTPUT_UPDATE] =
+                g_signal_new ("active-output-update",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, active_output_update),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+
+        signals [OUTPUT_REMOVED] =
+                g_signal_new ("output-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, output_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [INPUT_ADDED] =
+                g_signal_new ("input-added",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, input_added),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [INPUT_REMOVED] =
+                g_signal_new ("input-removed",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, input_removed),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);
+        signals [ACTIVE_INPUT_UPDATE] =
+                g_signal_new ("active-input-update",
+                              G_TYPE_FROM_CLASS (klass),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (GvcMixerControlClass, active_input_update),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__UINT,
+                              G_TYPE_NONE, 1, G_TYPE_UINT);                              
+        g_type_class_add_private (klass, sizeof (GvcMixerControlPrivate));
+}
+
+
+static void
+gvc_mixer_control_init (GvcMixerControl *control)
+{
+        control->priv = GVC_MIXER_CONTROL_GET_PRIVATE (control);
+
+        control->priv->pa_mainloop = pa_glib_mainloop_new (g_main_context_default ());
+        g_assert (control->priv->pa_mainloop);
+
+        control->priv->pa_api = pa_glib_mainloop_get_api (control->priv->pa_mainloop);
+        g_assert (control->priv->pa_api);
+
+        control->priv->all_streams = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->sinks = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->sources = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->sink_inputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->source_outputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->cards = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->ui_outputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+        control->priv->ui_inputs = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_object_unref);
+
+        control->priv->clients = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_free);
+
+        control->priv->state = GVC_STATE_CLOSED;
+}
+
+static void
+gvc_mixer_control_finalize (GObject *object)
+{
+        GvcMixerControl *mixer_control;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_CONTROL (object));
+
+        mixer_control = GVC_MIXER_CONTROL (object);
+        g_free (mixer_control->priv->name);
+        mixer_control->priv->name = NULL;
+
+        g_return_if_fail (mixer_control->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_control_parent_class)->finalize (object);
+}
+
+GvcMixerControl *
+gvc_mixer_control_new (const char *name)
+{
+        GObject *control;
+        control = g_object_new (GVC_TYPE_MIXER_CONTROL,
+                                "name", name,
+                                NULL);
+        return GVC_MIXER_CONTROL (control);
+}
+
+/* FIXME: Remove when PA 0.9.23 is used */
+#ifndef PA_VOLUME_UI_MAX
+#define PA_VOLUME_UI_MAX pa_sw_volume_from_dB(+11.0)
+#endif
+
+gdouble
+gvc_mixer_control_get_vol_max_norm (GvcMixerControl *control)
+{
+	return (gdouble) PA_VOLUME_NORM;
+}
+
+gdouble
+gvc_mixer_control_get_vol_max_amplified (GvcMixerControl *control)
+{
+	return (gdouble) PA_VOLUME_UI_MAX;
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-control.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-control.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,139 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_CONTROL_H
+#define __GVC_MIXER_CONTROL_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-ui-device.h"
+
+G_BEGIN_DECLS
+
+typedef enum
+{
+        GVC_STATE_CLOSED,
+        GVC_STATE_READY,
+        GVC_STATE_CONNECTING,
+        GVC_STATE_FAILED
+} GvcMixerControlState;
+
+#define GVC_TYPE_MIXER_CONTROL         (gvc_mixer_control_get_type ())
+#define GVC_MIXER_CONTROL(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_CONTROL, GvcMixerControl))
+#define GVC_MIXER_CONTROL_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_CONTROL, GvcMixerControlClass))
+#define GVC_IS_MIXER_CONTROL(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_CONTROL))
+#define GVC_IS_MIXER_CONTROL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_CONTROL))
+#define GVC_MIXER_CONTROL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_CONTROL, GvcMixerControlClass))
+
+typedef struct GvcMixerControlPrivate GvcMixerControlPrivate;
+
+typedef struct
+{
+        GObject                 parent;
+        GvcMixerControlPrivate *priv;
+} GvcMixerControl;
+
+typedef struct
+{
+        GObjectClass            parent_class;
+
+        void (*state_changed)          (GvcMixerControl      *control,
+                                        GvcMixerControlState  new_state);
+        void (*stream_added)           (GvcMixerControl *control,
+                                        guint            id);
+        void (*stream_removed)         (GvcMixerControl *control,
+                                        guint            id);
+        void (*card_added)             (GvcMixerControl *control,
+                                        guint            id);
+        void (*card_removed)           (GvcMixerControl *control,
+                                        guint            id);
+        void (*default_sink_changed)   (GvcMixerControl *control,
+                                        guint            id);
+        void (*default_source_changed) (GvcMixerControl *control,
+                                        guint            id);
+        void (*output_added)           (GvcMixerControl *control,
+                                        guint            id);
+        void (*output_removed)         (GvcMixerControl *control,
+                                        guint            id);
+        void (*active_output_update)   (GvcMixerControl *control,
+                                        guint            id);
+        void (*active_input_update)    (GvcMixerControl *control,
+                                        guint            id);
+        void (*input_added)            (GvcMixerControl *control,
+                                        guint            id);
+        void (*input_removed)          (GvcMixerControl *control,
+                                        guint            id);
+                                        
+} GvcMixerControlClass;
+
+GType               gvc_mixer_control_get_type            (void);
+
+GvcMixerControl *   gvc_mixer_control_new                 (const char *name);
+
+gboolean            gvc_mixer_control_open                (GvcMixerControl *control);
+gboolean            gvc_mixer_control_close               (GvcMixerControl *control);
+
+GSList *            gvc_mixer_control_get_cards           (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_streams         (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_sinks           (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_sources         (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_sink_inputs     (GvcMixerControl *control);
+GSList *            gvc_mixer_control_get_source_outputs  (GvcMixerControl *control);
+
+GvcMixerStream *        gvc_mixer_control_lookup_stream_id    (GvcMixerControl *control,
+                                                           guint            id);
+GvcMixerCard   *        gvc_mixer_control_lookup_card_id      (GvcMixerControl *control,
+                                                           guint            id);
+GvcMixerUIDevice *      gvc_mixer_control_lookup_output_id    (GvcMixerControl *control,
+                                                           guint            id);	                                                               
+GvcMixerUIDevice *      gvc_mixer_control_lookup_input_id    (GvcMixerControl *control,
+                                                          guint            id);	                                                               
+
+GvcMixerStream *        gvc_mixer_control_get_default_sink     (GvcMixerControl *control);
+GvcMixerStream *        gvc_mixer_control_get_default_source   (GvcMixerControl *control);
+GvcMixerStream *        gvc_mixer_control_get_event_sink_input (GvcMixerControl *control);
+
+gboolean                gvc_mixer_control_set_default_sink     (GvcMixerControl *control,
+                                                            GvcMixerStream  *stream);
+gboolean                gvc_mixer_control_set_default_source   (GvcMixerControl *control,
+                                                            GvcMixerStream  *stream);
+
+gdouble                 gvc_mixer_control_get_vol_max_norm      (GvcMixerControl *control);
+gdouble                 gvc_mixer_control_get_vol_max_amplified (GvcMixerControl *control);
+void                    gvc_mixer_control_change_output         (GvcMixerControl *control,
+                                                                 GvcMixerUIDevice* output);
+void                    gvc_mixer_control_change_input          (GvcMixerControl *control,
+                                                                 GvcMixerUIDevice* input);
+gchar*                  gvc_mixer_control_get_active_profile_from_ui_device (GvcMixerControl* control,
+                                                                             GvcMixerUIDevice* device);
+GvcMixerStream*         gvc_mixer_control_get_stream_from_device (GvcMixerControl *control,
+                                                                  GvcMixerUIDevice *dev);
+gboolean                gvc_mixer_control_change_profile_on_selected_device (GvcMixerControl *control,
+                                                                             GvcMixerUIDevice *device,
+                                                                             const gchar* profile);
+
+
+GvcMixerControlState gvc_mixer_control_get_state            (GvcMixerControl *control);
+
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_CONTROL_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-dialog.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-dialog.c	2012-02-14 13:55:14.673130208 -0500
@@ -0,0 +1,2209 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ * Copyright (C) 2012 Conor Curran
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+
+#include "gvc-channel-bar.h"
+#include "gvc-balance-bar.h"
+#include "gvc-combo-box.h"
+#include "gvc-mixer-control.h"
+#include "gvc-mixer-card.h"
+#include "gvc-mixer-ui-device.h"
+#include "gvc-mixer-sink.h"
+#include "gvc-mixer-source.h"
+#include "gvc-mixer-source-output.h"
+#include "gvc-mixer-dialog.h"
+#include "gvc-sound-theme-chooser.h"
+#include "gvc-level-bar.h"
+#include "gvc-speaker-test.h"
+#include "gvc-mixer-control-private.h"
+
+#define SCALE_SIZE 128
+
+#define GVC_MIXER_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_DIALOG, GvcMixerDialogPrivate))
+
+struct GvcMixerDialogPrivate
+{
+        GvcMixerControl *mixer_control;
+        GHashTable      *bars;        
+        GtkWidget       *notebook;
+        GtkWidget       *output_bar;
+        GtkWidget       *input_bar;
+        GtkWidget       *input_level_bar;
+        GtkWidget       *effects_bar;
+        GtkWidget       *output_stream_box;
+        GtkWidget       *sound_effects_box;
+        GtkWidget       *hw_box;
+        GtkWidget       *hw_treeview;
+        GtkWidget       *hw_settings_box;
+        GtkWidget       *hw_profile_combo;
+        GtkWidget       *input_box;
+        GtkWidget       *output_box;
+        GtkWidget       *applications_box;
+        GtkWidget       *no_apps_label;
+        GtkWidget       *output_treeview;
+        GtkWidget       *output_settings_box;
+        GtkWidget       *output_balance_bar;
+        GtkWidget       *output_fade_bar;
+        GtkWidget       *output_lfe_bar;
+        GtkWidget       *output_port_combo;
+        GtkWidget       *input_treeview;
+        GtkWidget       *input_settings_box;
+        GtkWidget       *sound_theme_chooser;
+        GtkWidget       *click_feedback_button;
+        GtkWidget       *audible_bell_button;
+        GtkSizeGroup    *size_group;
+        GtkWidget       *selected_output_label;
+        GtkWidget       *selected_input_label;
+        GtkWidget       *test_output_button;
+        GSettings       *indicator_settings;
+
+        gdouble          last_input_peak;
+        guint            num_apps;
+};
+
+enum {
+        NAME_COLUMN,
+        DEVICE_COLUMN,
+        ACTIVE_COLUMN,
+        ID_COLUMN,
+        SPEAKERS_COLUMN,
+        ICON_COLUMN,
+        NUM_COLUMNS
+};
+
+enum {
+        HW_ID_COLUMN,
+        HW_ICON_COLUMN,
+        HW_NAME_COLUMN,
+        HW_STATUS_COLUMN,
+        HW_PROFILE_COLUMN,
+        HW_PROFILE_HUMAN_COLUMN,
+        HW_SENSITIVE_COLUMN,
+        HW_NUM_COLUMNS
+};
+
+enum
+{
+        PROP_0,
+        PROP_MIXER_CONTROL
+};
+
+static void     gvc_mixer_dialog_class_init (GvcMixerDialogClass *klass);
+static void     gvc_mixer_dialog_init       (GvcMixerDialog      *mixer_dialog);
+static void     gvc_mixer_dialog_finalize   (GObject             *object);
+
+static void     bar_set_stream              (GvcMixerDialog      *dialog,
+                                             GtkWidget           *bar,
+                                             GvcMixerStream      *stream);
+
+static void     on_adjustment_value_changed (GtkAdjustment  *adjustment,
+                                             GvcMixerDialog *dialog);
+static void  	on_control_output_added (GvcMixerControl *control,
+                                       guint            id,
+                                       GvcMixerDialog  *dialog);
+static void   on_control_active_output_update (GvcMixerControl *control,
+                                               guint            id,
+                                               GvcMixerDialog  *dialog);
+                                       
+static void   on_control_active_input_update (GvcMixerControl *control,
+                                              guint            id,
+                                              GvcMixerDialog  *dialog);
+
+G_DEFINE_TYPE (GvcMixerDialog, gvc_mixer_dialog, GTK_TYPE_VBOX)
+
+
+static void
+update_description (GvcMixerDialog *dialog,
+                    guint column,
+                    const char *value,
+                    GvcMixerStream *stream)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        guint         id;
+
+        if (GVC_IS_MIXER_SOURCE (stream))
+                model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        else if (GVC_IS_MIXER_SINK (stream))
+                model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        else
+                g_assert_not_reached ();
+        gtk_tree_model_get_iter_first (model, &iter);
+
+        id = gvc_mixer_stream_get_id (stream);
+        do {
+                guint       current_id;
+
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &current_id,
+                                    -1);
+                if (id != current_id)
+                        continue;
+
+                gtk_list_store_set (GTK_LIST_STORE (model),
+                                    &iter,
+                                    column, value,
+                                    -1);
+                break;
+        } while (gtk_tree_model_iter_next (model, &iter));
+}
+
+static void
+profile_selection_changed (GvcComboBox *combo_box,
+                           const char  *profile,
+                           GvcMixerDialog *dialog)
+{	
+        g_print ("profile_selection_changed - %s", profile);
+        GvcMixerUIDevice *out;
+        out = g_object_get_data (G_OBJECT (combo_box), "uidevice");
+        
+        if (out == NULL) {
+                g_warning ("Could not find Output for profile combo box");
+                return;
+        }
+
+        g_print (" \n on profile selection changed on output with \n description %s \n origin %s \n id %i \n \n",
+                gvc_mixer_ui_device_get_description (out),
+                gvc_mixer_ui_device_get_origin (out),
+                gvc_mixer_ui_device_get_id (out));
+
+        if (gvc_mixer_control_change_profile_on_selected_device (dialog->priv->mixer_control, out, profile) == FALSE) {
+                g_warning ("Could not change profile on device %s",
+                           gvc_mixer_ui_device_get_description (out));
+        }
+}
+
+#define DECAY_STEP .15
+
+static void
+update_input_peak (GvcMixerDialog *dialog,
+                   gdouble         v)
+{
+        GtkAdjustment *adj;
+
+        if (dialog->priv->last_input_peak >= DECAY_STEP) {
+                if (v < dialog->priv->last_input_peak - DECAY_STEP) {
+                        v = dialog->priv->last_input_peak - DECAY_STEP;
+                }
+        }
+
+        dialog->priv->last_input_peak = v;
+
+        adj = gvc_level_bar_get_peak_adjustment (GVC_LEVEL_BAR (dialog->priv->input_level_bar));
+        if (v >= 0) {
+                gtk_adjustment_set_value (adj, v);
+        } else {
+                gtk_adjustment_set_value (adj, 0.0);
+        }
+}
+
+static void
+update_input_meter (GvcMixerDialog *dialog,
+                    uint32_t        source_index,
+                    uint32_t        sink_input_idx,
+                    double          v)
+{
+        update_input_peak (dialog, v);
+}
+
+static void
+on_monitor_suspended_callback (pa_stream *s,
+                               void      *userdata)
+{
+        GvcMixerDialog *dialog;
+
+        dialog = userdata;
+
+        if (pa_stream_is_suspended (s)) {
+                g_debug ("Stream suspended");
+                update_input_meter (dialog,
+                                    pa_stream_get_device_index (s),
+                                    PA_INVALID_INDEX,
+                                    -1);
+        }
+}
+
+static void
+on_monitor_read_callback (pa_stream *s,
+                          size_t     length,
+                          void      *userdata)
+{
+        GvcMixerDialog *dialog;
+        const void     *data;
+        double          v;
+
+        dialog = userdata;
+
+        if (pa_stream_peek (s, &data, &length) < 0) {
+                g_warning ("Failed to read data from stream");
+                return;
+        }
+
+        assert (length > 0);
+        assert (length % sizeof (float) == 0);
+
+        v = ((const float *) data)[length / sizeof (float) -1];
+
+        pa_stream_drop (s);
+
+        if (v < 0) {
+                v = 0;
+        }
+        if (v > 1) {
+                v = 1;
+        }
+
+        update_input_meter (dialog,
+                            pa_stream_get_device_index (s),
+                            pa_stream_get_monitor_stream (s),
+                            v);
+}
+
+static void
+create_monitor_stream_for_source (GvcMixerDialog *dialog,
+                                  GvcMixerStream *stream)
+{
+        pa_stream     *s;
+        char           t[16];
+        pa_buffer_attr attr;
+        pa_sample_spec ss;
+        pa_context    *context;
+        int            res;
+        pa_proplist   *proplist;
+        gboolean       has_monitor;
+
+        if (stream == NULL) {
+                return;
+        }
+        has_monitor = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (stream), "has-monitor"));
+        if (has_monitor != FALSE) {
+                return;
+        }
+
+        g_debug ("Create monitor for %u",
+                 gvc_mixer_stream_get_index (stream));
+
+        context = gvc_mixer_control_get_pa_context (dialog->priv->mixer_control);
+
+        if (pa_context_get_server_protocol_version (context) < 13) {
+                return;
+        }
+
+        ss.channels = 1;
+        ss.format = PA_SAMPLE_FLOAT32;
+        ss.rate = 25;
+
+        memset (&attr, 0, sizeof (attr));
+        attr.fragsize = sizeof (float);
+        attr.maxlength = (uint32_t) -1;
+
+        snprintf (t, sizeof (t), "%u", gvc_mixer_stream_get_index (stream));
+
+        proplist = pa_proplist_new ();
+        pa_proplist_sets (proplist, PA_PROP_APPLICATION_ID, "org.gnome.VolumeControl");
+        s = pa_stream_new_with_proplist (context, _("Peak detect"), &ss, NULL, proplist);
+        pa_proplist_free (proplist);
+        if (s == NULL) {
+                g_warning ("Failed to create monitoring stream");
+                return;
+        }
+
+        pa_stream_set_read_callback (s, on_monitor_read_callback, dialog);
+        pa_stream_set_suspended_callback (s, on_monitor_suspended_callback, dialog);
+
+        res = pa_stream_connect_record (s,
+                                        t,
+                                        &attr,
+                                        (pa_stream_flags_t) (PA_STREAM_DONT_MOVE
+                                                             |PA_STREAM_PEAK_DETECT
+                                                             |PA_STREAM_ADJUST_LATENCY));
+        if (res < 0) {
+                g_warning ("Failed to connect monitoring stream");
+                pa_stream_unref (s);
+        } else {
+                g_object_set_data (G_OBJECT (stream), "has-monitor", GINT_TO_POINTER (TRUE));
+                g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "pa_stream", s);
+                g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "stream", stream);
+        }
+}
+
+static void
+stop_monitor_stream_for_source (GvcMixerDialog *dialog)
+{
+        pa_stream      *s;
+        pa_context     *context;
+        int             res;
+        GvcMixerStream *stream;
+
+        s = g_object_get_data (G_OBJECT (dialog->priv->input_level_bar), "pa_stream");
+        if (s == NULL)
+                return;
+        stream = g_object_get_data (G_OBJECT (dialog->priv->input_level_bar), "stream");
+        g_assert (stream != NULL);
+
+        g_debug ("Stopping monitor for %u", pa_stream_get_index (s));
+
+        context = gvc_mixer_control_get_pa_context (dialog->priv->mixer_control);
+
+        if (pa_context_get_server_protocol_version (context) < 13) {
+                return;
+        }
+
+        res = pa_stream_disconnect (s);
+        if (res == 0)
+                g_object_set_data (G_OBJECT (stream), "has-monitor", GINT_TO_POINTER (FALSE));
+        g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "pa_stream", NULL);
+        g_object_set_data (G_OBJECT (dialog->priv->input_level_bar), "stream", NULL);
+}
+
+static void
+gvc_mixer_dialog_set_mixer_control (GvcMixerDialog  *dialog,
+                                    GvcMixerControl *control)
+{
+        g_return_if_fail (GVC_MIXER_DIALOG (dialog));
+        g_return_if_fail (GVC_IS_MIXER_CONTROL (control));
+
+        g_object_ref (control);
+
+        if (dialog->priv->mixer_control != NULL) {
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      G_CALLBACK (on_control_active_output_update),
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      G_CALLBACK (on_control_active_input_update),
+                                                      dialog);
+                g_object_unref (dialog->priv->mixer_control);
+        }
+
+        dialog->priv->mixer_control = control;
+
+        g_signal_connect (dialog->priv->mixer_control,
+                          "active-output-update",
+                          G_CALLBACK (on_control_active_output_update),
+                          dialog);
+        g_signal_connect (dialog->priv->mixer_control,
+                          "active-input-update",
+                          G_CALLBACK (on_control_active_input_update),
+                          dialog);
+
+        g_object_notify (G_OBJECT (dialog), "mixer-control");
+}
+
+static GvcMixerControl *
+gvc_mixer_dialog_get_mixer_control (GvcMixerDialog *dialog)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_DIALOG (dialog), NULL);
+
+        return dialog->priv->mixer_control;
+}
+
+static void
+gvc_mixer_dialog_set_property (GObject       *object,
+                               guint          prop_id,
+                               const GValue  *value,
+                               GParamSpec    *pspec)
+{
+        GvcMixerDialog *self = GVC_MIXER_DIALOG (object);
+
+        switch (prop_id) {
+        case PROP_MIXER_CONTROL:
+                gvc_mixer_dialog_set_mixer_control (self, g_value_get_object (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_dialog_get_property (GObject     *object,
+                               guint        prop_id,
+                               GValue      *value,
+                               GParamSpec  *pspec)
+{
+        GvcMixerDialog *self = GVC_MIXER_DIALOG (object);
+
+        switch (prop_id) {
+        case PROP_MIXER_CONTROL:
+                g_value_set_object (value, gvc_mixer_dialog_get_mixer_control (self));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+on_adjustment_value_changed (GtkAdjustment  *adjustment,
+                             GvcMixerDialog *dialog)
+{
+        GvcMixerStream *stream;
+
+        stream = g_object_get_data (G_OBJECT (adjustment), "gvc-mixer-dialog-stream");
+        if (stream != NULL) {
+                GObject *bar;
+                gdouble volume, rounded;
+                char *name;
+
+                volume = gtk_adjustment_get_value (adjustment);
+                rounded = round (volume);
+
+                bar = g_object_get_data (G_OBJECT (adjustment), "gvc-mixer-dialog-bar");
+                g_object_get (bar, "name", &name, NULL);
+                g_debug ("Setting stream volume %lf (rounded: %lf) for bar '%s'", volume, rounded, name);
+                g_free (name);
+
+                /* FIXME would need to do that in the balance bar really... */
+                /* Make sure we do not unmute muted streams, there's a button for that */
+                if (volume == 0.0)
+                        gvc_mixer_stream_set_is_muted (stream, TRUE);
+                /* Only push the volume if it's actually changed */
+                if (gvc_mixer_stream_set_volume(stream, (pa_volume_t) rounded) != FALSE)
+                        gvc_mixer_stream_push_volume (stream);
+        }
+}
+
+static void
+on_bar_is_muted_notify (GObject        *object,
+                        GParamSpec     *pspec,
+                        GvcMixerDialog *dialog)
+{
+        gboolean        is_muted;
+        GvcMixerStream *stream;
+
+        is_muted = gvc_channel_bar_get_is_muted (GVC_CHANNEL_BAR (object));
+
+        stream = g_object_get_data (object, "gvc-mixer-dialog-stream");
+        if (stream != NULL) {
+                gvc_mixer_stream_change_is_muted (stream, is_muted);
+        } else {
+                char *name;
+                g_object_get (object, "name", &name, NULL);
+                g_warning ("Unable to find stream for bar '%s'", name);
+                g_free (name);
+        }
+}
+
+static GtkWidget *
+lookup_bar_for_stream (GvcMixerDialog *dialog,
+                       GvcMixerStream *stream)
+{
+        GtkWidget *bar;
+
+        bar = g_hash_table_lookup (dialog->priv->bars, GUINT_TO_POINTER (gvc_mixer_stream_get_id (stream)));
+
+        return bar;
+}
+
+// TODO
+// Do we need this ?
+// UI devices now pull description material mainly for the card ports.
+// Therefore the need for stream description dynamic changes more than ever seems unneccessary. 
+static void
+on_stream_description_notify (GvcMixerStream *stream,
+                              GParamSpec     *pspec,
+                              GvcMixerDialog *dialog)
+{
+        update_description (dialog, NAME_COLUMN,
+                            gvc_mixer_stream_get_description (stream),
+                            stream);
+}
+
+static void
+on_stream_volume_notify (GObject        *object,
+                         GParamSpec     *pspec,
+                         GvcMixerDialog *dialog)
+{
+        GvcMixerStream *stream;
+        GtkWidget      *bar;
+        GtkAdjustment  *adj;
+        stream = GVC_MIXER_STREAM (object);
+
+        bar = lookup_bar_for_stream (dialog, stream);
+
+        if (bar == NULL) {
+                if (stream == gvc_mixer_control_get_default_sink(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->output_bar;
+                }
+                else if(stream == gvc_mixer_control_get_default_source(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->input_bar;
+                }
+                else{
+                        g_warning ("Unable to find bar for stream %s in on_stream_volume_notify()",
+                                   gvc_mixer_stream_get_name (stream));
+                        return;
+                }
+        }
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (bar)));
+
+        g_signal_handlers_block_by_func (adj,
+                                         on_adjustment_value_changed,
+                                         dialog);
+
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (stream));
+
+        g_signal_handlers_unblock_by_func (adj,
+                                           on_adjustment_value_changed,
+                                           dialog);
+}
+
+static void
+on_stream_is_muted_notify (GObject        *object,
+                           GParamSpec     *pspec,
+                           GvcMixerDialog *dialog)
+{
+        GvcMixerStream *stream;
+        GtkWidget      *bar;
+        gboolean        is_muted;
+
+        stream = GVC_MIXER_STREAM (object);
+
+        bar = lookup_bar_for_stream (dialog, stream);
+
+        if (bar == NULL) {
+                if (stream == gvc_mixer_control_get_default_sink(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->output_bar;
+                }
+                else if(stream == gvc_mixer_control_get_default_source(dialog->priv->mixer_control)) {
+                        bar = dialog->priv->input_bar;
+                }                
+                else{
+                        g_warning ("Unable to find bar for stream %s in on_stream_muted_notify()",
+                                   gvc_mixer_stream_get_name (stream));
+                        return;
+                }
+        }
+
+
+        is_muted = gvc_mixer_stream_get_is_muted (stream);
+        gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (bar),
+                                      is_muted);
+
+        if (stream == gvc_mixer_control_get_default_sink (dialog->priv->mixer_control)) {
+                gtk_widget_set_sensitive (dialog->priv->applications_box,
+                                          !is_muted);
+        }
+
+}
+
+static void
+save_bar_for_stream (GvcMixerDialog *dialog,
+                     GvcMixerStream *stream,
+                     GtkWidget      *bar)
+{
+        g_print ("\n saving bar for stream %s",
+                 gvc_mixer_stream_get_name (stream));
+        g_hash_table_insert (dialog->priv->bars,
+                             GUINT_TO_POINTER (gvc_mixer_stream_get_id (stream)),
+                             bar);
+}
+
+static GtkWidget *
+create_bar (GvcMixerDialog *dialog,
+            gboolean        add_to_size_group,
+            gboolean        symmetric)
+{
+        GtkWidget *bar;
+
+        bar = gvc_channel_bar_new ();
+        gtk_widget_set_sensitive (bar, FALSE);
+        if (add_to_size_group && dialog->priv->size_group != NULL) {
+                gvc_channel_bar_set_size_group (GVC_CHANNEL_BAR (bar),
+                                                dialog->priv->size_group,
+                                                symmetric);
+        }
+        gvc_channel_bar_set_orientation (GVC_CHANNEL_BAR (bar),
+                                         GTK_ORIENTATION_HORIZONTAL);
+        gvc_channel_bar_set_show_mute (GVC_CHANNEL_BAR (bar),
+                                       TRUE);
+        g_signal_connect (bar,
+                          "notify::is-muted",
+                          G_CALLBACK (on_bar_is_muted_notify),
+                          dialog);
+        return bar;
+}
+
+static GtkWidget *
+create_app_bar (GvcMixerDialog *dialog,
+                const char     *name,
+                const char     *icon_name)
+{
+        GtkWidget *bar;
+
+        bar = create_bar (dialog, FALSE, FALSE);
+        gvc_channel_bar_set_ellipsize (GVC_CHANNEL_BAR (bar), TRUE);
+        gvc_channel_bar_set_icon_name (GVC_CHANNEL_BAR (bar), icon_name);
+        if (name == NULL || strchr (name, '_') == NULL) {
+                gvc_channel_bar_set_name (GVC_CHANNEL_BAR (bar), name);
+        } else {
+                char **tokens, *escaped;
+
+                tokens = g_strsplit (name, "_", -1);
+                escaped = g_strjoinv ("__", tokens);
+                g_strfreev (tokens);
+                gvc_channel_bar_set_name (GVC_CHANNEL_BAR (bar), escaped);
+                g_free (escaped);
+        }
+
+        return bar;
+}
+
+/* active_input_update
+ * Handle input update change from the backend (control). 
+ * Trust the backend whole-heartedly to deliver the correct input
+ * i.e. keep it MVC.
+ */
+static void
+active_input_update (GvcMixerDialog *dialog,
+                     GvcMixerUIDevice *active_input)
+{         
+        g_print ("\n active_input_update %s \n", gvc_mixer_ui_device_get_description (active_input));
+        // First make sure the correct UI device is selected.
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        gtk_tree_model_get_iter_first (model, &iter);
+        
+        do {
+                gboolean         is_selected = FALSE;
+                gint             id;
+                        
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &id,
+                                    -1);
+
+                is_selected = id == gvc_mixer_ui_device_get_id (active_input);
+                
+                gtk_list_store_set (GTK_LIST_STORE (model),
+                                    &iter,
+                                    ACTIVE_COLUMN, is_selected,
+                                    -1);
+
+                if (is_selected) {
+                        GtkTreeSelection *selection;
+                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->priv->input_treeview));
+                        gtk_tree_selection_select_iter (selection, &iter);
+                }
+                
+        }while (gtk_tree_model_iter_next (model, &iter));
+
+        stop_monitor_stream_for_source (dialog);
+
+
+        GvcMixerStream       *stream;  
+        const GvcChannelMap  *map;
+        GtkAdjustment        *adj;
+  
+        stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, 
+                                                           active_input); 
+
+        if (stream == NULL) {
+                g_warning ("active_input_update - couldn't find a stream from the supposed active input");
+                gtk_widget_set_sensitive (dialog->priv->input_bar, 
+                                          FALSE);                
+                return;
+        }
+        // Set the label accordingly
+        gtk_label_set_label (GTK_LABEL(dialog->priv->selected_input_label),
+                             g_strdup_printf("Settings for %s",
+                                             gvc_mixer_ui_device_get_description (active_input)));  
+
+        gvc_channel_bar_set_base_volume (GVC_CHANNEL_BAR (dialog->priv->input_bar),
+                                         gvc_mixer_stream_get_base_volume (stream));
+        gvc_channel_bar_set_is_amplified (GVC_CHANNEL_BAR (dialog->priv->input_bar),
+                                          gvc_mixer_stream_get_can_decibel (stream));
+        /* Update the adjustment in case the previous bar wasn't decibel
+         * capable, and we clipped it */
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->input_bar)));
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (stream));        
+        
+        create_monitor_stream_for_source (dialog, stream);
+        // remove any previous stream that might have been pointed at 
+        // the static input bar and connect new signals from new stream.
+        bar_set_stream (dialog, dialog->priv->input_bar, stream);        
+}
+
+/* active_output_update
+ * Handle output update change from the backend (control). 
+ * Trust the backend whole heartedly to deliver the correct output
+ * i.e. keep it MVC.
+ */
+static void
+active_output_update (GvcMixerDialog *dialog,
+                      GvcMixerUIDevice *active_output)
+{                 
+        // First make sure the correct UI device is selected.
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        g_print ("\n\n active output update - device id = %i \n\n",
+                 gvc_mixer_ui_device_get_id (active_output));
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        gtk_tree_model_get_iter_first (model, &iter);
+        
+        do {
+                gboolean         is_selected;
+                gint             id;
+                        
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &id,
+                                    ACTIVE_COLUMN, &is_selected,                  
+                                    -1);
+
+                if (is_selected && id == gvc_mixer_ui_device_get_id (active_output)) {
+                        g_print ("\n\n unneccessary active output update unless it was a profile change on the same device ? \n\n");
+                }
+
+                is_selected = id == gvc_mixer_ui_device_get_id (active_output);
+                
+                gtk_list_store_set (GTK_LIST_STORE (model),
+                                    &iter,
+                                    ACTIVE_COLUMN, is_selected,
+                                    -1);
+
+                if (is_selected) {
+                        GtkTreeSelection *selection;
+                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->priv->output_treeview));
+                        gtk_tree_selection_select_iter (selection, &iter);
+                }
+                
+        }while (gtk_tree_model_iter_next (model, &iter));
+        
+          // Not ideal but for now destroy the combo and recreate below.
+        if (dialog->priv->output_port_combo != NULL) {
+                gtk_container_remove (GTK_CONTAINER (dialog->priv->output_settings_box),
+                                      dialog->priv->output_port_combo);
+                dialog->priv->output_port_combo = NULL;
+        }
+
+        GvcMixerStream       *stream;  
+        const GvcChannelMap *map;
+        GtkAdjustment        *adj;
+  
+        stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, 
+                                                           active_output); 
+
+        if (stream == NULL) {
+                g_warning ("active_output_update - couldn't find a stream from the supposed active output");
+                return;
+        }
+
+        gboolean is_muted = gvc_mixer_stream_get_is_muted (stream);
+        gtk_widget_set_sensitive (dialog->priv->applications_box,
+                                  !is_muted);
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->output_bar)));
+        g_signal_handlers_disconnect_by_func(adj, on_adjustment_value_changed, dialog);
+
+        bar_set_stream (dialog, dialog->priv->output_bar, stream);
+        gvc_channel_bar_set_base_volume (GVC_CHANNEL_BAR (dialog->priv->output_bar),
+                                         gvc_mixer_stream_get_base_volume (stream));
+        gvc_channel_bar_set_is_amplified (GVC_CHANNEL_BAR (dialog->priv->output_bar),
+                                          gvc_mixer_stream_get_can_decibel (stream));
+        /* Update the adjustment in case the previous bar wasn't decibel
+         * capable, and we clipped it */
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (dialog->priv->output_bar)));
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (stream));
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        if (map == NULL) {
+                g_warning ("Active output stream has no channel map");
+                gtk_widget_set_sensitive (dialog->priv->output_bar, FALSE);
+                gtk_widget_set_sensitive (dialog->priv->output_balance_bar, FALSE);
+                gtk_widget_set_sensitive (dialog->priv->output_lfe_bar, FALSE);
+                gtk_widget_set_sensitive (dialog->priv->output_fade_bar, FALSE);                
+                return;
+        }
+
+
+        // Swap bars to the active map
+        gvc_balance_bar_set_map (GVC_BALANCE_BAR (dialog->priv->output_balance_bar), 
+                                 map);  
+        gvc_balance_bar_set_map (GVC_BALANCE_BAR (dialog->priv->output_fade_bar), 
+                                 map);
+        gvc_balance_bar_set_map (GVC_BALANCE_BAR (dialog->priv->output_lfe_bar), 
+                                 map);
+                           
+        // Set sensitivities accordingly.
+        gtk_widget_set_sensitive (dialog->priv->output_balance_bar,
+                                  gvc_channel_map_can_balance (map));                                    
+        gtk_widget_set_sensitive (dialog->priv->output_fade_bar, 
+                                  gvc_channel_map_can_fade (map));
+        gtk_widget_set_sensitive (dialog->priv->output_lfe_bar, 
+                                  gvc_channel_map_has_lfe (map));
+        gtk_widget_set_sensitive (dialog->priv->output_bar, 
+                                  TRUE);
+        // Set the label accordingly
+	gtk_label_set_label (GTK_LABEL(dialog->priv->selected_output_label),
+			     g_strdup_printf("Settings for %s",
+                                             gvc_mixer_ui_device_get_description (active_output)));  
+        g_print ("\n active_output_update %s \n", gvc_mixer_ui_device_get_description (active_output));
+
+        GList* profiles;
+        profiles = gvc_mixer_ui_device_get_profiles (active_output);
+
+        if (profiles != NULL) {
+                dialog->priv->output_port_combo = gvc_combo_box_new (_("Mode:"));                
+                gvc_combo_box_set_profiles (GVC_COMBO_BOX (dialog->priv->output_port_combo),
+                                            profiles);
+                                
+                gboolean disabled;
+                disabled = gvc_mixer_ui_device_determine_profile_sensitivity (active_output);
+
+                if (disabled){
+                        GList *profs;
+                        GvcMixerCardProfile *p;
+                        profs = gvc_mixer_ui_device_get_profiles (active_output);
+                        // We can be sure that its just one profile in the list when it's disabled
+                        p = g_list_last (profs)->data;
+                        gvc_combo_box_set_active (GVC_COMBO_BOX (dialog->priv->output_port_combo), 
+                                                                 p->profile);                        
+                }
+                else{
+                        gvc_combo_box_set_active (GVC_COMBO_BOX (dialog->priv->output_port_combo), 
+                                                  gvc_mixer_control_get_active_profile_from_ui_device (dialog->priv->mixer_control,
+                                                                                               active_output));
+                }
+                g_object_set_data (G_OBJECT (dialog->priv->output_port_combo),
+                                   "uidevice",
+                                   active_output);
+                g_signal_connect (G_OBJECT (dialog->priv->output_port_combo), "changed",
+                                  G_CALLBACK (profile_selection_changed), dialog);
+
+                gtk_box_pack_start (GTK_BOX (dialog->priv->output_settings_box),
+                                    dialog->priv->output_port_combo,
+                                    TRUE, FALSE, 6);
+
+                if (dialog->priv->size_group != NULL) {
+                        gvc_combo_box_set_size_group (GVC_COMBO_BOX (dialog->priv->output_port_combo),
+                                                      dialog->priv->size_group, FALSE);
+                }
+                gtk_widget_show (dialog->priv->output_port_combo);                
+                gtk_widget_set_sensitive (dialog->priv->output_port_combo, 
+                                           !disabled);
+        }
+
+}
+
+static void
+bar_set_stream (GvcMixerDialog *dialog,
+                GtkWidget      *bar,
+                GvcMixerStream *stream)
+{
+        GtkAdjustment  *adj;
+        GvcMixerStream *old_stream;
+
+        g_assert (bar != NULL);
+
+        /*
+        old_stream = g_object_get_data (G_OBJECT (bar), "gvc-mixer-dialog-stream");
+
+        if (old_stream != NULL) {
+                char *name;
+
+                /*g_object_get (bar, "name", &name, NULL);
+                g_print ("Disconnecting old stream '%s' from bar '%s'",
+                         gvc_mixer_stream_get_name (old_stream), name);
+                g_free (name);
+
+                g_signal_handlers_disconnect_by_func (old_stream, on_stream_is_muted_notify, dialog);
+                g_signal_handlers_disconnect_by_func (old_stream, on_stream_volume_notify, dialog);
+                
+        }
+        */
+
+        gtk_widget_set_sensitive (bar, (stream != NULL));
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (bar)));
+
+        g_signal_handlers_disconnect_by_func (adj, on_adjustment_value_changed, dialog);
+
+        g_object_set_data (G_OBJECT (bar), "gvc-mixer-dialog-stream", stream);
+        g_object_set_data (G_OBJECT (adj), "gvc-mixer-dialog-stream", stream);
+        g_object_set_data (G_OBJECT (adj), "gvc-mixer-dialog-bar", bar);
+
+        if (stream != NULL) {
+                gboolean is_muted;
+
+                is_muted = gvc_mixer_stream_get_is_muted (stream);
+                gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (bar), is_muted);
+
+                gtk_adjustment_set_value (adj,
+                                          gvc_mixer_stream_get_volume (stream));
+                g_signal_connect (stream,
+                                  "notify::is-muted",
+                                  G_CALLBACK (on_stream_is_muted_notify),
+                                  dialog);
+                g_signal_connect (stream,
+                                  "notify::volume",
+                                  G_CALLBACK (on_stream_volume_notify),
+                                  dialog);
+                g_signal_connect (adj,
+                                  "value-changed",
+                                  G_CALLBACK (on_adjustment_value_changed),
+                                  dialog);
+        }
+}
+
+/**
+* This method handles all streams that are not an input or output
+* i.e. effects streams and application streams
+* TODO rename to truly reflect its usage. 
+**/
+static void
+add_stream (GvcMixerDialog *dialog,
+            GvcMixerStream *stream)
+{
+  
+        GtkWidget     *bar;
+        bar = NULL;
+
+        if (stream == gvc_mixer_control_get_event_sink_input (dialog->priv->mixer_control)) {
+                bar = dialog->priv->effects_bar;
+                g_debug ("Adding effects stream");
+        } else {
+                // Must be a sink/source input/output
+                const char *name;
+                name = gvc_mixer_stream_get_name (stream);
+                g_print ("\n Add bar for application stream : %s",
+                             name);
+
+                bar = create_app_bar (dialog, name,
+                                      gvc_mixer_stream_get_icon_name (stream));
+
+                gtk_box_pack_start (GTK_BOX (dialog->priv->applications_box), bar, FALSE, FALSE, 12);
+                dialog->priv->num_apps++;
+                gtk_widget_hide (dialog->priv->no_apps_label);
+        }
+        // We should have a bar by now.
+        g_assert (bar != NULL);
+        GvcMixerStream *old_stream;
+
+        if (bar != NULL) {
+                old_stream = g_object_get_data (G_OBJECT (bar), "gvc-mixer-dialog-stream");
+                if (old_stream != NULL) {
+                        char *name;
+                        g_object_get (bar, "name", &name, NULL);
+                        g_debug ("Disconnecting old stream '%s' from bar '%s'",
+                                 gvc_mixer_stream_get_name (old_stream), name);
+                        g_free (name);
+
+                        g_signal_handlers_disconnect_by_func (old_stream, on_stream_is_muted_notify, dialog);
+                        g_signal_handlers_disconnect_by_func (old_stream, on_stream_volume_notify, dialog);
+                        g_hash_table_remove (dialog->priv->bars, GUINT_TO_POINTER (gvc_mixer_stream_get_id (old_stream)));
+                }
+                save_bar_for_stream (dialog, stream, bar);
+                bar_set_stream (dialog, bar, stream);
+                gtk_widget_show (bar);
+        }
+}
+
+static void
+remove_stream (GvcMixerDialog  *dialog,
+               guint            id)
+{        
+        GtkWidget *bar;
+        bar = g_hash_table_lookup (dialog->priv->bars, GUINT_TO_POINTER (id));
+        if (bar != NULL) {
+                g_hash_table_remove (dialog->priv->bars, GUINT_TO_POINTER (id));
+                gtk_container_remove (GTK_CONTAINER (gtk_widget_get_parent (bar)),
+                                      bar);
+                dialog->priv->num_apps--;
+                if (dialog->priv->num_apps == 0) {
+                        gtk_widget_show (dialog->priv->no_apps_label);
+                }
+        }
+
+}
+
+static void
+on_control_stream_added (GvcMixerControl *control,
+                         guint            id,
+                         GvcMixerDialog  *dialog)
+{
+        GvcMixerStream *stream;
+        stream = gvc_mixer_control_lookup_stream_id (control, id);
+        
+        if (stream == NULL) 
+                return;
+        
+        const char    *app_id;
+        app_id = gvc_mixer_stream_get_application_id (stream);
+
+        if (stream == gvc_mixer_control_get_event_sink_input (dialog->priv->mixer_control) || (!GVC_IS_MIXER_SOURCE (stream) &&
+                !GVC_IS_MIXER_SINK (stream)
+                && !gvc_mixer_stream_is_virtual (stream)
+                && g_strcmp0 (app_id, "org.gnome.VolumeControl") != 0
+                && g_strcmp0 (app_id, "org.PulseAudio.pavucontrol") != 0)) {
+
+                GtkWidget      *bar;
+
+                bar = g_hash_table_lookup (dialog->priv->bars, GUINT_TO_POINTER (id));
+                if (bar != NULL) {
+                        g_debug ("GvcMixerDialog: Stream %u already added", id);
+                        return;
+                }
+                add_stream (dialog, stream);
+        } 
+}
+
+static void
+on_control_stream_removed (GvcMixerControl *control,
+                           guint            id,
+                           GvcMixerDialog  *dialog)
+{
+        remove_stream (dialog, id);
+}
+
+static gboolean
+find_item_by_id (GtkTreeModel *model,
+                 guint         id,
+                 guint         column,
+                 GtkTreeIter  *iter)
+{
+        gboolean found_item;
+
+        found_item = FALSE;
+
+        if (!gtk_tree_model_get_iter_first (model, iter)) {
+                return FALSE;
+        }
+
+        do {
+                guint t_id;
+
+                gtk_tree_model_get (model, iter,
+                                    column, &t_id, -1);
+
+                if (id == t_id) {
+                        found_item = TRUE;
+                }
+        } while (!found_item && gtk_tree_model_iter_next (model, iter));
+
+        return found_item;
+}
+
+static void
+add_input_ui_entry (GvcMixerDialog *dialog,
+                    GvcMixerUIDevice *input)
+{
+        g_print ("\n Add input ui entry with id : %u \n",
+                  gvc_mixer_ui_device_get_id (input));
+
+        gchar    *port_name;
+        gchar    *origin;
+        gchar    *description;
+        gboolean active;
+        gboolean available;
+        gint     card_id;
+        gint     stream_id;
+
+        g_object_get (G_OBJECT (input),
+                     "stream-id", &stream_id,
+                     "card-id", &card_id,
+                     "origin", &origin,
+                     "description", &description,
+                     "port-name", &port_name,
+                     "port-available", &available,
+                      NULL);
+        
+        GtkTreeModel        *model;
+        GtkTreeIter          iter;
+        const GvcChannelMap *map;
+        GIcon               *icon;
+
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID) {
+                GvcMixerStream *stream;
+                g_print ("just detected a network source");
+                stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, input);
+                if (stream == NULL) {
+                        g_warning ("tried to add the network source but the stream was null - fail ?!");
+                        g_free (port_name);					
+                        g_free (origin);							
+                        g_free (description);		  				
+                        return;
+                }
+                icon = gvc_mixer_stream_get_gicon (stream);			
+        }
+        else{
+                GvcMixerCard        *card;
+                card = gvc_mixer_control_lookup_card_id (dialog->priv->mixer_control, card_id);
+                icon = gvc_mixer_card_get_gicon (card);                 
+        }
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+
+        gtk_list_store_set (GTK_LIST_STORE (model),
+                            &iter,
+                            NAME_COLUMN, description,
+                            DEVICE_COLUMN, origin,
+                            ACTIVE_COLUMN, FALSE,
+                            ICON_COLUMN, icon,
+                            ID_COLUMN, gvc_mixer_ui_device_get_id (input),
+                            SPEAKERS_COLUMN,origin,
+                            -1);
+
+        if (icon != NULL)
+                g_object_unref (icon);
+
+        // TODO check this.
+        /*g_signal_connect (output,
+                          "notify::description",
+                          G_CALLBACK (on_output_description_notify),
+                          dialog);*/
+              
+        g_free (port_name);                                        
+        g_free (origin);                                                        
+        g_free (description);                   
+}                                   
+
+static void
+add_output_ui_entry (GvcMixerDialog *dialog,
+                     GvcMixerUIDevice *output)
+{
+        g_print ("\n Add output ui entry with id : %u \n",
+                  gvc_mixer_ui_device_get_id (output));
+
+        gchar    *sink_port_name;
+        gchar    *origin;
+        gchar    *description;
+        gboolean active;
+        gboolean available;
+        gint     card_id;
+        gint     sink_stream_id;
+
+        g_object_get (G_OBJECT (output),
+                     "stream-id", &sink_stream_id,
+                     "card-id", &card_id,
+                     "origin", &origin,
+                     "description", &description,
+                     "port-name", &sink_port_name,
+                     "port-available", &available,
+                      NULL);
+	
+        GtkTreeModel        *model;
+        GtkTreeIter          iter;
+        const GvcChannelMap *map;
+        GIcon               *icon;
+
+        if (card_id == GVC_MIXER_UI_DEVICE_INVALID) {
+                g_print ("just detected a network sink");
+                
+                GvcMixerStream *stream;
+                stream = gvc_mixer_control_get_stream_from_device (dialog->priv->mixer_control, output);
+                if (stream == NULL) {
+                        g_warning ("tried to add the network sink but the stream was null - fail ?!");
+                        g_free (sink_port_name);					
+                        g_free (origin);							
+                        g_free (description);		  				
+                        return;
+                }
+                icon = gvc_mixer_stream_get_gicon (stream);			
+        }
+        else{
+                GvcMixerCard	    *card;
+                card = gvc_mixer_control_lookup_card_id (dialog->priv->mixer_control, card_id);
+                icon = gvc_mixer_card_get_gicon (card);			
+        }
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+
+        gtk_list_store_set (GTK_LIST_STORE (model),
+                            &iter,
+                            NAME_COLUMN, description,
+                            DEVICE_COLUMN, origin,
+                            ACTIVE_COLUMN, FALSE,
+                            ICON_COLUMN, icon,
+                            ID_COLUMN, gvc_mixer_ui_device_get_id (output),
+                            SPEAKERS_COLUMN,origin,
+                            -1);
+
+        if (icon != NULL)
+                g_object_unref (icon);
+
+        // TODO check this.
+        /*g_signal_connect (output,
+                          "notify::description",
+                          G_CALLBACK (on_output_description_notify),
+                          dialog);*/
+              
+        g_free (sink_port_name);					
+        g_free (origin);							
+        g_free (description);		  	
+}				    
+
+static void
+on_control_output_added (GvcMixerControl *control,
+                         guint            id,
+                         GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* out = NULL;
+	out = gvc_mixer_control_lookup_output_id (control, id);
+
+	if (out == NULL) {
+		g_warning ("on_control_output_added - tried to fetch an output of id %u but got nothing", id);
+		return;
+	}
+
+	add_output_ui_entry (dialog, out);
+}
+
+static void
+on_control_active_output_update (GvcMixerControl *control,
+                                 guint            id,
+                                 GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* out = NULL;
+	out = gvc_mixer_control_lookup_output_id (control, id);
+
+	if (out == NULL) {
+		g_warning ("\n on_control_active_output_update - tried to fetch an output of id %u but got nothing", id);
+		return;
+	}
+        active_output_update (dialog, out);
+}
+
+static void
+on_control_active_input_update (GvcMixerControl *control,
+                                 guint            id,
+                                 GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* in = NULL;
+	in = gvc_mixer_control_lookup_input_id (control, id);
+
+	if (in == NULL) {
+		g_warning ("on_control_active_input_update - tried to fetch an input of id %u but got nothing", id);
+		return;
+	}
+        active_input_update (dialog, in);
+}
+
+static void
+on_control_input_added (GvcMixerControl *control,
+                        guint            id,
+                        GvcMixerDialog  *dialog)
+{
+	GvcMixerUIDevice* in = NULL;
+	in = gvc_mixer_control_lookup_input_id (control, id);
+
+	if (in == NULL) {
+		g_warning ("on_control_input_added - tried to fetch an input of id %u but got nothing", id);
+		return;
+	}
+	add_input_ui_entry (dialog, in);
+}
+
+static void
+on_control_output_removed (GvcMixerControl *control,
+                           guint	    id,
+                           GvcMixerDialog  *dialog)
+{
+        GtkWidget    *bar;
+        gboolean      found;
+        GtkTreeIter   iter;
+        GtkTreeModel *model;
+
+        GvcMixerUIDevice* out = NULL;
+        out = gvc_mixer_control_lookup_output_id (control, id);
+        
+        gint sink_stream_id;
+        
+        g_object_get (G_OBJECT (out),
+                     "stream-id", &sink_stream_id,
+                      NULL);
+		      
+        g_print ("Remove output from dialog \n id : %u \n sink stream id : %i \n",
+                  id,
+                  sink_stream_id);
+
+        /* remove from any models */
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        found = find_item_by_id (GTK_TREE_MODEL (model), id, ID_COLUMN, &iter);
+        if (found) {
+                gtk_list_store_remove (GTK_LIST_STORE (model), &iter);
+        }
+}     
+
+
+                 
+static void
+on_control_input_removed (GvcMixerControl *control,
+			   guint	    id,
+			   GvcMixerDialog  *dialog)
+{
+        GtkWidget    *bar;
+        gboolean      found;
+        GtkTreeIter   iter;
+        GtkTreeModel *model;
+
+        GvcMixerUIDevice* in = NULL;
+        in = gvc_mixer_control_lookup_input_id (control, id);
+        
+        gint stream_id;
+        
+        g_object_get (G_OBJECT (in),
+                     "stream-id", &stream_id,
+                      NULL);
+                      
+        g_print ("Remove input from dialog \n id : %u \n stream id : %i \n",
+                  id,
+                  stream_id);
+
+        /* remove from any models */
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->input_treeview));
+        found = find_item_by_id (GTK_TREE_MODEL (model), id, ID_COLUMN, &iter);
+        if (found) {
+                gtk_list_store_remove (GTK_LIST_STORE (model), &iter);
+        }        
+}
+
+static void
+_gtk_label_make_bold (GtkLabel *label)
+{
+        PangoFontDescription *font_desc;
+
+        font_desc = pango_font_description_new ();
+
+        pango_font_description_set_weight (font_desc,
+                                           PANGO_WEIGHT_BOLD);
+
+        /* This will only affect the weight of the font, the rest is
+         * from the current state of the widget, which comes from the
+         * theme or user prefs, since the font desc only has the
+         * weight flag turned on.
+         */
+        gtk_widget_modify_font (GTK_WIDGET (label), font_desc);
+
+        pango_font_description_free (font_desc);
+}
+
+
+static void
+on_input_selection_changed (GtkTreeSelection *selection,
+                             GvcMixerDialog   *dialog)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        gboolean      toggled;
+        guint         id;
+
+        if (gtk_tree_selection_get_selected (selection, &model, &iter) == FALSE) {
+                g_debug ("Could not get default input from selection");
+                return;
+        }
+
+        gtk_tree_model_get (model, &iter,
+                            ID_COLUMN, &id,
+                            ACTIVE_COLUMN, &toggled,
+                            -1);
+
+        toggled ^= 1;
+        GvcMixerUIDevice *input;
+        //g_print ("on_input_selection_changed - try swap to input with id %u", id); 
+        input = gvc_mixer_control_lookup_input_id (dialog->priv->mixer_control, id);
+        
+        if (input == NULL) {
+                g_warning ("on_input_selection_changed - Unable to find input with id: %u", id);
+                return;
+        }
+
+        gvc_mixer_control_change_input (dialog->priv->mixer_control, input);
+
+        /*if (toggled) {
+                GvcMixerStream *stream;
+
+                g_debug ("Default input selected: %u", id);
+                stream = gvc_mixer_control_lookup_stream_id (dialog->priv->mixer_control, id);
+                if (stream == NULL) {
+                        g_warning ("Unable to find stream for id: %u", id);
+                        return;
+                }
+
+                gvc_mixer_control_set_default_source (dialog->priv->mixer_control, stream);
+        }*/
+}
+
+static void
+on_output_selection_changed (GtkTreeSelection *selection,
+                             GvcMixerDialog   *dialog)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        gboolean      active;
+        guint         id;
+
+        if (gtk_tree_selection_get_selected (selection, &model, &iter) == FALSE) {
+                g_debug ("Could not get default output from selection");
+                return;
+        }
+
+        gtk_tree_model_get (model, &iter,
+                            ID_COLUMN, &id,
+                            ACTIVE_COLUMN, &active,
+                            -1);
+        
+        g_print ("\n\n on_output_selection_changed - active %i \n\n", active); 
+        if (active){
+                return;
+        }
+
+        GvcMixerUIDevice *output;
+        g_print ("\n on_output_selection_changed - try swap to output with id %u", id); 
+	output = gvc_mixer_control_lookup_output_id (dialog->priv->mixer_control, id);
+        
+	if (output == NULL) {
+		g_warning ("on_output_selection_changed - Unable to find output with id: %u", id);
+		return;
+	}
+
+        gvc_mixer_control_change_output (dialog->priv->mixer_control, output);
+}
+
+static void
+name_to_text (GtkTreeViewColumn *column,
+              GtkCellRenderer *cell,
+              GtkTreeModel *model,
+              GtkTreeIter *iter,
+              gpointer user_data)
+{
+        char *name, *mapping;
+
+        gtk_tree_model_get(model, iter,
+                           NAME_COLUMN, &name,
+                           SPEAKERS_COLUMN, &mapping,
+                           -1);
+
+        if (mapping == NULL) {
+                g_object_set (cell, "text", name, NULL);
+        } else {
+                char *str;
+
+                str = g_strdup_printf ("%s\n<i>%s</i>",
+                                       name, mapping);
+                g_object_set (cell, "markup", str, NULL);
+                g_free (str);
+        }
+
+        g_free (name);
+        g_free (mapping);
+}
+
+static GtkWidget *
+create_stream_treeview (GvcMixerDialog *dialog,
+                        GCallback       on_selection_changed)
+{
+        GtkWidget         *treeview;
+        GtkListStore      *store;
+        GtkCellRenderer   *renderer;
+        GtkTreeViewColumn *column;
+        GtkTreeSelection  *selection;
+
+        treeview = gtk_tree_view_new ();
+        gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview), FALSE);
+
+        store = gtk_list_store_new (NUM_COLUMNS,
+                                    G_TYPE_STRING,
+                                    G_TYPE_STRING,
+                                    G_TYPE_BOOLEAN,
+                                    G_TYPE_UINT,
+                                    G_TYPE_STRING,
+                                    G_TYPE_ICON);
+        gtk_tree_view_set_model (GTK_TREE_VIEW (treeview),
+                                 GTK_TREE_MODEL (store));
+
+        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));
+        gtk_tree_selection_set_mode (selection, GTK_SELECTION_BROWSE);
+
+        column = gtk_tree_view_column_new ();
+        gtk_tree_view_column_set_title (column, _("Name"));
+        renderer = gtk_cell_renderer_pixbuf_new ();
+        gtk_tree_view_column_pack_start (column, renderer, FALSE);
+        g_object_set (G_OBJECT (renderer), "stock-size", GTK_ICON_SIZE_LARGE_TOOLBAR, NULL);
+        gtk_tree_view_column_set_attributes (column, renderer,
+                                             "gicon", ICON_COLUMN,
+                                             NULL);
+
+        renderer = gtk_cell_renderer_text_new ();
+        gtk_tree_view_column_pack_start (column, renderer, TRUE);
+        gtk_tree_view_column_set_cell_data_func (column, renderer,
+                                                 name_to_text, NULL, NULL);
+        gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
+
+        g_signal_connect ( selection, "changed",
+                          on_selection_changed, dialog);
+#if 0
+        renderer = gtk_cell_renderer_text_new ();
+        column = gtk_tree_view_column_new_with_attributes (_("Device"),
+                                                           renderer,
+                                                           "text", DEVICE_COLUMN,
+                                                           NULL);
+        gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
+#endif
+        return treeview;
+}
+
+static void
+on_profile_changed (GvcComboBox *widget,
+                    const char  *profile,
+                    gpointer     user_data)
+{
+        GvcMixerCard        *card;
+
+        card = g_object_get_data (G_OBJECT (widget), "card");
+        if (card == NULL) {
+                g_warning ("Could not find card for combobox");
+                return;
+        }
+
+        g_debug ("Profile changed to %s for card %s", profile,
+                 gvc_mixer_card_get_name (card));
+
+        gvc_mixer_card_change_profile (card, profile);
+}
+
+static void
+on_test_speakers_clicked (GtkButton *widget,
+                          gpointer  user_data)
+{
+        GvcMixerDialog      *dialog = GVC_MIXER_DIALOG (user_data);
+        GtkTreeModel        *model;
+        GtkTreeIter         iter;
+        gint                active_output = GVC_MIXER_UI_DEVICE_INVALID;
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->priv->output_treeview));
+        gtk_tree_model_get_iter_first (model, &iter);
+        
+        // Fetch the active output from the treeview (hmmm...)         
+        
+        do {
+                gboolean         is_selected = FALSE ;
+                gint             id;
+                        
+                gtk_tree_model_get (model, &iter,
+                                    ID_COLUMN, &id,
+                                    ACTIVE_COLUMN, &is_selected,
+                                    -1);
+                
+                if (is_selected) {
+                        active_output = id;
+                        break;
+                }
+                
+        }while (gtk_tree_model_iter_next (model, &iter));
+        
+        if (active_output == GVC_MIXER_UI_DEVICE_INVALID) {
+                g_warning ("Cant find the active output from the UI");
+                return;
+        }        
+
+        GvcMixerUIDevice *output;
+        output = gvc_mixer_control_lookup_output_id (dialog->priv->mixer_control, (guint)active_output);
+        gint stream_id = gvc_mixer_ui_device_get_stream_id(output);
+
+        if (stream_id == GVC_MIXER_UI_DEVICE_INVALID)
+                return;
+
+        g_print ("Test the speakers on the %s", gvc_mixer_ui_device_get_description (output));
+        
+        GvcMixerStream        *stream;
+        GvcMixerCardProfile *profile;
+        GtkWidget           *d, *speaker_test, *container;
+        char                *title;
+
+        stream = gvc_mixer_control_lookup_stream_id (dialog->priv->mixer_control, stream_id);
+        if (stream == NULL) {
+                g_print ("Stream/sink not found");
+                return;
+        }
+/*        card = gvc_mixer_control_lookup_card_id (dialog->priv->mixer_control, card_id);
+
+        profile = gvc_mixer_card_get_profile (card);
+
+        g_debug ("XXX Start speaker testing for profile '%s', card %s XXX",
+                 profile->profile, gvc_mixer_card_get_name (card));
+*/
+        title = g_strdup_printf (_("Speaker Testing for %s"), gvc_mixer_ui_device_get_description (output));
+        d = gtk_dialog_new_with_buttons (title,
+                                         GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (widget))),
+                                         GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
+                                         GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,
+                                         NULL);
+        gtk_window_set_has_resize_grip (GTK_WINDOW (d), FALSE);
+
+        g_free (title);
+        speaker_test = gvc_speaker_test_new (dialog->priv->mixer_control,
+                                             stream);
+        gtk_widget_show (speaker_test);
+        container = gtk_dialog_get_content_area (GTK_DIALOG (d));
+        gtk_container_add (GTK_CONTAINER (container), speaker_test);
+
+        gtk_dialog_run (GTK_DIALOG (d));
+        gtk_widget_destroy (d);
+}
+
+static GObject *
+gvc_mixer_dialog_constructor (GType                  type,
+                              guint                  n_construct_properties,
+                              GObjectConstructParam *construct_params)
+{
+        GObject          *object;
+        GvcMixerDialog   *self;
+        GtkWidget        *w;
+        GtkWidget        *main_vbox;
+        GtkWidget        *label;
+        GtkWidget        *alignment;
+        GtkWidget        *box;
+        GtkWidget        *sbox;
+        GtkWidget        *ebox;
+        GtkWidget        *test_sound_box;
+        GSList           *streams;
+        GSList           *cards;
+        GSList           *l;
+        GvcMixerStream   *stream;
+        GvcMixerCard     *card;
+        GtkTreeSelection *selection;
+
+        object = G_OBJECT_CLASS (gvc_mixer_dialog_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_DIALOG (object);
+
+        main_vbox = GTK_WIDGET (self);
+        gtk_box_set_spacing (GTK_BOX (main_vbox), 2);
+
+        gtk_container_set_border_width (GTK_CONTAINER (self), 6);
+
+        self->priv->output_stream_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 12, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (alignment), self->priv->output_stream_box);
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            alignment,
+                            FALSE, FALSE, 0);
+
+        self->priv->notebook = gtk_notebook_new ();
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            self->priv->notebook,
+                            TRUE, TRUE, 0);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->notebook), 5);
+
+        /* Effects page */
+        self->priv->sound_effects_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->sound_effects_box), 12);
+        label = gtk_label_new (_("Sound Effects"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->sound_effects_box,
+                                  label);
+
+        self->priv->effects_bar = create_bar (self, FALSE, TRUE);
+        gvc_channel_bar_set_name (GVC_CHANNEL_BAR (self->priv->effects_bar),
+                                  _("_Alert volume:"));
+        gtk_widget_set_sensitive (self->priv->effects_bar, FALSE);
+        gtk_box_pack_start (GTK_BOX (self->priv->sound_effects_box),
+                            self->priv->effects_bar, FALSE, FALSE, 0);
+
+        self->priv->sound_theme_chooser = gvc_sound_theme_chooser_new ();
+        gtk_box_pack_start (GTK_BOX (self->priv->sound_effects_box),
+                            self->priv->sound_theme_chooser,
+                            TRUE, TRUE, 6);
+
+        /* Input page */
+        self->priv->input_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->input_box), 12);
+        label = gtk_label_new (_("Input"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->input_box,
+                                  label);
+        box = gtk_frame_new (_("Record sound from:"));
+        gtk_widget_set_size_request (GTK_WIDGET (box), 325, -1);        
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        _gtk_label_make_bold (GTK_LABEL (label));
+        gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_box), box, FALSE, TRUE, 0);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_container_add (GTK_CONTAINER (box), alignment);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 6, 0, 0, 0);
+
+        self->priv->input_treeview = create_stream_treeview (self,
+                                                             G_CALLBACK (on_input_selection_changed));
+        gtk_label_set_mnemonic_widget (GTK_LABEL (label), self->priv->input_treeview);
+
+        box = gtk_scrolled_window_new (NULL, NULL);
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (box),
+                                        GTK_POLICY_NEVER,
+                                        GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (box),
+                                             GTK_SHADOW_IN);
+        gtk_container_add (GTK_CONTAINER (box), self->priv->input_treeview);
+        gtk_container_add (GTK_CONTAINER (alignment), box);
+
+        self->priv->selected_input_label = gtk_label_new (_("Settings for the selected device:"));
+        box = gtk_frame_new ("");
+        gtk_frame_set_label_widget (GTK_FRAME (box), self->priv->selected_input_label);
+
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        _gtk_label_make_bold (GTK_LABEL (label));
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_box), box, FALSE, FALSE, 0);
+        self->priv->input_settings_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+
+        self->priv->input_bar = create_bar (self, FALSE, TRUE);
+        gvc_channel_bar_set_name (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                  _("_Input volume:"));
+        gvc_channel_bar_set_low_icon_name (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                           "audio-input-microphone-low-symbolic");
+        gvc_channel_bar_set_high_icon_name (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                            "audio-input-microphone-high-symbolic");
+        gtk_widget_set_sensitive (self->priv->input_bar, FALSE);
+
+        if (self->priv->size_group != NULL) {
+                gvc_channel_bar_set_size_group (GVC_CHANNEL_BAR (self->priv->input_bar),
+                                                self->priv->size_group,
+                                                FALSE);                
+        }
+
+        gtk_box_pack_start (GTK_BOX (self->priv->input_settings_box),
+                            self->priv->input_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->input_bar);
+        
+        gtk_container_add (GTK_CONTAINER (box), self->priv->input_settings_box);
+        
+        
+
+        /* Creating a box and try to deal using the same size group. */
+        GtkWidget *input_level_box;
+        input_level_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_start (GTK_BOX (self->priv->input_settings_box),
+                            input_level_box,
+                            FALSE,
+                            FALSE,
+                            5);
+
+        sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_start (GTK_BOX (input_level_box),
+                            sbox,
+                            FALSE, FALSE, 0);
+        
+        label = gtk_label_new (_("Input level:"));
+        gtk_box_pack_start (GTK_BOX (sbox),
+                            label,
+                            FALSE, FALSE, 0);
+        if (self->priv->size_group != NULL)
+                gtk_size_group_add_widget (self->priv->size_group, sbox);
+
+
+        self->priv->input_level_bar = gvc_level_bar_new ();
+        gvc_level_bar_set_orientation (GVC_LEVEL_BAR (self->priv->input_level_bar),
+                                       GTK_ORIENTATION_HORIZONTAL);
+        gvc_level_bar_set_scale (GVC_LEVEL_BAR (self->priv->input_level_bar),
+                                 GVC_LEVEL_SCALE_LINEAR);
+
+        gtk_box_pack_start (GTK_BOX (input_level_box),
+                            self->priv->input_level_bar,
+                            TRUE, TRUE, 10);
+
+
+        /* Output page */
+        self->priv->output_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);        
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->output_box), 12);
+        label = gtk_label_new (_("Output"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->output_box,
+                                  label);
+
+        box = gtk_frame_new (_("Play sound through:"));
+        gtk_widget_set_size_request (GTK_WIDGET (box), 325, -1);        
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        _gtk_label_make_bold (GTK_LABEL (label));
+        gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+        gtk_box_pack_start (GTK_BOX (self->priv->output_box), box, FALSE, TRUE, 0);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_container_add (GTK_CONTAINER (box), alignment);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 6, 0, 0, 0);
+
+        self->priv->output_treeview = create_stream_treeview (self,
+                                                              G_CALLBACK (on_output_selection_changed));
+        gtk_label_set_mnemonic_widget (GTK_LABEL (label), self->priv->output_treeview);
+
+        box = gtk_scrolled_window_new (NULL, NULL);
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (box),
+                                        GTK_POLICY_NEVER,
+                                        GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (box),
+                                             GTK_SHADOW_IN);
+        gtk_container_add (GTK_CONTAINER (box), self->priv->output_treeview);
+        gtk_container_add (GTK_CONTAINER (alignment), box);
+
+        self->priv->selected_output_label = gtk_label_new (_("Settings for the selected device:"));
+        box = gtk_frame_new ("");
+        gtk_frame_set_label_widget (GTK_FRAME (box), self->priv->selected_output_label);
+
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        _gtk_label_make_bold (GTK_LABEL (label));
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+        
+        gtk_box_pack_start (GTK_BOX (self->priv->output_box), box, FALSE, FALSE, 0);
+        self->priv->output_settings_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+
+        
+        self->priv->output_balance_bar = gvc_balance_bar_new (BALANCE_TYPE_RL);
+        if (self->priv->size_group != NULL) {
+                gvc_balance_bar_set_size_group (GVC_BALANCE_BAR (self->priv->output_balance_bar),
+                                                self->priv->size_group,
+                                                FALSE);
+        }
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_balance_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->output_balance_bar);
+
+        self->priv->output_fade_bar = gvc_balance_bar_new (BALANCE_TYPE_FR);
+        if (self->priv->size_group != NULL) {
+                gvc_balance_bar_set_size_group (GVC_BALANCE_BAR (self->priv->output_fade_bar),
+                                                self->priv->size_group,
+                                                FALSE);
+        }
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_fade_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->output_fade_bar);
+
+        self->priv->output_lfe_bar = gvc_balance_bar_new (BALANCE_TYPE_LFE);
+        if (self->priv->size_group != NULL) {
+                gvc_balance_bar_set_size_group (GVC_BALANCE_BAR (self->priv->output_lfe_bar),
+                                                self->priv->size_group,
+                                                FALSE);
+        }
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_lfe_bar,
+                            FALSE, FALSE, 3);
+        gtk_widget_show (self->priv->output_lfe_bar);
+                
+
+        self->priv->output_port_combo = gvc_combo_box_new (_("Modes:"));
+        g_signal_connect (G_OBJECT (self->priv->output_port_combo), "changed",
+                          G_CALLBACK (profile_selection_changed), self);
+        gtk_box_pack_start (GTK_BOX (self->priv->output_settings_box),
+                            self->priv->output_port_combo,
+                            TRUE, FALSE, 3);
+
+        if (self->priv->size_group != NULL) {
+                gvc_combo_box_set_size_group (GVC_COMBO_BOX (self->priv->output_port_combo),
+                                              self->priv->size_group, FALSE);
+        }
+        gtk_widget_show (self->priv->output_port_combo);
+
+        /* Creating a box and try to deal using the same size group. */
+        test_sound_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_end (GTK_BOX (self->priv->output_settings_box),
+                          test_sound_box,
+                          FALSE, 
+                          FALSE,
+                          5);
+
+        sbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_box_pack_start (GTK_BOX (test_sound_box),
+                            sbox,
+                            FALSE, FALSE, 0);
+
+        label = gtk_label_new (_("Test:"));
+        gtk_box_pack_start (GTK_BOX (sbox),
+                            label,
+                            FALSE, FALSE, 0);
+        if (self->priv->size_group != NULL)
+                gtk_size_group_add_widget (self->priv->size_group, sbox);
+
+        self->priv->test_output_button = gtk_button_new_with_label ("Test Sound");
+        
+        /* FIXME: I am getting mental with all these hardcoded padding values,
+         * Here 8 works fine, not sure why. */
+        gtk_box_pack_start (GTK_BOX (test_sound_box),
+                            self->priv->test_output_button,
+                            TRUE, TRUE, 8);
+
+        /* Is this needed */
+        if (self->priv->size_group != NULL)
+                gtk_size_group_add_widget (self->priv->size_group, self->priv->test_output_button);
+
+        gtk_widget_show (test_sound_box);
+
+        gtk_container_add (GTK_CONTAINER (box), self->priv->output_settings_box);
+	g_signal_connect (self->priv->test_output_button,
+                          "released",
+                           G_CALLBACK (on_test_speakers_clicked),
+                           self);
+	
+        /* Applications */
+        self->priv->applications_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
+        gtk_container_set_border_width (GTK_CONTAINER (self->priv->applications_box), 12);
+        label = gtk_label_new (_("Applications"));
+        gtk_notebook_append_page (GTK_NOTEBOOK (self->priv->notebook),
+                                  self->priv->applications_box,
+                                  label);
+        self->priv->no_apps_label = gtk_label_new (_("No application is currently playing or recording audio."));
+        gtk_box_pack_start (GTK_BOX (self->priv->applications_box),
+                            self->priv->no_apps_label,
+                            TRUE, TRUE, 0);
+
+        self->priv->output_stream_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 12, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (alignment), self->priv->output_stream_box);
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            alignment,
+                            FALSE, FALSE, 0);
+        // Output volume
+        self->priv->output_bar = create_bar (self, FALSE, TRUE);
+        gvc_channel_bar_set_name (GVC_CHANNEL_BAR (self->priv->output_bar),
+                                  _("_Output volume:"));
+        gtk_widget_set_sensitive (self->priv->output_bar, FALSE);
+        gtk_widget_set_size_request (self->priv->output_bar, 460, -1);        
+
+        gtk_box_pack_start (GTK_BOX (self->priv->output_stream_box),
+                            self->priv->output_bar, TRUE, FALSE, 12);
+
+        /* Indicator visibility toggle */
+        w = gtk_check_button_new_with_mnemonic(_( "_Show sound volume in the menu bar"));
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 3, 3, 5, 5);
+        gtk_container_add (GTK_CONTAINER (alignment), w);
+        self->priv->indicator_settings = g_settings_new ("com.canonical.indicator.sound");
+        g_settings_bind (self->priv->indicator_settings, "visible", w, "active", G_SETTINGS_BIND_DEFAULT);
+        gtk_box_pack_start (GTK_BOX (main_vbox),
+                            alignment,
+                            FALSE, FALSE, 0);
+
+        gtk_widget_show_all (main_vbox);
+
+        g_signal_connect (self->priv->mixer_control,
+                          "stream-added",
+                          G_CALLBACK (on_control_stream_added),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "stream-removed",
+                          G_CALLBACK (on_control_stream_removed),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "output-added",
+                          G_CALLBACK (on_control_output_added),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "output-removed",
+                          G_CALLBACK (on_control_output_removed),
+                          self);
+        /*g_signal_connect (self->priv->mixer_control,
+                          "active-output-update",
+                          G_CALLBACK (on_control_active_output_update),
+                          self);*/
+        g_signal_connect (self->priv->mixer_control,
+                          "input-added",
+                          G_CALLBACK (on_control_input_added),
+                          self);
+        g_signal_connect (self->priv->mixer_control,
+                          "input-removed",
+                          G_CALLBACK (on_control_input_removed),
+                          self);        
+        /*g_signal_connect (self->priv->mixer_control,
+                          "active-input-update",
+                          G_CALLBACK (on_control_active_input_update),
+                          self);*/
+
+	//// The below code is redundant, for some reason no cards or sinks
+	//// are returned at this point. 
+        //GSList           *streams;
+        //GSList           *cards;
+        //GSList           *l;
+	
+        //streams = gvc_mixer_control_get_streams (self->priv->mixer_control);
+        //for (l = streams; l != NULL; l = l->next) {
+                //////stream = l->data;
+                ////add_stream (self, stream);
+        ////}
+        ////g_slist_free (streams);
+
+        ////cards = gvc_mixer_control_get_cards (self->priv->mixer_control);
+
+        ////for (l = cards; l != NULL; l = l->next) {
+                ////card = l->data;
+                ////add_card (self, card);
+                ////g_print ("about to add a card");
+        ////}
+        ////g_slist_free (cards);
+        
+        return object;
+}
+
+static void
+gvc_mixer_dialog_dispose (GObject *object)
+{
+        GvcMixerDialog *dialog = GVC_MIXER_DIALOG (object);
+
+        g_clear_object (&dialog->priv->indicator_settings);
+
+        if (dialog->priv->mixer_control != NULL) {
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_output_added,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_output_removed,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_active_input_update,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_active_output_update,
+                                                      dialog);                                            
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_input_added,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_input_removed,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_stream_added,
+                                                      dialog);
+                g_signal_handlers_disconnect_by_func (dialog->priv->mixer_control,
+                                                      on_control_stream_removed,
+                                                      dialog);
+                g_object_unref (dialog->priv->mixer_control);
+                dialog->priv->mixer_control = NULL;
+        }
+
+        if (dialog->priv->bars != NULL) {
+                g_hash_table_destroy (dialog->priv->bars);
+                dialog->priv->bars = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_mixer_dialog_parent_class)->dispose (object);
+}
+
+static void
+gvc_mixer_dialog_class_init (GvcMixerDialogClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_mixer_dialog_constructor;
+        object_class->dispose = gvc_mixer_dialog_dispose;
+        object_class->finalize = gvc_mixer_dialog_finalize;
+        object_class->set_property = gvc_mixer_dialog_set_property;
+        object_class->get_property = gvc_mixer_dialog_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_MIXER_CONTROL,
+                                         g_param_spec_object ("mixer-control",
+                                                              "mixer control",
+                                                              "mixer control",
+                                                              GVC_TYPE_MIXER_CONTROL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcMixerDialogPrivate));
+}
+
+
+static void
+gvc_mixer_dialog_init (GvcMixerDialog *dialog)
+{
+        dialog->priv = GVC_MIXER_DIALOG_GET_PRIVATE (dialog);
+        dialog->priv->bars = g_hash_table_new (NULL, NULL);
+        dialog->priv->size_group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
+}
+
+static void
+gvc_mixer_dialog_finalize (GObject *object)
+{
+        GvcMixerDialog *mixer_dialog;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_DIALOG (object));
+
+        mixer_dialog = GVC_MIXER_DIALOG (object);
+
+        g_return_if_fail (mixer_dialog->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_dialog_parent_class)->finalize (object);
+}
+
+GvcMixerDialog *
+gvc_mixer_dialog_new (GvcMixerControl *control)
+{
+        GObject *dialog;
+        dialog = g_object_new (GVC_TYPE_MIXER_DIALOG,
+                               "mixer-control", control,
+                               NULL);
+        return GVC_MIXER_DIALOG (dialog);
+}
+
+enum {
+        PAGE_EVENTS,
+        PAGE_HARDWARE,
+        PAGE_INPUT,
+        PAGE_OUTPUT,
+        PAGE_APPLICATIONS
+};
+
+gboolean
+gvc_mixer_dialog_set_page (GvcMixerDialog *self,
+                           const char     *page)
+{
+        guint num;
+
+        g_return_val_if_fail (self != NULL, FALSE);
+
+        if (page == NULL)
+                num = 0;
+        else if (g_str_equal (page, "effects"))
+                num = PAGE_EVENTS;
+        else if (g_str_equal (page, "input"))
+                num = PAGE_INPUT;
+        else if (g_str_equal (page, "output"))
+                num = PAGE_OUTPUT;
+        else if (g_str_equal (page, "applications"))
+                num = PAGE_APPLICATIONS;
+        else
+                num = 0;
+
+        gtk_notebook_set_current_page (GTK_NOTEBOOK (self->priv->notebook), num);
+
+        return TRUE;
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-dialog.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-dialog.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,56 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_DIALOG_H
+#define __GVC_MIXER_DIALOG_H
+
+#include <glib-object.h>
+#include "gvc-mixer-control.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_DIALOG         (gvc_mixer_dialog_get_type ())
+#define GVC_MIXER_DIALOG(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_DIALOG, GvcMixerDialog))
+#define GVC_MIXER_DIALOG_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_DIALOG, GvcMixerDialogClass))
+#define GVC_IS_MIXER_DIALOG(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_DIALOG))
+#define GVC_IS_MIXER_DIALOG_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_DIALOG))
+#define GVC_MIXER_DIALOG_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_DIALOG, GvcMixerDialogClass))
+
+typedef struct GvcMixerDialogPrivate GvcMixerDialogPrivate;
+
+typedef struct
+{
+        GtkVBox                parent;
+        GvcMixerDialogPrivate *priv;
+} GvcMixerDialog;
+
+typedef struct
+{
+        GtkVBoxClass           parent_class;
+} GvcMixerDialogClass;
+
+GType               gvc_mixer_dialog_get_type            (void);
+
+GvcMixerDialog *    gvc_mixer_dialog_new                 (GvcMixerControl *control);
+gboolean            gvc_mixer_dialog_set_page            (GvcMixerDialog *dialog, const gchar* page);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_DIALOG_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-event-role.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-event-role.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,231 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+#include <pulse/ext-stream-restore.h>
+
+#include "gvc-mixer-event-role.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_EVENT_ROLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRolePrivate))
+
+struct GvcMixerEventRolePrivate
+{
+        char          *device;
+};
+
+enum
+{
+        PROP_0,
+        PROP_DEVICE
+};
+
+static void     gvc_mixer_event_role_class_init (GvcMixerEventRoleClass *klass);
+static void     gvc_mixer_event_role_init       (GvcMixerEventRole      *mixer_event_role);
+static void     gvc_mixer_event_role_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerEventRole, gvc_mixer_event_role, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+update_settings (GvcMixerEventRole *role,
+                 gboolean           is_muted,
+                 gpointer          *op)
+{
+        pa_operation              *o;
+        const GvcChannelMap       *map;
+        pa_context                *context;
+        pa_ext_stream_restore_info info;
+
+        map = gvc_mixer_stream_get_channel_map (GVC_MIXER_STREAM(role));
+
+        info.volume = *gvc_channel_map_get_cvolume(map);
+        info.name = "sink-input-by-media-role:event";
+        info.channel_map = *gvc_channel_map_get_pa_channel_map(map);
+        info.device = role->priv->device;
+        info.mute = is_muted;
+
+        context = gvc_mixer_stream_get_pa_context (GVC_MIXER_STREAM (role));
+
+        o = pa_ext_stream_restore_write (context,
+                                         PA_UPDATE_REPLACE,
+                                         &info,
+                                         1,
+                                         TRUE,
+                                         NULL,
+                                         NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_ext_stream_restore_write() failed");
+                return FALSE;
+        }
+
+        if (op != NULL)
+                *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_event_role_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        return update_settings (GVC_MIXER_EVENT_ROLE (stream),
+                                gvc_mixer_stream_get_is_muted (stream), op);
+}
+
+static gboolean
+gvc_mixer_event_role_change_is_muted (GvcMixerStream *stream,
+                                      gboolean        is_muted)
+{
+        return update_settings (GVC_MIXER_EVENT_ROLE (stream),
+                                is_muted, NULL);
+}
+
+static gboolean
+gvc_mixer_event_role_set_device (GvcMixerEventRole *role,
+                                 const char        *device)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_EVENT_ROLE (role), FALSE);
+
+        g_free (role->priv->device);
+        role->priv->device = g_strdup (device);
+        g_object_notify (G_OBJECT (role), "device");
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_event_role_set_property (GObject       *object,
+                                   guint          prop_id,
+                                   const GValue  *value,
+                                   GParamSpec    *pspec)
+{
+        GvcMixerEventRole *self = GVC_MIXER_EVENT_ROLE (object);
+
+        switch (prop_id) {
+        case PROP_DEVICE:
+                gvc_mixer_event_role_set_device (self, g_value_get_string (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_event_role_get_property (GObject     *object,
+                                   guint        prop_id,
+                                   GValue      *value,
+                                   GParamSpec  *pspec)
+{
+        GvcMixerEventRole *self = GVC_MIXER_EVENT_ROLE (object);
+
+        switch (prop_id) {
+        case PROP_DEVICE:
+                g_value_set_string (value, self->priv->device);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_event_role_class_init (GvcMixerEventRoleClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_event_role_finalize;
+        object_class->set_property = gvc_mixer_event_role_set_property;
+        object_class->get_property = gvc_mixer_event_role_get_property;
+
+        stream_class->push_volume = gvc_mixer_event_role_push_volume;
+        stream_class->change_is_muted = gvc_mixer_event_role_change_is_muted;
+
+        g_object_class_install_property (object_class,
+                                         PROP_DEVICE,
+                                         g_param_spec_string ("device",
+                                                              "Device",
+                                                              "Device",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcMixerEventRolePrivate));
+}
+
+static void
+gvc_mixer_event_role_init (GvcMixerEventRole *event_role)
+{
+        event_role->priv = GVC_MIXER_EVENT_ROLE_GET_PRIVATE (event_role);
+
+}
+
+static void
+gvc_mixer_event_role_finalize (GObject *object)
+{
+        GvcMixerEventRole *mixer_event_role;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_EVENT_ROLE (object));
+
+        mixer_event_role = GVC_MIXER_EVENT_ROLE (object);
+
+        g_return_if_fail (mixer_event_role->priv != NULL);
+
+        g_free (mixer_event_role->priv->device);
+
+        G_OBJECT_CLASS (gvc_mixer_event_role_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_event_role_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_event_role_new (pa_context *context,
+                          const char *device,
+                          GvcChannelMap *channel_map)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_EVENT_ROLE,
+                               "pa-context", context,
+                               "index", 0,
+                               "device", device,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-event-role.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-event-role.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_EVENT_ROLE_H
+#define __GVC_MIXER_EVENT_ROLE_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_EVENT_ROLE         (gvc_mixer_event_role_get_type ())
+#define GVC_MIXER_EVENT_ROLE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRole))
+#define GVC_MIXER_EVENT_ROLE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRoleClass))
+#define GVC_IS_MIXER_EVENT_ROLE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_EVENT_ROLE))
+#define GVC_IS_MIXER_EVENT_ROLE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_EVENT_ROLE))
+#define GVC_MIXER_EVENT_ROLE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_EVENT_ROLE, GvcMixerEventRoleClass))
+
+typedef struct GvcMixerEventRolePrivate GvcMixerEventRolePrivate;
+
+typedef struct
+{
+        GvcMixerStream            parent;
+        GvcMixerEventRolePrivate *priv;
+} GvcMixerEventRole;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerEventRoleClass;
+
+GType               gvc_mixer_event_role_get_type      (void);
+
+GvcMixerStream *    gvc_mixer_event_role_new           (pa_context    *context,
+                                                        const char    *device,
+                                                        GvcChannelMap *channel_map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_EVENT_ROLE_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-sink-input.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-sink-input.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,166 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-sink-input.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_SINK_INPUT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInputPrivate))
+
+struct GvcMixerSinkInputPrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_sink_input_class_init (GvcMixerSinkInputClass *klass);
+static void     gvc_mixer_sink_input_init       (GvcMixerSinkInput      *mixer_sink_input);
+static void     gvc_mixer_sink_input_finalize   (GObject                *object);
+
+G_DEFINE_TYPE (GvcMixerSinkInput, gvc_mixer_sink_input, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_sink_input_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        pa_operation        *o;
+        guint                index;
+        const GvcChannelMap *map;
+        pa_context          *context;
+        const pa_cvolume    *cv;
+
+        index = gvc_mixer_stream_get_index (stream);
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        cv = gvc_channel_map_get_cvolume(map);
+
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_input_volume (context,
+                                              index,
+                                              cv,
+                                              NULL,
+                                              NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_input_volume() failed");
+                return FALSE;
+        }
+
+        *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_sink_input_change_is_muted (GvcMixerStream *stream,
+                                      gboolean        is_muted)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_input_mute (context,
+                                            index,
+                                            is_muted,
+                                            NULL,
+                                            NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_input_mute_by_index() failed");
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_sink_input_class_init (GvcMixerSinkInputClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_sink_input_finalize;
+
+        stream_class->push_volume = gvc_mixer_sink_input_push_volume;
+        stream_class->change_is_muted = gvc_mixer_sink_input_change_is_muted;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSinkInputPrivate));
+}
+
+static void
+gvc_mixer_sink_input_init (GvcMixerSinkInput *sink_input)
+{
+        sink_input->priv = GVC_MIXER_SINK_INPUT_GET_PRIVATE (sink_input);
+}
+
+static void
+gvc_mixer_sink_input_finalize (GObject *object)
+{
+        GvcMixerSinkInput *mixer_sink_input;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SINK_INPUT (object));
+
+        mixer_sink_input = GVC_MIXER_SINK_INPUT (object);
+
+        g_return_if_fail (mixer_sink_input->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_sink_input_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_sink_input_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_sink_input_new (pa_context    *context,
+                          guint          index,
+                          GvcChannelMap *channel_map)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SINK_INPUT,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-sink-input.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-sink-input.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SINK_INPUT_H
+#define __GVC_MIXER_SINK_INPUT_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SINK_INPUT         (gvc_mixer_sink_input_get_type ())
+#define GVC_MIXER_SINK_INPUT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInput))
+#define GVC_MIXER_SINK_INPUT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInputClass))
+#define GVC_IS_MIXER_SINK_INPUT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SINK_INPUT))
+#define GVC_IS_MIXER_SINK_INPUT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SINK_INPUT))
+#define GVC_MIXER_SINK_INPUT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SINK_INPUT, GvcMixerSinkInputClass))
+
+typedef struct GvcMixerSinkInputPrivate GvcMixerSinkInputPrivate;
+
+typedef struct
+{
+        GvcMixerStream            parent;
+        GvcMixerSinkInputPrivate *priv;
+} GvcMixerSinkInput;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSinkInputClass;
+
+GType               gvc_mixer_sink_input_get_type      (void);
+
+GvcMixerStream *    gvc_mixer_sink_input_new           (pa_context    *context,
+                                                        guint          index,
+                                                        GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SINK_INPUT_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-sink.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-sink.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,196 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-sink.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_SINK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SINK, GvcMixerSinkPrivate))
+
+struct GvcMixerSinkPrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_sink_class_init (GvcMixerSinkClass *klass);
+static void     gvc_mixer_sink_init       (GvcMixerSink      *mixer_sink);
+static void     gvc_mixer_sink_finalize   (GObject           *object);
+
+G_DEFINE_TYPE (GvcMixerSink, gvc_mixer_sink, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_sink_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        pa_operation        *o;
+        guint                index;
+        const GvcChannelMap *map;
+        pa_context          *context;
+        const pa_cvolume    *cv;
+
+        index = gvc_mixer_stream_get_index (stream);
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        /* set the volume */
+        cv = gvc_channel_map_get_cvolume(map);
+
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_volume_by_index (context,
+                                                 index,
+                                                 cv,
+                                                 NULL,
+                                                 NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_volume_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_sink_change_is_muted (GvcMixerStream *stream,
+                                gboolean        is_muted)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_mute_by_index (context,
+                                               index,
+                                               is_muted,
+                                               NULL,
+                                               NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_mute_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_sink_change_port (GvcMixerStream *stream,
+                            const char     *port)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_sink_port_by_index (context,
+                                               index,
+                                               port,
+                                               NULL,
+                                               NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_sink_port_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_sink_class_init (GvcMixerSinkClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_sink_finalize;
+
+        stream_class->push_volume = gvc_mixer_sink_push_volume;
+        stream_class->change_port = gvc_mixer_sink_change_port;
+        stream_class->change_is_muted = gvc_mixer_sink_change_is_muted;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSinkPrivate));
+}
+
+static void
+gvc_mixer_sink_init (GvcMixerSink *sink)
+{
+        sink->priv = GVC_MIXER_SINK_GET_PRIVATE (sink);
+}
+
+static void
+gvc_mixer_sink_finalize (GObject *object)
+{
+        GvcMixerSink *mixer_sink;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SINK (object));
+
+        mixer_sink = GVC_MIXER_SINK (object);
+
+        g_return_if_fail (mixer_sink->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_sink_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_sink_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_sink_new (pa_context    *context,
+                    guint          index,
+                    GvcChannelMap *channel_map)
+
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SINK,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-sink.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-sink.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SINK_H
+#define __GVC_MIXER_SINK_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SINK         (gvc_mixer_sink_get_type ())
+#define GVC_MIXER_SINK(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SINK, GvcMixerSink))
+#define GVC_MIXER_SINK_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SINK, GvcMixerSinkClass))
+#define GVC_IS_MIXER_SINK(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SINK))
+#define GVC_IS_MIXER_SINK_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SINK))
+#define GVC_MIXER_SINK_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SINK, GvcMixerSinkClass))
+
+typedef struct GvcMixerSinkPrivate GvcMixerSinkPrivate;
+
+typedef struct
+{
+        GvcMixerStream       parent;
+        GvcMixerSinkPrivate *priv;
+} GvcMixerSink;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSinkClass;
+
+GType               gvc_mixer_sink_get_type            (void);
+
+GvcMixerStream *    gvc_mixer_sink_new                 (pa_context    *context,
+                                                        guint          index,
+                                                        GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SINK_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-source-output.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-source-output.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,121 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-source-output.h"
+
+#define GVC_MIXER_SOURCE_OUTPUT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutputPrivate))
+
+struct GvcMixerSourceOutputPrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_source_output_class_init (GvcMixerSourceOutputClass *klass);
+static void     gvc_mixer_source_output_init       (GvcMixerSourceOutput      *mixer_source_output);
+static void     gvc_mixer_source_output_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerSourceOutput, gvc_mixer_source_output, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_source_output_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        /* FIXME: */
+        *op = NULL;
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_source_output_change_is_muted (GvcMixerStream *stream,
+                                      gboolean        is_muted)
+{
+        /* FIXME: */
+        return TRUE;
+}
+
+static void
+gvc_mixer_source_output_class_init (GvcMixerSourceOutputClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_source_output_finalize;
+
+        stream_class->push_volume = gvc_mixer_source_output_push_volume;
+        stream_class->change_is_muted = gvc_mixer_source_output_change_is_muted;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSourceOutputPrivate));
+}
+
+static void
+gvc_mixer_source_output_init (GvcMixerSourceOutput *source_output)
+{
+        source_output->priv = GVC_MIXER_SOURCE_OUTPUT_GET_PRIVATE (source_output);
+
+}
+
+static void
+gvc_mixer_source_output_finalize (GObject *object)
+{
+        GvcMixerSourceOutput *mixer_source_output;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SOURCE_OUTPUT (object));
+
+        mixer_source_output = GVC_MIXER_SOURCE_OUTPUT (object);
+
+        g_return_if_fail (mixer_source_output->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_source_output_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_source_output_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_source_output_new (pa_context    *context,
+                             guint          index,
+                             GvcChannelMap *channel_map)
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SOURCE_OUTPUT,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-source-output.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-source-output.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SOURCE_OUTPUT_H
+#define __GVC_MIXER_SOURCE_OUTPUT_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SOURCE_OUTPUT         (gvc_mixer_source_output_get_type ())
+#define GVC_MIXER_SOURCE_OUTPUT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutput))
+#define GVC_MIXER_SOURCE_OUTPUT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutputClass))
+#define GVC_IS_MIXER_SOURCE_OUTPUT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT))
+#define GVC_IS_MIXER_SOURCE_OUTPUT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SOURCE_OUTPUT))
+#define GVC_MIXER_SOURCE_OUTPUT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SOURCE_OUTPUT, GvcMixerSourceOutputClass))
+
+typedef struct GvcMixerSourceOutputPrivate GvcMixerSourceOutputPrivate;
+
+typedef struct
+{
+        GvcMixerStream               parent;
+        GvcMixerSourceOutputPrivate *priv;
+} GvcMixerSourceOutput;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSourceOutputClass;
+
+GType               gvc_mixer_source_output_get_type      (void);
+
+GvcMixerStream *    gvc_mixer_source_output_new           (pa_context    *context,
+                                                           guint          index,
+                                                           GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SOURCE_OUTPUT_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-source.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-source.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,196 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-source.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_SOURCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_SOURCE, GvcMixerSourcePrivate))
+
+struct GvcMixerSourcePrivate
+{
+        gpointer dummy;
+};
+
+static void     gvc_mixer_source_class_init (GvcMixerSourceClass *klass);
+static void     gvc_mixer_source_init       (GvcMixerSource      *mixer_source);
+static void     gvc_mixer_source_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcMixerSource, gvc_mixer_source, GVC_TYPE_MIXER_STREAM)
+
+static gboolean
+gvc_mixer_source_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        pa_operation        *o;
+        guint                index;
+        const GvcChannelMap *map;
+        pa_context          *context;
+        const pa_cvolume    *cv;
+
+        index = gvc_mixer_stream_get_index (stream);
+
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        /* set the volume */
+        cv = gvc_channel_map_get_cvolume (map);
+
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_source_volume_by_index (context,
+                                                   index,
+                                                   cv,
+                                                   NULL,
+                                                   NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_source_volume_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        *op = o;
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_source_change_is_muted (GvcMixerStream *stream,
+                                gboolean        is_muted)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_source_mute_by_index (context,
+                                                 index,
+                                                 is_muted,
+                                                 NULL,
+                                                 NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_source_mute_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static gboolean
+gvc_mixer_source_change_port (GvcMixerStream *stream,
+                              const char     *port)
+{
+        pa_operation *o;
+        guint         index;
+        pa_context   *context;
+
+        index = gvc_mixer_stream_get_index (stream);
+        context = gvc_mixer_stream_get_pa_context (stream);
+
+        o = pa_context_set_source_port_by_index (context,
+                                                 index,
+                                                 port,
+                                                 NULL,
+                                                 NULL);
+
+        if (o == NULL) {
+                g_warning ("pa_context_set_source_port_by_index() failed: %s", pa_strerror(pa_context_errno(context)));
+                return FALSE;
+        }
+
+        pa_operation_unref(o);
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_source_class_init (GvcMixerSourceClass *klass)
+{
+        GObjectClass        *object_class = G_OBJECT_CLASS (klass);
+        GvcMixerStreamClass *stream_class = GVC_MIXER_STREAM_CLASS (klass);
+
+        object_class->finalize = gvc_mixer_source_finalize;
+
+        stream_class->push_volume = gvc_mixer_source_push_volume;
+        stream_class->change_is_muted = gvc_mixer_source_change_is_muted;
+        stream_class->change_port = gvc_mixer_source_change_port;
+
+        g_type_class_add_private (klass, sizeof (GvcMixerSourcePrivate));
+}
+
+static void
+gvc_mixer_source_init (GvcMixerSource *source)
+{
+        source->priv = GVC_MIXER_SOURCE_GET_PRIVATE (source);
+}
+
+static void
+gvc_mixer_source_finalize (GObject *object)
+{
+        GvcMixerSource *mixer_source;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_SOURCE (object));
+
+        mixer_source = GVC_MIXER_SOURCE (object);
+
+        g_return_if_fail (mixer_source->priv != NULL);
+        G_OBJECT_CLASS (gvc_mixer_source_parent_class)->finalize (object);
+}
+
+/**
+ * gvc_mixer_source_new: (skip)
+ *
+ * @context:
+ * @index:
+ * @channel_map:
+ *
+ * Returns:
+ */
+GvcMixerStream *
+gvc_mixer_source_new (pa_context    *context,
+                      guint          index,
+                      GvcChannelMap *channel_map)
+
+{
+        GObject *object;
+
+        object = g_object_new (GVC_TYPE_MIXER_SOURCE,
+                               "pa-context", context,
+                               "index", index,
+                               "channel-map", channel_map,
+                               NULL);
+
+        return GVC_MIXER_STREAM (object);
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-source.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-source.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_SOURCE_H
+#define __GVC_MIXER_SOURCE_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_SOURCE         (gvc_mixer_source_get_type ())
+#define GVC_MIXER_SOURCE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_SOURCE, GvcMixerSource))
+#define GVC_MIXER_SOURCE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_SOURCE, GvcMixerSourceClass))
+#define GVC_IS_MIXER_SOURCE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_SOURCE))
+#define GVC_IS_MIXER_SOURCE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_SOURCE))
+#define GVC_MIXER_SOURCE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_SOURCE, GvcMixerSourceClass))
+
+typedef struct GvcMixerSourcePrivate GvcMixerSourcePrivate;
+
+typedef struct
+{
+        GvcMixerStream       parent;
+        GvcMixerSourcePrivate *priv;
+} GvcMixerSource;
+
+typedef struct
+{
+        GvcMixerStreamClass parent_class;
+} GvcMixerSourceClass;
+
+GType               gvc_mixer_source_get_type            (void);
+
+GvcMixerStream *    gvc_mixer_source_new               (pa_context    *context,
+                                                        guint          index,
+                                                        GvcChannelMap *map);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_SOURCE_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-stream-private.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-stream-private.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,34 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_STREAM_PRIVATE_H
+#define __GVC_MIXER_STREAM_PRIVATE_H
+
+#include <glib-object.h>
+
+#include "gvc-channel-map.h"
+
+G_BEGIN_DECLS
+
+pa_context *        gvc_mixer_stream_get_pa_context  (GvcMixerStream *stream);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_STREAM_PRIVATE_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-stream.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-stream.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,968 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-stream.h"
+#include "gvc-mixer-stream-private.h"
+#include "gvc-channel-map-private.h"
+
+#define GVC_MIXER_STREAM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_MIXER_STREAM, GvcMixerStreamPrivate))
+
+static guint32 stream_serial = 1;
+
+struct GvcMixerStreamPrivate
+{
+        pa_context    *pa_context;
+        guint          id;
+        guint          index;
+        gint           card_index;
+        GvcChannelMap *channel_map;
+        char          *name;
+        char          *description;
+        char          *application_id;
+        char          *icon_name;
+        gboolean       is_muted;
+        gboolean       can_decibel;
+        gboolean       is_event_stream;
+        gboolean       is_virtual;
+        pa_volume_t    base_volume;
+        pa_operation  *change_volume_op;
+        char          *port;
+        char          *human_port;
+        GList         *ports;
+};
+
+enum
+{
+        PROP_0,
+        PROP_ID,
+        PROP_PA_CONTEXT,
+        PROP_CHANNEL_MAP,
+        PROP_INDEX,
+        PROP_NAME,
+        PROP_DESCRIPTION,
+        PROP_APPLICATION_ID,
+        PROP_ICON_NAME,
+        PROP_VOLUME,
+        PROP_DECIBEL,
+        PROP_IS_MUTED,
+        PROP_CAN_DECIBEL,
+        PROP_IS_EVENT_STREAM,
+        PROP_IS_VIRTUAL,
+        PROP_CARD_INDEX,
+        PROP_PORT,
+};
+
+static void     gvc_mixer_stream_class_init (GvcMixerStreamClass *klass);
+static void     gvc_mixer_stream_init       (GvcMixerStream      *mixer_stream);
+static void     gvc_mixer_stream_finalize   (GObject            *object);
+
+G_DEFINE_ABSTRACT_TYPE (GvcMixerStream, gvc_mixer_stream, G_TYPE_OBJECT)
+
+static guint32
+get_next_stream_serial (void)
+{
+        guint32 serial;
+
+        serial = stream_serial++;
+
+        if ((gint32)stream_serial < 0) {
+                stream_serial = 1;
+        }
+
+        return serial;
+}
+
+pa_context *
+gvc_mixer_stream_get_pa_context (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+        return stream->priv->pa_context;
+}
+
+guint
+gvc_mixer_stream_get_index (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+        return stream->priv->index;
+}
+
+guint
+gvc_mixer_stream_get_id (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+        return stream->priv->id;
+}
+
+const GvcChannelMap *
+gvc_mixer_stream_get_channel_map (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->channel_map;
+}
+
+/**
+ * gvc_mixer_stream_get_volume:
+ *
+ * @stream:
+ *
+ * Returns: (type guint32) (transfer none):
+ */
+pa_volume_t
+gvc_mixer_stream_get_volume (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+
+        return (pa_volume_t) gvc_channel_map_get_volume(stream->priv->channel_map)[VOLUME];
+}
+
+gdouble
+gvc_mixer_stream_get_decibel (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+
+        return pa_sw_volume_to_dB(
+                        (pa_volume_t) gvc_channel_map_get_volume(stream->priv->channel_map)[VOLUME]);
+}
+
+/**
+ * gvc_mixer_stream_set_volume:
+ *
+ * @stream:
+ * @volume: (type guint32):
+ *
+ * Returns:
+ */
+gboolean
+gvc_mixer_stream_set_volume (GvcMixerStream *stream,
+                              pa_volume_t     volume)
+{
+        pa_cvolume cv;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        cv = *gvc_channel_map_get_cvolume(stream->priv->channel_map);
+        pa_cvolume_scale(&cv, volume);
+
+        if (!pa_cvolume_equal(gvc_channel_map_get_cvolume(stream->priv->channel_map), &cv)) {
+                gvc_channel_map_volume_changed(stream->priv->channel_map, &cv, FALSE);
+                g_object_notify (G_OBJECT (stream), "volume");
+                return TRUE;
+        }
+
+        return FALSE;
+}
+
+gboolean
+gvc_mixer_stream_set_decibel (GvcMixerStream *stream,
+                              gdouble         db)
+{
+        pa_cvolume cv;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        cv = *gvc_channel_map_get_cvolume(stream->priv->channel_map);
+        pa_cvolume_scale(&cv, pa_sw_volume_from_dB(db));
+
+        if (!pa_cvolume_equal(gvc_channel_map_get_cvolume(stream->priv->channel_map), &cv)) {
+                gvc_channel_map_volume_changed(stream->priv->channel_map, &cv, FALSE);
+                g_object_notify (G_OBJECT (stream), "volume");
+        }
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_get_is_muted  (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        return stream->priv->is_muted;
+}
+
+gboolean
+gvc_mixer_stream_get_can_decibel (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        return stream->priv->can_decibel;
+}
+
+gboolean
+gvc_mixer_stream_set_is_muted  (GvcMixerStream *stream,
+                                gboolean        is_muted)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (is_muted != stream->priv->is_muted) {
+                stream->priv->is_muted = is_muted;
+                g_object_notify (G_OBJECT (stream), "is-muted");
+        }
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_set_can_decibel  (GvcMixerStream *stream,
+                                   gboolean        can_decibel)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (can_decibel != stream->priv->can_decibel) {
+                stream->priv->can_decibel = can_decibel;
+                g_object_notify (G_OBJECT (stream), "can-decibel");
+        }
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_stream_get_name (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->name;
+}
+
+const char *
+gvc_mixer_stream_get_description (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->description;
+}
+
+gboolean
+gvc_mixer_stream_set_name (GvcMixerStream *stream,
+                           const char     *name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->name);
+        stream->priv->name = g_strdup (name);
+        g_object_notify (G_OBJECT (stream), "name");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_set_description (GvcMixerStream *stream,
+                                  const char     *description)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->description);
+        stream->priv->description = g_strdup (description);
+        g_object_notify (G_OBJECT (stream), "description");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_is_event_stream (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        return stream->priv->is_event_stream;
+}
+
+gboolean
+gvc_mixer_stream_set_is_event_stream (GvcMixerStream *stream,
+                                      gboolean is_event_stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->is_event_stream = is_event_stream;
+        g_object_notify (G_OBJECT (stream), "is-event-stream");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_is_virtual (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        return stream->priv->is_virtual;
+}
+
+gboolean
+gvc_mixer_stream_set_is_virtual (GvcMixerStream *stream,
+                                 gboolean is_virtual)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->is_virtual = is_virtual;
+        g_object_notify (G_OBJECT (stream), "is-virtual");
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_stream_get_application_id (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->application_id;
+}
+
+gboolean
+gvc_mixer_stream_set_application_id (GvcMixerStream *stream,
+                                     const char *application_id)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->application_id);
+        stream->priv->application_id = g_strdup (application_id);
+        g_object_notify (G_OBJECT (stream), "application-id");
+
+        return TRUE;
+}
+
+static void
+on_channel_map_volume_changed (GvcChannelMap  *channel_map,
+                               gboolean        set,
+                               GvcMixerStream *stream)
+{
+        if (set == TRUE)
+                gvc_mixer_stream_push_volume (stream);
+
+        g_object_notify (G_OBJECT (stream), "volume");
+}
+
+static gboolean
+gvc_mixer_stream_set_channel_map (GvcMixerStream *stream,
+                                  GvcChannelMap  *channel_map)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (channel_map != NULL) {
+                g_object_ref (channel_map);
+        }
+
+        if (stream->priv->channel_map != NULL) {
+                g_signal_handlers_disconnect_by_func (stream->priv->channel_map,
+                                                      on_channel_map_volume_changed,
+                                                      stream);
+                g_object_unref (stream->priv->channel_map);
+        }
+
+        stream->priv->channel_map = channel_map;
+
+        if (stream->priv->channel_map != NULL) {
+                g_signal_connect (stream->priv->channel_map,
+                                  "volume-changed",
+                                  G_CALLBACK (on_channel_map_volume_changed),
+                                  stream);
+
+                g_object_notify (G_OBJECT (stream), "channel-map");
+        }
+
+        return TRUE;
+}
+
+const char *
+gvc_mixer_stream_get_icon_name (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->icon_name;
+}
+
+/**
+ * gvc_mixer_stream_get_gicon:
+ * @stream: a #GvcMixerStream
+ *
+ * Returns: (transfer full): a new #GIcon
+ */
+GIcon *
+gvc_mixer_stream_get_gicon (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        if (stream->priv->icon_name == NULL)
+                return NULL;
+        return g_themed_icon_new_with_default_fallbacks (stream->priv->icon_name);
+}
+
+gboolean
+gvc_mixer_stream_set_icon_name (GvcMixerStream *stream,
+                                const char     *icon_name)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        g_free (stream->priv->icon_name);
+        stream->priv->icon_name = g_strdup (icon_name);
+        g_object_notify (G_OBJECT (stream), "icon-name");
+
+        return TRUE;
+}
+
+/**
+ * gvc_mixer_stream_get_base_volume:
+ *
+ * @stream:
+ *
+ * Returns: (type guint32) (transfer none):
+ */
+pa_volume_t
+gvc_mixer_stream_get_base_volume (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), 0);
+
+        return stream->priv->base_volume;
+}
+
+/**
+ * gvc_mixer_stream_set_base_volume:
+ *
+ * @stream:
+ * @base_volume: (type guint32):
+ *
+ * Returns:
+ */
+gboolean
+gvc_mixer_stream_set_base_volume (GvcMixerStream *stream,
+                                  pa_volume_t base_volume)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->base_volume = base_volume;
+
+        return TRUE;
+}
+
+const GvcMixerStreamPort *
+gvc_mixer_stream_get_port (GvcMixerStream *stream)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        g_return_val_if_fail (stream->priv->ports != NULL, NULL);
+
+        for (l = stream->priv->ports; l != NULL; l = l->next) {
+                GvcMixerStreamPort *p = l->data;
+                if (g_strcmp0 (stream->priv->port, p->port) == 0) {
+                        return p;
+                }
+        }
+
+        g_assert_not_reached ();
+
+        return NULL;
+}
+
+gboolean
+gvc_mixer_stream_set_port (GvcMixerStream *stream,
+                           const char     *port)
+{
+        GList *l;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        g_return_val_if_fail (stream->priv->ports != NULL, FALSE);
+
+        g_free (stream->priv->port);
+        stream->priv->port = g_strdup (port);
+
+        g_free (stream->priv->human_port);
+        stream->priv->human_port = NULL;
+
+        for (l = stream->priv->ports; l != NULL; l = l->next) {
+                GvcMixerStreamPort *p = l->data;
+                if (g_str_equal (stream->priv->port, p->port)) {
+                        stream->priv->human_port = g_strdup (p->human_port);
+                        break;
+                }
+        }
+
+        g_object_notify (G_OBJECT (stream), "port");
+
+        return TRUE;
+}
+
+gboolean
+gvc_mixer_stream_change_port (GvcMixerStream *stream,
+                              const char     *port)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        return GVC_MIXER_STREAM_GET_CLASS (stream)->change_port (stream, port);
+}
+
+/**
+ * gvc_mixer_stream_get_ports:
+ *
+ * Return value: (transfer none) (element-type GvcMixerStreamPort):
+ */
+const GList *
+gvc_mixer_stream_get_ports (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), NULL);
+        return stream->priv->ports;
+}
+
+static int
+sort_ports (GvcMixerStreamPort *a,
+            GvcMixerStreamPort *b)
+{
+        if (a->priority == b->priority)
+                return 0;
+        if (a->priority > b->priority)
+                return 1;
+        return -1;
+}
+
+/**
+ * gvc_mixer_stream_set_ports:
+ * @ports: (transfer full) (element-type GvcMixerStreamPort):
+ */
+gboolean
+gvc_mixer_stream_set_ports (GvcMixerStream *stream,
+                            GList          *ports)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        g_return_val_if_fail (stream->priv->ports == NULL, FALSE);
+
+        stream->priv->ports = g_list_sort (ports, (GCompareFunc) sort_ports);
+
+        return TRUE;
+}
+
+gint
+gvc_mixer_stream_get_card_index (GvcMixerStream *stream)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), PA_INVALID_INDEX);
+        return stream->priv->card_index;
+}
+
+gboolean
+gvc_mixer_stream_set_card_index (GvcMixerStream *stream,
+                                 gint            card_index)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        stream->priv->card_index = card_index;
+        g_object_notify (G_OBJECT (stream), "card-index");
+
+        return TRUE;
+}
+
+static void
+gvc_mixer_stream_set_property (GObject       *object,
+                               guint          prop_id,
+                               const GValue  *value,
+                               GParamSpec    *pspec)
+{
+        GvcMixerStream *self = GVC_MIXER_STREAM (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                self->priv->pa_context = g_value_get_pointer (value);
+                break;
+        case PROP_INDEX:
+                self->priv->index = g_value_get_ulong (value);
+                break;
+        case PROP_ID:
+                self->priv->id = g_value_get_ulong (value);
+                break;
+        case PROP_CHANNEL_MAP:
+                gvc_mixer_stream_set_channel_map (self, g_value_get_object (value));
+                break;
+        case PROP_NAME:
+                gvc_mixer_stream_set_name (self, g_value_get_string (value));
+                break;
+        case PROP_DESCRIPTION:
+                gvc_mixer_stream_set_description (self, g_value_get_string (value));
+                break;
+        case PROP_APPLICATION_ID:
+                gvc_mixer_stream_set_application_id (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAME:
+                gvc_mixer_stream_set_icon_name (self, g_value_get_string (value));
+                break;
+        case PROP_VOLUME:
+                gvc_mixer_stream_set_volume (self, g_value_get_ulong (value));
+                break;
+        case PROP_DECIBEL:
+                gvc_mixer_stream_set_decibel (self, g_value_get_double (value));
+                break;
+        case PROP_IS_MUTED:
+                gvc_mixer_stream_set_is_muted (self, g_value_get_boolean (value));
+                break;
+        case PROP_IS_EVENT_STREAM:
+                gvc_mixer_stream_set_is_event_stream (self, g_value_get_boolean (value));
+                break;
+        case PROP_IS_VIRTUAL:
+                gvc_mixer_stream_set_is_virtual (self, g_value_get_boolean (value));
+                break;
+        case PROP_CAN_DECIBEL:
+                gvc_mixer_stream_set_can_decibel (self, g_value_get_boolean (value));
+                break;
+        case PROP_PORT:
+                gvc_mixer_stream_set_port (self, g_value_get_string (value));
+                break;
+        case PROP_CARD_INDEX:
+                self->priv->card_index = g_value_get_long (value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_mixer_stream_get_property (GObject     *object,
+                               guint        prop_id,
+                               GValue      *value,
+                               GParamSpec  *pspec)
+{
+        GvcMixerStream *self = GVC_MIXER_STREAM (object);
+
+        switch (prop_id) {
+        case PROP_PA_CONTEXT:
+                g_value_set_pointer (value, self->priv->pa_context);
+                break;
+        case PROP_INDEX:
+                g_value_set_ulong (value, self->priv->index);
+                break;
+        case PROP_ID:
+                g_value_set_ulong (value, self->priv->id);
+                break;
+        case PROP_CHANNEL_MAP:
+                g_value_set_object (value, self->priv->channel_map);
+                break;
+        case PROP_NAME:
+                g_value_set_string (value, self->priv->name);
+                break;
+        case PROP_DESCRIPTION:
+                g_value_set_string (value, self->priv->description);
+                break;
+        case PROP_APPLICATION_ID:
+                g_value_set_string (value, self->priv->application_id);
+                break;
+        case PROP_ICON_NAME:
+                g_value_set_string (value, self->priv->icon_name);
+                break;
+        case PROP_VOLUME:
+                g_value_set_ulong (value,
+                                   pa_cvolume_max(gvc_channel_map_get_cvolume(self->priv->channel_map)));
+                break;
+        case PROP_DECIBEL:
+                g_value_set_double (value,
+                                    pa_sw_volume_to_dB(pa_cvolume_max(gvc_channel_map_get_cvolume(self->priv->channel_map))));
+                break;
+        case PROP_IS_MUTED:
+                g_value_set_boolean (value, self->priv->is_muted);
+                break;
+        case PROP_IS_EVENT_STREAM:
+                g_value_set_boolean (value, self->priv->is_event_stream);
+                break;
+        case PROP_IS_VIRTUAL:
+                g_value_set_boolean (value, self->priv->is_virtual);
+                break;
+        case PROP_CAN_DECIBEL:
+                g_value_set_boolean (value, self->priv->can_decibel);
+                break;
+        case PROP_PORT:
+                g_value_set_string (value, self->priv->port);
+                break;
+        case PROP_CARD_INDEX:
+                g_value_set_long (value, self->priv->card_index);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gvc_mixer_stream_constructor (GType                  type,
+                              guint                  n_construct_properties,
+                              GObjectConstructParam *construct_params)
+{
+        GObject       *object;
+        GvcMixerStream *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_stream_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_STREAM (object);
+
+        self->priv->id = get_next_stream_serial ();
+
+        return object;
+}
+
+static gboolean
+gvc_mixer_stream_real_change_port (GvcMixerStream *stream,
+                                   const char     *port)
+{
+        return FALSE;
+}
+
+static gboolean
+gvc_mixer_stream_real_push_volume (GvcMixerStream *stream, gpointer *op)
+{
+        return FALSE;
+}
+
+static gboolean
+gvc_mixer_stream_real_change_is_muted (GvcMixerStream *stream,
+                                       gboolean        is_muted)
+{
+        return FALSE;
+}
+
+gboolean
+gvc_mixer_stream_push_volume (GvcMixerStream *stream)
+{
+        pa_operation *op;
+        gboolean ret;
+
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+
+        if (stream->priv->is_event_stream != FALSE)
+                return TRUE;
+
+        g_debug ("Pushing new volume to stream '%s' (%s)",
+                 stream->priv->description, stream->priv->name);
+
+        ret = GVC_MIXER_STREAM_GET_CLASS (stream)->push_volume (stream, (gpointer *) &op);
+        if (ret) {
+                if (stream->priv->change_volume_op != NULL)
+                        pa_operation_unref (stream->priv->change_volume_op);
+                stream->priv->change_volume_op = op;
+        }
+        return ret;
+}
+
+gboolean
+gvc_mixer_stream_change_is_muted (GvcMixerStream *stream,
+                                  gboolean        is_muted)
+{
+        gboolean ret;
+        g_return_val_if_fail (GVC_IS_MIXER_STREAM (stream), FALSE);
+        ret = GVC_MIXER_STREAM_GET_CLASS (stream)->change_is_muted (stream, is_muted);
+        return ret;
+}
+
+gboolean
+gvc_mixer_stream_is_running (GvcMixerStream *stream)
+{
+        if (stream->priv->change_volume_op == NULL)
+                return FALSE;
+
+        if ((pa_operation_get_state(stream->priv->change_volume_op) == PA_OPERATION_RUNNING))
+                return TRUE;
+
+        pa_operation_unref(stream->priv->change_volume_op);
+        stream->priv->change_volume_op = NULL;
+
+        return FALSE;
+}
+
+static void
+gvc_mixer_stream_class_init (GvcMixerStreamClass *klass)
+{
+        GObjectClass   *gobject_class = G_OBJECT_CLASS (klass);
+
+        gobject_class->constructor = gvc_mixer_stream_constructor;
+        gobject_class->finalize = gvc_mixer_stream_finalize;
+        gobject_class->set_property = gvc_mixer_stream_set_property;
+        gobject_class->get_property = gvc_mixer_stream_get_property;
+
+        klass->push_volume = gvc_mixer_stream_real_push_volume;
+        klass->change_port = gvc_mixer_stream_real_change_port;
+        klass->change_is_muted = gvc_mixer_stream_real_change_is_muted;
+
+        g_object_class_install_property (gobject_class,
+                                         PROP_INDEX,
+                                         g_param_spec_ulong ("index",
+                                                             "Index",
+                                                             "The index for this stream",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ID,
+                                         g_param_spec_ulong ("id",
+                                                             "id",
+                                                             "The id for this stream",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_CHANNEL_MAP,
+                                         g_param_spec_object ("channel-map",
+                                                              "channel map",
+                                                              "The channel map for this stream",
+                                                              GVC_TYPE_CHANNEL_MAP,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PA_CONTEXT,
+                                         g_param_spec_pointer ("pa-context",
+                                                               "PulseAudio context",
+                                                               "The PulseAudio context for this stream",
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (gobject_class,
+                                         PROP_VOLUME,
+                                         g_param_spec_ulong ("volume",
+                                                             "Volume",
+                                                             "The volume for this stream",
+                                                             0, G_MAXULONG, 0,
+                                                             G_PARAM_READWRITE));
+        g_object_class_install_property (gobject_class,
+                                         PROP_DECIBEL,
+                                         g_param_spec_double ("decibel",
+                                                              "Decibel",
+                                                              "The decibel level for this stream",
+                                                              -G_MAXDOUBLE, G_MAXDOUBLE, 0,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_object_class_install_property (gobject_class,
+                                         PROP_NAME,
+                                         g_param_spec_string ("name",
+                                                              "Name",
+                                                              "Name to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_DESCRIPTION,
+                                         g_param_spec_string ("description",
+                                                              "Description",
+                                                              "Description to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_APPLICATION_ID,
+                                         g_param_spec_string ("application-id",
+                                                              "Application identifier",
+                                                              "Application identifier for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_ICON_NAME,
+                                         g_param_spec_string ("icon-name",
+                                                              "Icon Name",
+                                                              "Name of icon to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_IS_MUTED,
+                                         g_param_spec_boolean ("is-muted",
+                                                               "is muted",
+                                                               "Whether stream is muted",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_CAN_DECIBEL,
+                                         g_param_spec_boolean ("can-decibel",
+                                                               "can decibel",
+                                                               "Whether stream volume can be converted to decibel units",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_IS_EVENT_STREAM,
+                                         g_param_spec_boolean ("is-event-stream",
+                                                               "is event stream",
+                                                               "Whether stream's role is to play an event",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_IS_VIRTUAL,
+                                         g_param_spec_boolean ("is-virtual",
+                                                               "is virtual stream",
+                                                               "Whether the stream is virtual",
+                                                               FALSE,
+                                                               G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (gobject_class,
+                                         PROP_PORT,
+                                         g_param_spec_string ("port",
+                                                              "Port",
+                                                              "The name of the current port for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE));
+        g_object_class_install_property (gobject_class,
+                                         PROP_CARD_INDEX,
+                                         g_param_spec_long ("card-index",
+                                                             "Card index",
+                                                             "The index of the card for this stream",
+                                                             PA_INVALID_INDEX, G_MAXLONG, PA_INVALID_INDEX,
+                                                             G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_type_class_add_private (klass, sizeof (GvcMixerStreamPrivate));
+}
+
+static void
+gvc_mixer_stream_init (GvcMixerStream *stream)
+{
+        stream->priv = GVC_MIXER_STREAM_GET_PRIVATE (stream);
+}
+
+static void
+free_port (GvcMixerStreamPort *p)
+{
+        g_free (p->port);
+        g_free (p->human_port);
+        g_free (p);
+}
+
+static void
+gvc_mixer_stream_finalize (GObject *object)
+{
+        GvcMixerStream *mixer_stream;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_MIXER_STREAM (object));
+
+        mixer_stream = GVC_MIXER_STREAM (object);
+
+        g_return_if_fail (mixer_stream->priv != NULL);
+
+        g_object_unref (mixer_stream->priv->channel_map);
+        mixer_stream->priv->channel_map = NULL;
+
+        g_free (mixer_stream->priv->name);
+        mixer_stream->priv->name = NULL;
+
+        g_free (mixer_stream->priv->description);
+        mixer_stream->priv->description = NULL;
+
+        g_free (mixer_stream->priv->application_id);
+        mixer_stream->priv->application_id = NULL;
+
+        g_free (mixer_stream->priv->icon_name);
+        mixer_stream->priv->icon_name = NULL;
+
+        g_free (mixer_stream->priv->port);
+        mixer_stream->priv->port = NULL;
+
+        g_free (mixer_stream->priv->human_port);
+        mixer_stream->priv->human_port = NULL;
+
+        g_list_foreach (mixer_stream->priv->ports, (GFunc) free_port, NULL);
+        g_list_free (mixer_stream->priv->ports);
+        mixer_stream->priv->ports = NULL;
+
+       if (mixer_stream->priv->change_volume_op) {
+               pa_operation_unref(mixer_stream->priv->change_volume_op);
+               mixer_stream->priv->change_volume_op = NULL;
+       }
+
+        G_OBJECT_CLASS (gvc_mixer_stream_parent_class)->finalize (object);
+}
Index: gnome-control-center/panels/sound-nua/gvc-mixer-stream.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-stream.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,128 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_MIXER_STREAM_H
+#define __GVC_MIXER_STREAM_H
+
+#include <glib-object.h>
+#include "gvc-pulseaudio-fake.h"
+#include "gvc-channel-map.h"
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_STREAM         (gvc_mixer_stream_get_type ())
+#define GVC_MIXER_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_MIXER_STREAM, GvcMixerStream))
+#define GVC_MIXER_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_MIXER_STREAM, GvcMixerStreamClass))
+#define GVC_IS_MIXER_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_MIXER_STREAM))
+#define GVC_IS_MIXER_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_MIXER_STREAM))
+#define GVC_MIXER_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_MIXER_STREAM, GvcMixerStreamClass))
+
+typedef struct GvcMixerStreamPrivate GvcMixerStreamPrivate;
+
+typedef struct
+{
+        GObject                parent;
+        GvcMixerStreamPrivate *priv;
+} GvcMixerStream;
+
+typedef struct
+{
+        GObjectClass           parent_class;
+
+        /* vtable */
+        gboolean (*push_volume)     (GvcMixerStream *stream,
+                                     gpointer *operation);
+        gboolean (*change_is_muted) (GvcMixerStream *stream,
+                                     gboolean        is_muted);
+        gboolean (*change_port)     (GvcMixerStream *stream,
+                                     const char     *port);
+} GvcMixerStreamClass;
+
+typedef struct
+{
+        char *port;
+        char *human_port;
+        guint priority;
+        gboolean available;        
+} GvcMixerStreamPort;
+
+GType               gvc_mixer_stream_get_type        (void);
+
+guint               gvc_mixer_stream_get_index       (GvcMixerStream *stream);
+guint               gvc_mixer_stream_get_id          (GvcMixerStream *stream);
+const GvcChannelMap *gvc_mixer_stream_get_channel_map(GvcMixerStream *stream);
+const GvcMixerStreamPort *gvc_mixer_stream_get_port  (GvcMixerStream *stream);
+const GList *       gvc_mixer_stream_get_ports       (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_change_port     (GvcMixerStream *stream,
+                                                      const char     *port);
+
+pa_volume_t         gvc_mixer_stream_get_volume      (GvcMixerStream *stream);
+gdouble             gvc_mixer_stream_get_decibel     (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_push_volume     (GvcMixerStream *stream);
+pa_volume_t         gvc_mixer_stream_get_base_volume (GvcMixerStream *stream);
+
+gboolean            gvc_mixer_stream_get_is_muted    (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_get_can_decibel (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_change_is_muted (GvcMixerStream *stream,
+                                                      gboolean        is_muted);
+gboolean            gvc_mixer_stream_is_running      (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_name        (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_icon_name   (GvcMixerStream *stream);
+GIcon *             gvc_mixer_stream_get_gicon       (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_description (GvcMixerStream *stream);
+const char *        gvc_mixer_stream_get_application_id (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_is_event_stream (GvcMixerStream *stream);
+gboolean            gvc_mixer_stream_is_virtual      (GvcMixerStream *stream);
+gint                gvc_mixer_stream_get_card_index  (GvcMixerStream *stream);
+
+/* private */
+gboolean            gvc_mixer_stream_set_volume      (GvcMixerStream *stream,
+                                                      pa_volume_t     volume);
+gboolean            gvc_mixer_stream_set_decibel     (GvcMixerStream *stream,
+                                                      gdouble         db);
+gboolean            gvc_mixer_stream_set_is_muted    (GvcMixerStream *stream,
+                                                      gboolean        is_muted);
+gboolean            gvc_mixer_stream_set_can_decibel (GvcMixerStream *stream,
+                                                      gboolean        can_decibel);
+gboolean            gvc_mixer_stream_set_name        (GvcMixerStream *stream,
+                                                      const char     *name);
+gboolean            gvc_mixer_stream_set_description (GvcMixerStream *stream,
+                                                      const char     *description);
+gboolean            gvc_mixer_stream_set_icon_name   (GvcMixerStream *stream,
+                                                      const char     *name);
+gboolean            gvc_mixer_stream_set_is_event_stream (GvcMixerStream *stream,
+                                                          gboolean is_event_stream);
+gboolean            gvc_mixer_stream_set_is_virtual  (GvcMixerStream *stream,
+                                                      gboolean is_event_stream);
+gboolean            gvc_mixer_stream_set_application_id (GvcMixerStream *stream,
+                                                         const char *application_id);
+gboolean            gvc_mixer_stream_set_base_volume (GvcMixerStream *stream,
+                                                      pa_volume_t     base_volume);
+gboolean            gvc_mixer_stream_set_port        (GvcMixerStream *stream,
+                                                      const char     *port);
+gboolean            gvc_mixer_stream_set_ports       (GvcMixerStream *stream,
+                                                      GList          *ports);
+gboolean            gvc_mixer_stream_set_card_index  (GvcMixerStream *stream,
+                                                      gint            card_index);
+
+G_END_DECLS
+
+#endif /* __GVC_MIXER_STREAM_H */
Index: gnome-control-center/panels/sound-nua/gvc-mixer-ui-device.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-ui-device.c	2012-02-10 14:40:47.385282961 -0500
@@ -0,0 +1,612 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
+/*
+ * gvc-mixer-ui-device.c
+ * Copyright (C) Conor Curran 2011 <conor.curran@canonical.com>
+ * 
+ * gvc-mixer-ui-device.c is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * gvc-mixer-ui-device.c is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "gvc-mixer-ui-device.h"
+#include "gvc-mixer-card.h"
+
+#define GVC_MIXER_UI_DEVICE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDevicePrivate))
+
+static guint32 output_serial = 1;
+
+struct GvcMixerUIDevicePrivate
+{
+	gchar*	     		first_line_desc;
+	gchar*	     		second_line_desc;
+	gint	     		card_id; 
+	gchar*	     		port_name;
+	gint	     		stream_id;
+	guint	     		id;
+	gboolean     		port_available;
+	GList*       		supported_profiles;
+	UiDeviceDirection 	type;
+	GHashTable* 		profiles;
+	gboolean 		disable_profile_swapping;
+	gchar* 			user_preferred_profile;
+};
+
+enum
+{
+	PROP_0,
+	PROP_DESC_LINE_1,
+	PROP_DESC_LINE_2,
+	PROP_CARD_ID,
+	PROP_PORT_NAME,	
+	PROP_STREAM_ID,
+	PROP_UI_DEVICE_TYPE,
+	PROP_PORT_AVAILABLE,
+};
+
+static void     gvc_mixer_ui_device_class_init (GvcMixerUIDeviceClass *klass);
+static void     gvc_mixer_ui_device_init       (GvcMixerUIDevice      *op);
+static void     gvc_mixer_ui_device_finalize   (GObject             *object);
+
+G_DEFINE_TYPE (GvcMixerUIDevice, gvc_mixer_ui_device, G_TYPE_OBJECT);
+
+static guint32
+get_next_output_serial (void)
+{
+        guint32 serial;
+
+        serial = output_serial++;
+
+        if ((gint32)output_serial < 0) {
+                output_serial = 1;
+        }
+        return serial;
+}
+
+static void
+gvc_mixer_ui_device_get_property  (GObject       *object,
+				   guint         property_id,
+				   GValue 	 *value,
+				   GParamSpec    *pspec)
+{
+	  GvcMixerUIDevice *self = GVC_MIXER_UI_DEVICE (object);
+
+	  switch (property_id)
+		{
+		case PROP_DESC_LINE_1:
+			g_value_set_string (value, self->priv->first_line_desc);
+			break;
+		case PROP_DESC_LINE_2:
+			g_value_set_string (value, self->priv->second_line_desc);
+			break;
+		case PROP_CARD_ID:
+			g_value_set_int (value, self->priv->card_id);
+  			break;
+		case PROP_PORT_NAME:
+			g_value_set_string (value, self->priv->port_name);
+			break;
+		case PROP_STREAM_ID:
+			g_value_set_int (value, self->priv->stream_id);
+  			break;
+		case PROP_UI_DEVICE_TYPE:
+			g_value_set_uint (value, (guint)self->priv->type);
+			break;
+		case PROP_PORT_AVAILABLE:
+			g_value_set_boolean (value, self->priv->port_available);
+			break;
+		default:
+			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+			break;
+		}
+}
+
+static void
+gvc_mixer_ui_device_set_property  (GObject      *object,
+				guint         property_id,
+				const GValue *value,
+				GParamSpec   *pspec)
+{
+	  GvcMixerUIDevice *self = GVC_MIXER_UI_DEVICE (object);
+
+	  switch (property_id)
+		{
+		case PROP_DESC_LINE_1:
+			g_free (self->priv->first_line_desc);
+			self->priv->first_line_desc = g_value_dup_string (value);
+			/*g_print ("gvc-mixer-output-set-property - 1st line: %s\n",
+				 self->priv->first_line_desc);*/
+			break;
+		case PROP_DESC_LINE_2:
+			g_free (self->priv->second_line_desc);
+			self->priv->second_line_desc = g_value_dup_string (value);
+			/*g_print ("gvc-mixer-output-set-property - 2nd line: %s\n",
+				 self->priv->second_line_desc);*/
+			break;	
+		case PROP_CARD_ID:
+			self->priv->card_id = g_value_get_int (value);
+			/*g_print ("gvc-mixer-output-set-property - card id: %i\n",
+				 self->priv->gvc_card_id);*/
+			break;	
+		case PROP_PORT_NAME:
+			g_free (self->priv->port_name);
+			self->priv->port_name = g_value_dup_string (value);
+			/*g_print ("gvc-mixer-output-set-property - card port name: %s\n",
+				 self->priv->card_port_name);*/
+			break;	
+		case PROP_STREAM_ID:
+			self->priv->stream_id = g_value_get_int (value);
+			/*g_print ("gvc-mixer-output-set-property - sink id: %i\n",
+				 self->priv->stream_id);*/
+			break;	
+		case PROP_UI_DEVICE_TYPE:
+			self->priv->type = (UiDeviceDirection)g_value_get_uint (value);
+			break;
+		case PROP_PORT_AVAILABLE:
+			self->priv->port_available = g_value_get_boolean (value);
+			/*g_print ("gvc-mixer-output-set-property - port available %i, value passed in %i \n",
+				 self->priv->port_available, g_value_get_boolean (value));*/
+			break;			
+		default:
+			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+			break;
+	    }
+}
+
+static GObject *
+gvc_mixer_ui_device_constructor (GType                  type,
+			         guint                  n_construct_properties,
+		                 GObjectConstructParam *construct_params)
+{
+        GObject         *object;
+        GvcMixerUIDevice  *self;
+
+        object = G_OBJECT_CLASS (gvc_mixer_ui_device_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_MIXER_UI_DEVICE (object);
+        self->priv->id = get_next_output_serial ();
+        self->priv->profiles = g_hash_table_new_full (g_str_hash,
+         					      g_str_equal,
+         					      g_free,
+         					      NULL);
+	self->priv->stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+	self->priv->card_id = GVC_MIXER_UI_DEVICE_INVALID;
+	self->priv->port_name = NULL;
+	self->priv->disable_profile_swapping = FALSE;
+	self->priv->user_preferred_profile = NULL;
+        return object;
+}
+
+static void
+gvc_mixer_ui_device_init (GvcMixerUIDevice *object)
+{
+	object->priv  = GVC_MIXER_UI_DEVICE_GET_PRIVATE (object);	
+}
+
+static void 
+gvc_mixer_ui_device_dispose (GObject *object)
+{
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_MIXER_UI_DEVICE (object));
+
+	GvcMixerUIDevice *device;
+	device = GVC_MIXER_UI_DEVICE (object);
+	
+	if (device->priv->port_name != NULL){
+		g_free (device->priv->port_name);
+		device->priv->port_name = NULL;
+	}
+	if (device->priv->first_line_desc != NULL){		
+		g_free (device->priv->first_line_desc);
+		device->priv->first_line_desc = NULL;
+	}
+	if (device->priv->second_line_desc != NULL){
+		g_free (device->priv->second_line_desc);
+		device->priv->second_line_desc = NULL;
+	}
+	if (device->priv->profiles != NULL){
+		g_hash_table_destroy (device->priv->profiles);
+		device->priv->profiles = NULL;
+	}
+	if (device->priv->user_preferred_profile != NULL){
+		g_free (device->priv->user_preferred_profile);
+		device->priv->user_preferred_profile = NULL;
+	}
+    G_OBJECT_CLASS (gvc_mixer_ui_device_parent_class)->dispose (object);	
+}
+
+static void
+gvc_mixer_ui_device_finalize (GObject *object)
+{
+	G_OBJECT_CLASS (gvc_mixer_ui_device_parent_class)->finalize (object);
+}
+
+static void
+gvc_mixer_ui_device_class_init (GvcMixerUIDeviceClass *klass)
+{
+	GObjectClass* object_class = G_OBJECT_CLASS (klass);
+
+	object_class->constructor = gvc_mixer_ui_device_constructor;
+	object_class->dispose = gvc_mixer_ui_device_dispose;        
+	object_class->finalize = gvc_mixer_ui_device_finalize;
+	object_class->set_property = gvc_mixer_ui_device_set_property;
+	object_class->get_property = gvc_mixer_ui_device_get_property;
+
+	GParamSpec *pspec;
+
+	pspec = g_param_spec_string ("description",
+				"Description construct prop",
+				"Set first line description",
+				"no-name-set",
+				G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_DESC_LINE_1,
+					 pspec);	
+				 
+	pspec = g_param_spec_string ("origin",
+				 "origin construct prop",
+				 "Set second line description name",
+				 "no-name-set",
+				  G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					PROP_DESC_LINE_2,
+					pspec);	
+
+	pspec = g_param_spec_int ("card-id",
+				  "Card id from pulse",
+				  "Set/Get card id",
+				  -1 ,
+				  1000 ,
+				  GVC_MIXER_UI_DEVICE_INVALID,
+				  G_PARAM_READWRITE);
+
+	g_object_class_install_property (object_class,
+					 PROP_CARD_ID,
+					 pspec);
+				 				 
+	pspec = g_param_spec_string ("port-name",
+				 "port-name construct prop",
+				 "Set port-name",
+				 NULL,
+				 G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_PORT_NAME,
+					 pspec);	
+
+	pspec = g_param_spec_int ("stream-id",
+				  "stream id assigned by gvc-stream",
+				  "Set/Get stream id",
+				  -1,  
+				   10000, 
+				   GVC_MIXER_UI_DEVICE_INVALID,
+				   G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_STREAM_ID,
+					 pspec);
+
+	pspec = g_param_spec_uint ("type",
+				   "ui-device type",
+				   "determine whether its an input and output",
+     				0,
+				    1,
+				    0,
+				    G_PARAM_READWRITE);
+	g_object_class_install_property (object_class,
+					 PROP_UI_DEVICE_TYPE,
+					 pspec);
+
+	pspec = g_param_spec_boolean ( "port-available",
+					"available",
+					"determine whether this port is available",
+					FALSE,
+					G_PARAM_READWRITE);				       
+	g_object_class_install_property (object_class,
+					PROP_PORT_AVAILABLE,
+					pspec);        
+				 
+	g_type_class_add_private (klass, sizeof (GvcMixerUIDevicePrivate));					 				
+}
+
+// TODO
+// Optimise so as on the first pass you can 'choose' which profiles to hold on to and
+// which are useles because they are essentially duplicates.
+void
+gvc_mixer_ui_device_set_profiles (GvcMixerUIDevice *device, const GList *in_profiles)
+{
+	gint profile_count;
+	GList* t;
+	GHashTable *profile_descriptions;
+	if (in_profiles == NULL)
+		return;
+
+	device->priv->supported_profiles = in_profiles;
+		
+	profile_count = g_list_length (in_profiles);
+	profile_descriptions = g_hash_table_new_full (g_str_hash,
+	 					      g_str_equal,
+	 					      g_free,
+	 					      g_free);
+
+	//debug
+	gboolean is_input = device->priv->type != UiDeviceOutput;
+	gboolean is_output = device->priv->type == UiDeviceOutput;
+
+	// Store each profile in a hash with the shortened relevant string as the key
+	for (t = in_profiles; t != NULL; t = t->next) {
+
+		GvcMixerCardProfile* p;
+		p = t->data;
+
+
+		//g_print ("\n check if this %s has already passed %i", p->profile, g_hash_table_contains (profile_descriptions, p->profile));
+
+		gchar** modified;
+
+		modified = g_strsplit (p->profile, "+", 0);	
+		guint count;
+		
+		count = g_strv_length (modified);
+
+		if (count == 1){
+			g_print ("\n Single profile, %i, key %s against value %s for device %s \n",
+				 is_input,
+				 p->profile,
+				 modified[0],
+				 gvc_mixer_ui_device_get_description (device));
+			g_hash_table_insert (profile_descriptions,
+			 		     g_strdup (p->profile),
+			 		     g_strdup (modified[0]));
+			g_strfreev (modified);
+			continue;	
+		}
+
+		if (device->priv->type == UiDeviceOutput) {
+			if (g_str_has_prefix (modified[0], "output")){
+				g_print ("\n Found an output profile - storing key %s against value %s for device %s \n",
+					   p->profile, modified[0], gvc_mixer_ui_device_get_description (device));
+				g_hash_table_insert (profile_descriptions,
+				 		     g_strdup (p->profile),
+				 		     g_strdup (modified[0]));
+			}
+		}
+		else{
+			if (g_str_has_prefix (modified[1], "input")){
+				g_print ("\n Found an input profile - storing key %s against value %s for device %s \n",
+					  p->profile, modified[1], gvc_mixer_ui_device_get_description (device));
+				g_hash_table_insert (profile_descriptions,
+				 		     g_strdup (p->profile),
+				 		     g_strdup (modified[1]));
+			}
+		}
+		g_strfreev (modified);				
+	}
+	
+	// Determine if we want allow the user to change the profile from the device
+	// i.e. is there any actual choice or just much of the same thing from the 
+	// context of the direction on this device.
+	gboolean identical = TRUE;
+	GList *shortened_profiles;
+	shortened_profiles = g_hash_table_get_values (profile_descriptions);
+	
+	for (t = shortened_profiles; t != NULL; t = t->next) {
+		gchar* prof;
+		prof = t->data;
+		if (g_list_next (t) != NULL){
+			gchar* next_prof;
+			GList* n;
+			n = g_list_next (t);
+			next_prof = n->data;
+			identical = g_strcmp0 (prof, next_prof) == 0; 
+		}
+		if (!identical){
+			break;
+		}
+	}
+	g_list_free (shortened_profiles);
+
+	g_print ("\n device->priv->disable_profile_swapping = %i \n", 
+		  identical);
+
+	device->priv->disable_profile_swapping = identical;
+	GList *x;
+	GList *y;
+
+	if (!identical) {
+		for (y = in_profiles; y != NULL; y = y->next) {
+			GvcMixerCardProfile* p;
+			p = y->data;
+			gchar* short_name;
+			short_name = g_hash_table_lookup (profile_descriptions, p->profile);
+
+			g_print ("\n\n has this profile passed already- %s , %s \n\n", short_name, p->profile);
+
+			for (x = in_profiles; x != NULL; x = x->next) {
+				GvcMixerCardProfile* l;
+				l = x->data;
+				gchar* other_modified;
+								
+				if (g_strcmp0 (p->profile, "off") == 0){
+					g_print ("\n\n Bluetooth off profile - ignore it");
+					continue;
+				}
+				
+				if (g_hash_table_contains (device->priv->profiles, short_name) == TRUE){
+					g_print ("\n\n SHORT NAME already populated move on - %s \n\n", p->profile);
+					continue;				
+				}
+
+				other_modified = g_hash_table_lookup (profile_descriptions, l->profile);
+				
+				if (g_strcmp0 (other_modified, short_name) == 0){
+					if (sort_profiles (p, l) > 0){
+						g_hash_table_insert (device->priv->profiles, short_name, p);
+					}
+					else{
+						g_hash_table_insert (device->priv->profiles, short_name, l);						
+					}				
+				}
+			}
+		}
+	}
+	else{
+		// If it's identical we want to find the profile that is relevant to the context of the device
+		// For the sake of the UI - avoid user confusion.
+		GList* profile_descriptions_keys;
+		profile_descriptions_keys = g_hash_table_get_keys (profile_descriptions);
+		GList* c;
+		gboolean matched = FALSE;
+		for (c = profile_descriptions_keys; c != NULL; c = c->next) {
+			gchar* prof;
+			prof = c->data;
+			gchar* shortened_value;
+			shortened_value = g_hash_table_lookup (profile_descriptions, prof);
+			if (g_strcmp0 (shortened_value, prof) == 0){
+				GList *j;
+				for (j = in_profiles; j != NULL; j = j->next) {
+					GvcMixerCardProfile* l;
+					l = j->data;
+					if (g_strcmp0 (l->profile, prof) == 0){
+						g_hash_table_insert (device->priv->profiles, 
+								     "tmp",
+								     l);	
+						matched = TRUE;
+					}
+				}			
+			}
+		}
+		// We can't find the ideal profile for the insensitive combo
+		// just pick the one with the highest priority.
+		if (!matched){	
+			GvcMixerCardProfile* p = NULL;
+			// Since the profile list was already sorted on card port creation
+			// we just need to take the last one as this will have the highest priority
+			p = g_list_last (in_profiles)->data;
+			if (p != NULL)
+				g_hash_table_insert (device->priv->profiles, 
+						     "tmp",
+						      p);			
+		}
+	}
+
+	/* DEBUG */
+	GList* final_keys;
+	final_keys = g_hash_table_get_keys (device->priv->profiles);
+	GList* o;
+	g_print ("\n\n Profile population \n FOR DEVICE %s", gvc_mixer_ui_device_get_description (device));
+	for (o = final_keys; o != NULL; o = o->next){
+		gchar* key;
+		key = o->data;
+		GvcMixerCardProfile* l;
+		l = g_hash_table_lookup (device->priv->profiles, key);
+		g_print ("\n key %s against \n profile %s \n", 
+			key,
+			l->profile);
+	}
+	g_hash_table_destroy (profile_descriptions);
+}
+
+gboolean
+gvc_mixer_ui_device_determine_profile_sensitivity (GvcMixerUIDevice *device)
+{
+	return device->priv->disable_profile_swapping;
+}
+
+GList*
+gvc_mixer_ui_device_get_profiles (GvcMixerUIDevice *device)
+{
+	return g_hash_table_get_values (device->priv->profiles); 
+}
+
+GList*
+gvc_mixer_ui_device_get_supported_profiles (GvcMixerUIDevice *device)
+{
+	return device->priv->supported_profiles;
+}
+
+guint
+gvc_mixer_ui_device_get_id (GvcMixerUIDevice *op)
+{
+        g_return_val_if_fail (GVC_IS_MIXER_UI_DEVICE (op), 0);
+        return op->priv->id;
+}
+
+gint
+gvc_mixer_ui_device_get_stream_id (GvcMixerUIDevice *op)
+{
+	gint sink_id;
+	g_object_get (G_OBJECT (op),
+		      "stream-id", &sink_id, NULL);
+        return sink_id;			
+}
+
+void					
+gvc_mixer_ui_device_invalidate_stream (GvcMixerUIDevice *self)
+{
+	self->priv->stream_id = GVC_MIXER_UI_DEVICE_INVALID;
+}
+
+
+const gchar*
+gvc_mixer_ui_device_get_description (GvcMixerUIDevice *op)
+{
+	return op->priv->first_line_desc;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_origin (GvcMixerUIDevice *op)
+{
+	return op->priv->second_line_desc;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_user_preferred_profile (GvcMixerUIDevice *dev)
+{
+	return dev->priv->user_preferred_profile;
+}
+
+const gchar*
+gvc_mixer_ui_device_get_top_priority_profile (GvcMixerUIDevice *dev)
+{
+	GList *last;
+	last = g_list_last (dev->priv->supported_profiles);
+	GvcMixerCardProfile *profile;
+	profile = last->data;                        
+	return profile->profile;
+}
+
+void 
+gvc_mixer_ui_device_set_user_preferred_profile (GvcMixerUIDevice *device, const gchar* profile)
+{
+	if (device->priv->user_preferred_profile != NULL){
+		g_free (device->priv->user_preferred_profile);
+		device->priv->user_preferred_profile = NULL;
+	}
+	device->priv->user_preferred_profile = g_strdup (profile);
+}
+
+const gchar*
+gvc_mixer_ui_device_get_port (GvcMixerUIDevice *op)
+{
+	return op->priv->port_name;
+}
+
+gboolean
+gvc_mixer_ui_device_is_software (GvcMixerUIDevice *dev)
+{
+	return dev->priv->port_name == NULL;
+}
+
+gboolean
+gvc_mixer_ui_device_is_output (GvcMixerUIDevice *dev)
+{
+	return dev->priv->type == UiDeviceOutput;	
+}
+
Index: gnome-control-center/panels/sound-nua/gvc-mixer-ui-device.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-mixer-ui-device.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,74 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
+/*
+ * Copyright (C) Conor Curran 2011 <conor.curran@canonical.com>
+ * 
+ * This is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * gvc-mixer-output.c is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _GVC_MIXER_UI_DEVICE_H_
+#define _GVC_MIXER_UI_DEVICE_H_
+
+#include <glib-object.h>
+
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_MIXER_UI_DEVICE             (gvc_mixer_ui_device_get_type ())
+#define GVC_MIXER_UI_DEVICE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDevice))
+#define GVC_MIXER_UI_DEVICE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDeviceClass))
+#define GVC_IS_MIXER_UI_DEVICE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GVC_TYPE_MIXER_UI_DEVICE))
+#define GVC_IS_MIXER_UI_DEVICE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GVC_TYPE_MIXER_UI_DEVICE))
+#define GVC_MIXER_UI_DEVICE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GVC_TYPE_MIXER_UI_DEVICE, GvcMixerUIDeviceClass))
+#define GVC_MIXER_UI_DEVICE_INVALID          -1
+
+typedef struct GvcMixerUIDevicePrivate GvcMixerUIDevicePrivate;
+
+typedef struct
+{
+	GObjectClass parent_class;
+}GvcMixerUIDeviceClass;
+
+typedef struct
+{
+	GObject parent_instance;
+	GvcMixerUIDevicePrivate *priv;	
+}GvcMixerUIDevice;
+
+typedef enum
+{
+	UiDeviceInput,
+	UiDeviceOutput,	
+}UiDeviceDirection;
+
+GType gvc_mixer_ui_device_get_type (void) G_GNUC_CONST;
+
+guint       			gvc_mixer_ui_device_get_id                   		(GvcMixerUIDevice *dev);
+gint        			gvc_mixer_ui_device_get_stream_id            		(GvcMixerUIDevice *dev);
+const gchar*			gvc_mixer_ui_device_get_description          		(GvcMixerUIDevice *dev);
+const gchar*			gvc_mixer_ui_device_get_origin				 		(GvcMixerUIDevice *dev);
+const gchar*			gvc_mixer_ui_device_get_port				 		(GvcMixerUIDevice *dev);
+const gchar* 			gvc_mixer_ui_device_get_user_preferred_profile		(GvcMixerUIDevice *dev);
+const gchar* 			gvc_mixer_ui_device_get_top_priority_profile		(GvcMixerUIDevice *dev);
+GList*					gvc_mixer_ui_device_get_profiles 			 		(GvcMixerUIDevice *dev);
+GList*					gvc_mixer_ui_device_get_supported_profiles			(GvcMixerUIDevice *device);
+gboolean	    		gvc_mixer_ui_device_determine_profile_sensitivity 	(GvcMixerUIDevice *device);
+void					gvc_mixer_ui_device_set_profiles			 		(GvcMixerUIDevice *device, const GList *profiles);
+void 					gvc_mixer_ui_device_set_user_preferred_profile 		(GvcMixerUIDevice *device, const gchar *profile);
+void					gvc_mixer_ui_device_invalidate_stream		 		(GvcMixerUIDevice *dev);
+gboolean				gvc_mixer_ui_device_is_software_stream		 		(GvcMixerUIDevice *dev);
+
+
+G_END_DECLS
+
+#endif /* _GVC_MIXER_UI_DEVICE_H_ */
Index: gnome-control-center/panels/sound-nua/gvc-pulseaudio-fake.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-pulseaudio-fake.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,34 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_PULSEAUDIO_FAKE_H
+#define __GVC_PULSEAUDIO_FAKE_H
+
+#ifdef WITH_INTROSPECTION
+
+#ifndef PA_API_VERSION
+#define pa_channel_position_t int
+#define pa_volume_t guint32
+#define pa_context gpointer
+#endif /* PA_API_VERSION */
+
+#endif /* WITH_INTROSPECTION */
+
+#endif /* __GVC_PULSEAUDIO_FAKE_H */
Index: gnome-control-center/panels/sound-nua/gvc-sound-theme-chooser.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-sound-theme-chooser.c	2012-02-14 13:55:14.677130208 -0500
@@ -0,0 +1,856 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Bastien Nocera <hadess@hadess.net>
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <utime.h>
+#include <errno.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra-gtk.h>
+#include <libxml/tree.h>
+
+#include <gconf/gconf-client.h>
+
+#include "gvc-sound-theme-chooser.h"
+#include "sound-theme-file-utils.h"
+
+#define GVC_SOUND_THEME_CHOOSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooserPrivate))
+
+struct GvcSoundThemeChooserPrivate
+{
+        GtkWidget *treeview;
+        GtkWidget *selection_box;
+        GConfClient *client;
+        GSettings *sound_settings;
+        guint metacity_dir_id;
+        char *current_theme;
+        char *current_parent;
+};
+
+static void     gvc_sound_theme_chooser_class_init (GvcSoundThemeChooserClass *klass);
+static void     gvc_sound_theme_chooser_init       (GvcSoundThemeChooser      *sound_theme_chooser);
+static void     gvc_sound_theme_chooser_finalize   (GObject            *object);
+
+G_DEFINE_TYPE (GvcSoundThemeChooser, gvc_sound_theme_chooser, GTK_TYPE_VBOX)
+
+#define KEY_SOUNDS_SCHEMA          "org.gnome.desktop.sound"
+#define EVENT_SOUNDS_KEY           "event-sounds"
+#define INPUT_SOUNDS_KEY           "input-feedback-sounds"
+#define SOUND_THEME_KEY            "theme-name"
+
+#define KEY_METACITY_DIR           "/apps/metacity/general"
+#define AUDIO_BELL_KEY             KEY_METACITY_DIR "/audible_bell"
+
+#define DEFAULT_ALERT_ID        "__default"
+#define CUSTOM_THEME_NAME       "__custom"
+#define NO_SOUNDS_THEME_NAME    "__no_sounds"
+#define DEFAULT_THEME           "ubuntu"
+
+enum {
+        THEME_DISPLAY_COL,
+        THEME_IDENTIFIER_COL,
+        THEME_PARENT_ID_COL,
+        THEME_NUM_COLS
+};
+
+enum {
+        ALERT_DISPLAY_COL,
+        ALERT_IDENTIFIER_COL,
+        ALERT_SOUND_TYPE_COL,
+        ALERT_NUM_COLS
+};
+
+enum {
+        SOUND_TYPE_UNSET,
+        SOUND_TYPE_OFF,
+        SOUND_TYPE_DEFAULT_FROM_THEME,
+        SOUND_TYPE_BUILTIN,
+        SOUND_TYPE_CUSTOM
+};
+
+#define GVC_SOUND_SOUND    (xmlChar *) "sound"
+#define GVC_SOUND_NAME     (xmlChar *) "name"
+#define GVC_SOUND_FILENAME (xmlChar *) "filename"
+
+/* Adapted from yelp-toc-pager.c */
+static xmlChar *
+xml_get_and_trim_names (xmlNodePtr node)
+{
+        xmlNodePtr cur;
+        xmlChar *keep_lang = NULL;
+        xmlChar *value;
+        int j, keep_pri = INT_MAX;
+
+        const gchar * const * langs = g_get_language_names ();
+
+        value = NULL;
+
+        for (cur = node->children; cur; cur = cur->next) {
+                if (! xmlStrcmp (cur->name, GVC_SOUND_NAME)) {
+                        xmlChar *cur_lang = NULL;
+                        int cur_pri = INT_MAX;
+
+                        cur_lang = xmlNodeGetLang (cur);
+
+                        if (cur_lang) {
+                                for (j = 0; langs[j]; j++) {
+                                        if (g_str_equal (cur_lang, langs[j])) {
+                                                cur_pri = j;
+                                                break;
+                                        }
+                                }
+                        } else {
+                                cur_pri = INT_MAX - 1;
+                        }
+
+                        if (cur_pri <= keep_pri) {
+                                if (keep_lang)
+                                        xmlFree (keep_lang);
+                                if (value)
+                                        xmlFree (value);
+
+                                value = xmlNodeGetContent (cur);
+
+                                keep_lang = cur_lang;
+                                keep_pri = cur_pri;
+                        } else {
+                                if (cur_lang)
+                                        xmlFree (cur_lang);
+                        }
+                }
+        }
+
+        /* Delete all GVC_SOUND_NAME nodes */
+        cur = node->children;
+        while (cur) {
+                xmlNodePtr this = cur;
+                cur = cur->next;
+                if (! xmlStrcmp (this->name, GVC_SOUND_NAME)) {
+                        xmlUnlinkNode (this);
+                        xmlFreeNode (this);
+                }
+        }
+
+        return value;
+}
+
+static void
+populate_model_from_node (GvcSoundThemeChooser *chooser,
+                          GtkTreeModel         *model,
+                          xmlNodePtr            node)
+{
+        xmlNodePtr child;
+        xmlChar   *filename;
+        xmlChar   *name;
+
+        filename = NULL;
+        name = xml_get_and_trim_names (node);
+        for (child = node->children; child; child = child->next) {
+                if (xmlNodeIsText (child)) {
+                        continue;
+                }
+
+                if (xmlStrcmp (child->name, GVC_SOUND_FILENAME) == 0) {
+                        filename = xmlNodeGetContent (child);
+                } else if (xmlStrcmp (child->name, GVC_SOUND_NAME) == 0) {
+                        /* EH? should have been trimmed */
+                }
+        }
+
+        if (filename != NULL && name != NULL) {
+                gtk_list_store_insert_with_values (GTK_LIST_STORE (model),
+                                                   NULL,
+                                                   G_MAXINT,
+                                                   ALERT_IDENTIFIER_COL, filename,
+                                                   ALERT_DISPLAY_COL, name,
+                                                   ALERT_SOUND_TYPE_COL, _("Built-in"),
+                                                   -1);
+        }
+
+        xmlFree (filename);
+        xmlFree (name);
+}
+
+static void
+populate_model_from_file (GvcSoundThemeChooser *chooser,
+                          GtkTreeModel         *model,
+                          const char           *filename)
+{
+        xmlDocPtr  doc;
+        xmlNodePtr root;
+        xmlNodePtr child;
+        gboolean   exists;
+
+        exists = g_file_test (filename, G_FILE_TEST_EXISTS);
+        if (! exists) {
+                return;
+        }
+
+        doc = xmlParseFile (filename);
+        if (doc == NULL) {
+                return;
+        }
+
+        root = xmlDocGetRootElement (doc);
+
+        for (child = root->children; child; child = child->next) {
+                if (xmlNodeIsText (child)) {
+                        continue;
+                }
+                if (xmlStrcmp (child->name, GVC_SOUND_SOUND) != 0) {
+                        continue;
+                }
+
+                populate_model_from_node (chooser, model, child);
+        }
+
+        xmlFreeDoc (doc);
+}
+
+static void
+populate_model_from_dir (GvcSoundThemeChooser *chooser,
+                         GtkTreeModel         *model,
+                         const char           *dirname)
+{
+        GDir       *d;
+        const char *name;
+
+        d = g_dir_open (dirname, 0, NULL);
+        if (d == NULL) {
+                return;
+        }
+
+        while ((name = g_dir_read_name (d)) != NULL) {
+                char *path;
+
+                if (! g_str_has_suffix (name, ".xml")) {
+                        continue;
+                }
+
+                path = g_build_filename (dirname, name, NULL);
+                populate_model_from_file (chooser, model, path);
+                g_free (path);
+        }
+}
+
+static gboolean
+save_alert_sounds (GvcSoundThemeChooser  *chooser,
+                   const char            *id)
+{
+        const char *sounds[3] = { "bell-terminal", "bell-window-system", NULL };
+        char *path;
+
+        if (strcmp (id, DEFAULT_ALERT_ID) == 0) {
+                delete_old_files (sounds);
+                delete_disabled_files (sounds);
+        } else {
+                delete_old_files (sounds);
+                delete_disabled_files (sounds);
+                add_custom_file (sounds, id);
+        }
+
+        /* And poke the directory so the theme gets updated */
+        path = custom_theme_dir_path (NULL);
+        if (utime (path, NULL) != 0) {
+                g_warning ("Failed to update mtime for directory '%s': %s",
+                           path, g_strerror (errno));
+        }
+        g_free (path);
+
+        return FALSE;
+}
+
+
+static void
+update_alert_model (GvcSoundThemeChooser  *chooser,
+                    const char            *id)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (chooser->priv->treeview));
+        gtk_tree_model_get_iter_first (model, &iter);
+        do {
+                char    *this_id;
+
+                gtk_tree_model_get (model, &iter,
+                                    ALERT_IDENTIFIER_COL, &this_id,
+                                    -1);
+
+                if (strcmp (this_id, id) == 0) {
+                        GtkTreeSelection *selection;
+
+                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (chooser->priv->treeview));
+                        gtk_tree_selection_select_iter (selection, &iter);
+                }
+
+                g_free (this_id);
+        } while (gtk_tree_model_iter_next (model, &iter));
+}
+
+static void
+save_theme_name (GvcSoundThemeChooser *chooser,
+                 const char           *theme_name)
+{
+        /* If the name is empty, use "freedesktop" */
+        if (theme_name == NULL || *theme_name == '\0') {
+                theme_name = DEFAULT_THEME;
+        }
+
+        /* special case for no sounds */
+        if (strcmp (theme_name, NO_SOUNDS_THEME_NAME) == 0) {
+                g_settings_set_boolean (chooser->priv->sound_settings, EVENT_SOUNDS_KEY, FALSE);
+                return;
+        } else {
+                g_settings_set_boolean (chooser->priv->sound_settings, EVENT_SOUNDS_KEY, TRUE);
+        }
+
+        g_settings_set_string (chooser->priv->sound_settings, SOUND_THEME_KEY, theme_name);
+}
+
+static gboolean
+load_theme_file (const char *path,
+                 char      **parent)
+{
+        GKeyFile *file;
+        gboolean hidden;
+
+        file = g_key_file_new ();
+        if (g_key_file_load_from_file (file, path, G_KEY_FILE_KEEP_TRANSLATIONS, NULL) == FALSE) {
+                g_key_file_free (file);
+                return FALSE;
+        }
+        /* Don't add hidden themes to the list */
+        hidden = g_key_file_get_boolean (file, "Sound Theme", "Hidden", NULL);
+        if (!hidden) {
+                /* Save the parent theme, if there's one */
+                if (parent != NULL) {
+                        *parent = g_key_file_get_string (file,
+                                                         "Sound Theme",
+                                                         "Inherits",
+                                                         NULL);
+                }
+        }
+
+        g_key_file_free (file);
+
+        return TRUE;
+}
+
+static gboolean
+load_theme_name (const char *name,
+                 char      **parent)
+{
+        const char * const   *data_dirs;
+        const char           *data_dir;
+        char                 *path;
+        guint                 i;
+        gboolean              res;
+
+        data_dir = g_get_user_data_dir ();
+        path = g_build_filename (data_dir, "sounds", name, "index.theme", NULL);
+        res = load_theme_file (path, parent);
+        g_free (path);
+        if (res)
+                return TRUE;
+
+        data_dirs = g_get_system_data_dirs ();
+        for (i = 0; data_dirs[i] != NULL; i++) {
+                path = g_build_filename (data_dirs[i], "sounds", name, "index.theme", NULL);
+                res = load_theme_file (path, parent);
+                g_free (path);
+                if (res)
+                        return TRUE;
+        }
+
+        return FALSE;
+}
+
+static void
+update_alert (GvcSoundThemeChooser *chooser,
+              const char           *alert_id)
+{
+        gboolean      is_custom;
+        gboolean      is_default;
+        gboolean      add_custom;
+        gboolean      remove_custom;
+
+        is_custom = strcmp (chooser->priv->current_theme, CUSTOM_THEME_NAME) == 0;
+        is_default = strcmp (alert_id, DEFAULT_ALERT_ID) == 0;
+
+        /* So a few possibilities:
+         * 1. Named theme, default alert selected: noop
+         * 2. Named theme, alternate alert selected: create new custom with sound
+         * 3. Custom theme, default alert selected: remove sound and possibly custom
+         * 4. Custom theme, alternate alert selected: update custom sound
+         */
+        add_custom = FALSE;
+        remove_custom = FALSE;
+        if (! is_custom && is_default) {
+                /* remove custom just in case */
+                remove_custom = TRUE;
+        } else if (! is_custom && ! is_default) {
+                if (chooser->priv->current_parent)
+                        create_custom_theme (chooser->priv->current_parent);
+                else
+                        create_custom_theme (DEFAULT_THEME);
+                save_alert_sounds (chooser, alert_id);
+                add_custom = TRUE;
+        } else if (is_custom && is_default) {
+                save_alert_sounds (chooser, alert_id);
+                /* after removing files check if it is empty */
+                if (custom_theme_dir_is_empty ()) {
+                        remove_custom = TRUE;
+                }
+        } else if (is_custom && ! is_default) {
+                save_alert_sounds (chooser, alert_id);
+        }
+
+        if (add_custom) {
+                save_theme_name (chooser, CUSTOM_THEME_NAME);
+        } else if (remove_custom) {
+                delete_custom_theme_dir ();
+                if (is_custom) {
+                        save_theme_name (chooser, chooser->priv->current_parent);
+                }
+        }
+
+        update_alert_model (chooser, alert_id);
+}
+
+static void
+play_preview_for_id (GvcSoundThemeChooser *chooser,
+                     const char           *id)
+{
+        g_return_if_fail (id != NULL);
+
+        /* special case: for the default item on custom themes
+         * play the alert for the parent theme */
+        if (strcmp (id, DEFAULT_ALERT_ID) == 0) {
+                if (chooser->priv->current_parent != NULL) {
+                        ca_gtk_play_for_widget (GTK_WIDGET (chooser), 0,
+                                                CA_PROP_APPLICATION_NAME, _("Sound Preferences"),
+                                                CA_PROP_EVENT_ID, "bell-window-system",
+                                                CA_PROP_CANBERRA_XDG_THEME_NAME, chooser->priv->current_parent,
+                                                CA_PROP_EVENT_DESCRIPTION, _("Testing event sound"),
+                                                CA_PROP_CANBERRA_CACHE_CONTROL, "never",
+                                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+#ifdef CA_PROP_CANBERRA_ENABLE
+                                                CA_PROP_CANBERRA_ENABLE, "1",
+#endif
+                                                NULL);
+                } else {
+                        ca_gtk_play_for_widget (GTK_WIDGET (chooser), 0,
+                                                CA_PROP_APPLICATION_NAME, _("Sound Preferences"),
+                                                CA_PROP_EVENT_ID, "bell-window-system",
+                                                CA_PROP_EVENT_DESCRIPTION, _("Testing event sound"),
+                                                CA_PROP_CANBERRA_CACHE_CONTROL, "never",
+                                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+#ifdef CA_PROP_CANBERRA_ENABLE
+                                                CA_PROP_CANBERRA_ENABLE, "1",
+#endif
+                                                NULL);
+                }
+        } else {
+                ca_gtk_play_for_widget (GTK_WIDGET (chooser), 0,
+                                        CA_PROP_APPLICATION_NAME, _("Sound Preferences"),
+                                        CA_PROP_MEDIA_FILENAME, id,
+                                        CA_PROP_EVENT_DESCRIPTION, _("Testing event sound"),
+                                        CA_PROP_CANBERRA_CACHE_CONTROL, "never",
+                                        CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+#ifdef CA_PROP_CANBERRA_ENABLE
+                                        CA_PROP_CANBERRA_ENABLE, "1",
+#endif
+                                        NULL);
+
+        }
+}
+
+static void
+on_treeview_selection_changed (GtkTreeSelection     *selection,
+                               GvcSoundThemeChooser *chooser)
+{
+        GtkTreeModel *model;
+        GtkTreeIter   iter;
+        char         *id;
+
+        if (chooser->priv->treeview == NULL) {
+                return;
+        }
+
+        model = gtk_tree_view_get_model (GTK_TREE_VIEW (chooser->priv->treeview));
+
+        if (gtk_tree_selection_get_selected (selection, &model, &iter) == FALSE) {
+                return;
+        }
+
+        id = NULL;
+        gtk_tree_model_get (model, &iter,
+                            ALERT_IDENTIFIER_COL, &id,
+                            -1);
+        if (id == NULL) {
+                return;
+        }
+
+        play_preview_for_id (chooser, id);
+        update_alert (chooser, id);
+        g_free (id);
+}
+
+static gboolean
+on_treeview_button_pressed (GtkTreeView          *treeview,
+                            GdkEventButton       *event,
+                            GvcSoundThemeChooser *chooser)
+{
+        GtkTreeSelection *selection;
+        GtkTreePath      *path;
+
+        selection = gtk_tree_view_get_selection (treeview);
+        if (gtk_tree_view_get_path_at_pos (GTK_TREE_VIEW (treeview),
+                                           event->x, event->y, &path, NULL, NULL, NULL) == FALSE) {
+                return FALSE;
+        }
+
+        if (gtk_tree_selection_path_is_selected (selection, path) == FALSE) {
+                gtk_tree_path_free (path);
+                return FALSE;
+        }
+        gtk_tree_path_free (path);
+
+        on_treeview_selection_changed (selection, chooser);
+
+        return FALSE;
+}
+
+static GtkWidget *
+create_alert_treeview (GvcSoundThemeChooser *chooser)
+{
+        GtkListStore         *store;
+        GtkWidget            *treeview;
+        GtkCellRenderer      *renderer;
+        GtkTreeViewColumn    *column;
+        GtkTreeSelection     *selection;
+
+        treeview = gtk_tree_view_new ();
+        gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview), FALSE);
+        g_signal_connect (treeview,
+                          "button-press-event",
+                          G_CALLBACK (on_treeview_button_pressed),
+                          chooser);
+
+        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));
+        gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+        g_signal_connect (selection,
+                          "changed",
+                          G_CALLBACK (on_treeview_selection_changed),
+                          chooser);
+
+        /* Setup the tree model, 3 columns:
+         * - display name
+         * - sound id
+         * - sound type
+         */
+        store = gtk_list_store_new (ALERT_NUM_COLS,
+                                    G_TYPE_STRING,
+                                    G_TYPE_STRING,
+                                    G_TYPE_STRING);
+
+        gtk_list_store_insert_with_values (store,
+                                           NULL,
+                                           G_MAXINT,
+                                           ALERT_IDENTIFIER_COL, DEFAULT_ALERT_ID,
+                                           ALERT_DISPLAY_COL, _("Default"),
+                                           ALERT_SOUND_TYPE_COL, _("From theme"),
+                                           -1);
+
+        populate_model_from_dir (chooser, GTK_TREE_MODEL (store), SOUND_SET_DIR);
+
+        gtk_tree_view_set_model (GTK_TREE_VIEW (treeview),
+                                 GTK_TREE_MODEL (store));
+
+        renderer = gtk_cell_renderer_text_new ();
+        column = gtk_tree_view_column_new_with_attributes (_("Name"),
+                                                           renderer,
+                                                           "text", ALERT_DISPLAY_COL,
+                                                           NULL);
+        gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
+
+        return treeview;
+}
+
+static int
+get_file_type (const char *sound_name,
+               char      **linked_name)
+{
+        char *name, *filename;
+
+        *linked_name = NULL;
+
+        name = g_strdup_printf ("%s.disabled", sound_name);
+        filename = custom_theme_dir_path (name);
+        g_free (name);
+
+        if (g_file_test (filename, G_FILE_TEST_IS_REGULAR) != FALSE) {
+                g_free (filename);
+                return SOUND_TYPE_OFF;
+        }
+        g_free (filename);
+
+        /* We only check for .ogg files because those are the
+         * only ones we create */
+        name = g_strdup_printf ("%s.ogg", sound_name);
+        filename = custom_theme_dir_path (name);
+        g_free (name);
+
+        if (g_file_test (filename, G_FILE_TEST_IS_SYMLINK) != FALSE) {
+                *linked_name = g_file_read_link (filename, NULL);
+                g_free (filename);
+                return SOUND_TYPE_CUSTOM;
+        }
+        g_free (filename);
+
+        return SOUND_TYPE_BUILTIN;
+}
+
+static void
+update_alerts_from_theme_name (GvcSoundThemeChooser *chooser,
+                               const char           *name)
+{
+        if (strcmp (name, CUSTOM_THEME_NAME) != 0) {
+                /* reset alert to default */
+                update_alert (chooser, DEFAULT_ALERT_ID);
+        } else {
+                int   sound_type;
+                char *linkname;
+
+                linkname = NULL;
+                sound_type = get_file_type ("bell-terminal", &linkname);
+                g_debug ("Found link: %s", linkname);
+                if (sound_type == SOUND_TYPE_CUSTOM) {
+                        update_alert (chooser, linkname);
+                }
+        }
+}
+
+static void
+update_theme (GvcSoundThemeChooser *chooser)
+{
+        gboolean     events_enabled;
+        char        *last_theme;
+
+        events_enabled = g_settings_get_boolean (chooser->priv->sound_settings, EVENT_SOUNDS_KEY);
+
+        last_theme = chooser->priv->current_theme;
+        if (events_enabled) {
+                chooser->priv->current_theme = g_settings_get_string (chooser->priv->sound_settings, SOUND_THEME_KEY);
+        } else {
+                chooser->priv->current_theme = g_strdup (NO_SOUNDS_THEME_NAME);
+        }
+
+        if (g_strcmp0 (last_theme, chooser->priv->current_theme) != 0) {
+                g_free (chooser->priv->current_parent);
+                if (load_theme_name (chooser->priv->current_theme,
+                                     &chooser->priv->current_parent) == FALSE) {
+                        g_free (chooser->priv->current_theme);
+                        chooser->priv->current_theme = g_strdup (DEFAULT_THEME);
+                        load_theme_name (DEFAULT_THEME,
+                                         &chooser->priv->current_parent);
+                }
+        }
+        g_free (last_theme);
+
+        gtk_widget_set_sensitive (chooser->priv->selection_box, events_enabled);
+
+        update_alerts_from_theme_name (chooser, chooser->priv->current_theme);
+}
+
+static GObject *
+gvc_sound_theme_chooser_constructor (GType                  type,
+                                     guint                  n_construct_properties,
+                                     GObjectConstructParam *construct_params)
+{
+        GObject              *object;
+        GvcSoundThemeChooser *self;
+
+        object = G_OBJECT_CLASS (gvc_sound_theme_chooser_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        self = GVC_SOUND_THEME_CHOOSER (object);
+
+        update_theme (self);
+
+        return object;
+}
+
+static void
+gvc_sound_theme_chooser_class_init (GvcSoundThemeChooserClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_sound_theme_chooser_constructor;
+        object_class->finalize = gvc_sound_theme_chooser_finalize;
+
+        g_type_class_add_private (klass, sizeof (GvcSoundThemeChooserPrivate));
+}
+
+static void
+on_sound_settings_changed (GSettings            *settings,
+                           const char           *key,
+                           GvcSoundThemeChooser *chooser)
+{
+        if (strcmp (key, EVENT_SOUNDS_KEY) == 0) {
+                update_theme (chooser);
+        } else if (strcmp (key, SOUND_THEME_KEY) == 0) {
+                update_theme (chooser);
+        } else if (strcmp (key, INPUT_SOUNDS_KEY) == 0) {
+                update_theme (chooser);
+        }
+}
+
+static void
+on_key_changed (GConfClient          *client,
+                guint                 cnxn_id,
+                GConfEntry           *entry,
+                GvcSoundThemeChooser *chooser)
+{
+        const char *key;
+
+        key = gconf_entry_get_key (entry);
+
+        if (! g_str_has_prefix (key, KEY_METACITY_DIR)) {
+                return;
+        }
+
+        if (strcmp (key, AUDIO_BELL_KEY) == 0) {
+                update_theme (chooser);
+        }
+}
+
+static void
+setup_list_size_constraint (GtkWidget *widget,
+                            GtkWidget *to_size)
+{
+        GtkRequisition req;
+        int            max_height;
+
+        /* constrain height to be the tree height up to a max */
+        max_height = (gdk_screen_get_height (gtk_widget_get_screen (widget))) / 4;
+
+        gtk_widget_get_preferred_size (to_size, NULL, &req);
+
+        gtk_scrolled_window_set_min_content_height (GTK_SCROLLED_WINDOW (widget),
+                                                    MIN (req.height, max_height));
+}
+
+static void
+gvc_sound_theme_chooser_init (GvcSoundThemeChooser *chooser)
+{
+        GtkWidget   *box;
+        GtkWidget   *label;
+        GtkWidget   *scrolled_window;
+        GtkWidget   *alignment;
+        char        *str;
+
+        chooser->priv = GVC_SOUND_THEME_CHOOSER_GET_PRIVATE (chooser);
+
+        chooser->priv->client = gconf_client_get_default ();
+        chooser->priv->sound_settings = g_settings_new (KEY_SOUNDS_SCHEMA);
+
+        str = g_strdup_printf ("<b>%s</b>", _("C_hoose an alert sound:"));
+        chooser->priv->selection_box = box = gtk_frame_new (str);
+        g_free (str);
+        label = gtk_frame_get_label_widget (GTK_FRAME (box));
+        gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+        gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
+        gtk_frame_set_shadow_type (GTK_FRAME (box), GTK_SHADOW_NONE);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 6, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (alignment), box);
+        gtk_box_pack_start (GTK_BOX (chooser), alignment, TRUE, TRUE, 6);
+
+        alignment = gtk_alignment_new (0, 0, 1, 1);
+        gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 6, 0, 0, 0);
+        gtk_container_add (GTK_CONTAINER (box), alignment);
+
+        chooser->priv->treeview = create_alert_treeview (chooser);
+        gtk_label_set_mnemonic_widget (GTK_LABEL (label), chooser->priv->treeview);
+
+        scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+        setup_list_size_constraint (scrolled_window, chooser->priv->treeview);
+
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+                                        GTK_POLICY_NEVER,
+                                        GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolled_window),
+                                             GTK_SHADOW_IN);
+        gtk_container_add (GTK_CONTAINER (scrolled_window), chooser->priv->treeview);
+        gtk_container_add (GTK_CONTAINER (alignment), scrolled_window);
+
+        g_signal_connect (G_OBJECT (chooser->priv->sound_settings), "changed",
+                          G_CALLBACK (on_sound_settings_changed), chooser);
+        gconf_client_add_dir (chooser->priv->client, KEY_METACITY_DIR,
+                              GCONF_CLIENT_PRELOAD_ONELEVEL,
+                              NULL);
+        chooser->priv->metacity_dir_id = gconf_client_notify_add (chooser->priv->client,
+                                                                  KEY_METACITY_DIR,
+                                                                  (GConfClientNotifyFunc)on_key_changed,
+                                                                  chooser, NULL, NULL);
+}
+
+static void
+gvc_sound_theme_chooser_finalize (GObject *object)
+{
+        GvcSoundThemeChooser *sound_theme_chooser;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_SOUND_THEME_CHOOSER (object));
+
+        sound_theme_chooser = GVC_SOUND_THEME_CHOOSER (object);
+
+        if (sound_theme_chooser->priv != NULL) {
+                if (sound_theme_chooser->priv->metacity_dir_id > 0) {
+                        gconf_client_notify_remove (sound_theme_chooser->priv->client,
+                                                    sound_theme_chooser->priv->metacity_dir_id);
+                        sound_theme_chooser->priv->metacity_dir_id = 0;
+                }
+                g_object_unref (sound_theme_chooser->priv->client);
+                g_object_unref (sound_theme_chooser->priv->sound_settings);
+                sound_theme_chooser->priv->client = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_sound_theme_chooser_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_sound_theme_chooser_new (void)
+{
+        GObject *chooser;
+        chooser = g_object_new (GVC_TYPE_SOUND_THEME_CHOOSER,
+                                "spacing", 6,
+                                NULL);
+        return GTK_WIDGET (chooser);
+}
Index: gnome-control-center/panels/sound-nua/gvc-sound-theme-chooser.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-sound-theme-chooser.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_SOUND_THEME_CHOOSER_H
+#define __GVC_SOUND_THEME_CHOOSER_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_SOUND_THEME_CHOOSER         (gvc_sound_theme_chooser_get_type ())
+#define GVC_SOUND_THEME_CHOOSER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooser))
+#define GVC_SOUND_THEME_CHOOSER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooserClass))
+#define GVC_IS_SOUND_THEME_CHOOSER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_SOUND_THEME_CHOOSER))
+#define GVC_IS_SOUND_THEME_CHOOSER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_SOUND_THEME_CHOOSER))
+#define GVC_SOUND_THEME_CHOOSER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_SOUND_THEME_CHOOSER, GvcSoundThemeChooserClass))
+
+typedef struct GvcSoundThemeChooserPrivate GvcSoundThemeChooserPrivate;
+
+typedef struct
+{
+        GtkVBox                      parent;
+        GvcSoundThemeChooserPrivate *priv;
+} GvcSoundThemeChooser;
+
+typedef struct
+{
+        GtkVBoxClass          parent_class;
+} GvcSoundThemeChooserClass;
+
+GType               gvc_sound_theme_chooser_get_type            (void);
+
+GtkWidget *         gvc_sound_theme_chooser_new                 (void);
+
+G_END_DECLS
+
+#endif /* __GVC_SOUND_THEME_CHOOSER_H */
Index: gnome-control-center/panels/sound-nua/gvc-speaker-test.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-speaker-test.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,531 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Bastien Nocera
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+#include <canberra.h>
+#include <canberra-gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-speaker-test.h"
+#include "gvc-mixer-stream.h"
+/* #include "gvc-mixer-card.h" */
+
+#define GVC_SPEAKER_TEST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTestPrivate))
+
+struct GvcSpeakerTestPrivate
+{
+        GtkWidget       *channel_controls[PA_CHANNEL_POSITION_MAX];
+        ca_context      *canberra;
+        GvcMixerStream  *stream;
+        GvcMixerControl *control;
+};
+
+enum {
+        COL_NAME,
+        COL_HUMAN_NAME,
+        NUM_COLS
+};
+
+enum {
+        PROP_0,
+        PROP_STREAM,
+        PROP_CONTROL
+};
+
+static void     gvc_speaker_test_class_init (GvcSpeakerTestClass *klass);
+static void     gvc_speaker_test_init       (GvcSpeakerTest      *speaker_test);
+static void     gvc_speaker_test_finalize   (GObject            *object);
+static void     update_channel_map          (GvcSpeakerTest *speaker_test);
+
+G_DEFINE_TYPE (GvcSpeakerTest, gvc_speaker_test, GTK_TYPE_TABLE)
+
+static const int position_table[] = {
+        /* Position, X, Y */
+        PA_CHANNEL_POSITION_FRONT_LEFT, 0, 0,
+        PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER, 1, 0,
+        PA_CHANNEL_POSITION_FRONT_CENTER, 2, 0,
+        PA_CHANNEL_POSITION_MONO, 2, 0,
+        PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER, 3, 0,
+        PA_CHANNEL_POSITION_FRONT_RIGHT, 4, 0,
+        PA_CHANNEL_POSITION_SIDE_LEFT, 0, 1,
+        PA_CHANNEL_POSITION_SIDE_RIGHT, 4, 1,
+        PA_CHANNEL_POSITION_REAR_LEFT, 0, 2,
+        PA_CHANNEL_POSITION_REAR_CENTER, 2, 2,
+        PA_CHANNEL_POSITION_REAR_RIGHT, 4, 2,
+        PA_CHANNEL_POSITION_LFE, 3, 2
+};
+
+static void
+gvc_speaker_test_set_property (GObject       *object,
+                               guint          prop_id,
+                               const GValue  *value,
+                               GParamSpec    *pspec)
+{
+        GvcSpeakerTest *self = GVC_SPEAKER_TEST (object);
+
+        switch (prop_id) {
+        case PROP_STREAM:
+                self->priv->stream = g_value_dup_object (value);
+                if (self->priv->control != NULL)
+                        update_channel_map (self);
+                break;
+        case PROP_CONTROL:
+                self->priv->control = g_value_dup_object (value);
+                if (self->priv->stream != NULL)
+                        update_channel_map (self);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_speaker_test_get_property (GObject     *object,
+                               guint        prop_id,
+                               GValue      *value,
+                               GParamSpec  *pspec)
+{
+        GvcSpeakerTest *self = GVC_SPEAKER_TEST (object);
+
+        switch (prop_id) {
+        case PROP_STREAM:
+                g_value_set_object (value, self->priv->stream);
+                break;
+        case PROP_CONTROL:
+                g_value_set_object (value, self->priv->control);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_speaker_test_class_init (GvcSpeakerTestClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gvc_speaker_test_finalize;
+        object_class->set_property = gvc_speaker_test_set_property;
+        object_class->get_property = gvc_speaker_test_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_STREAM,
+                                         g_param_spec_object ("stream",
+                                                              "stream",
+                                                              "The stream",
+                                                              GVC_TYPE_MIXER_STREAM,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_CONTROL,
+                                         g_param_spec_object ("control",
+                                                              "control",
+                                                              "The mixer controller",
+                                                              GVC_TYPE_MIXER_CONTROL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT_ONLY));
+        g_type_class_add_private (klass, sizeof (GvcSpeakerTestPrivate));
+}
+
+static const char *
+sound_name (pa_channel_position_t position)
+{
+        switch (position) {
+        case PA_CHANNEL_POSITION_FRONT_LEFT:
+                return "audio-channel-front-left";
+        case PA_CHANNEL_POSITION_FRONT_RIGHT:
+                return "audio-channel-front-right";
+        case PA_CHANNEL_POSITION_FRONT_CENTER:
+                return "audio-channel-front-center";
+        case PA_CHANNEL_POSITION_REAR_LEFT:
+                return "audio-channel-rear-left";
+        case PA_CHANNEL_POSITION_REAR_RIGHT:
+                return "audio-channel-rear-right";
+        case PA_CHANNEL_POSITION_REAR_CENTER:
+                return "audio-channel-rear-center";
+        case PA_CHANNEL_POSITION_LFE:
+                return "audio-channel-lfe";
+        case PA_CHANNEL_POSITION_SIDE_LEFT:
+                return "audio-channel-side-left";
+        case PA_CHANNEL_POSITION_SIDE_RIGHT:
+                return "audio-channel-side-right";
+        default:
+                return NULL;
+        }
+}
+
+static const char *
+icon_name (pa_channel_position_t position, gboolean playing)
+{
+        switch (position) {
+        case PA_CHANNEL_POSITION_FRONT_LEFT:
+                return playing ? "audio-speaker-left-testing" : "audio-speaker-left";
+        case PA_CHANNEL_POSITION_FRONT_RIGHT:
+                return playing ? "audio-speaker-right-testing" : "audio-speaker-right";
+        case PA_CHANNEL_POSITION_FRONT_CENTER:
+                return playing ? "audio-speaker-center-testing" : "audio-speaker-center";
+        case PA_CHANNEL_POSITION_REAR_LEFT:
+                return playing ? "audio-speaker-left-back-testing" : "audio-speaker-left-back";
+        case PA_CHANNEL_POSITION_REAR_RIGHT:
+                return playing ? "audio-speaker-right-back-testing" : "audio-speaker-right-back";
+        case PA_CHANNEL_POSITION_REAR_CENTER:
+                return playing ? "audio-speaker-center-back-testing" : "audio-speaker-center-back";
+        case PA_CHANNEL_POSITION_LFE:
+                return playing ? "audio-subwoofer-testing" : "audio-subwoofer";
+        case PA_CHANNEL_POSITION_SIDE_LEFT:
+                return playing ? "audio-speaker-left-side-testing" : "audio-speaker-left-side";
+        case PA_CHANNEL_POSITION_SIDE_RIGHT:
+                return playing ? "audio-speaker-right-side-testing" : "audio-speaker-right-side";
+        default:
+                return NULL;
+        }
+}
+
+static void
+update_button (GtkWidget *control)
+{
+        GtkWidget *button;
+        GtkWidget *image;
+        pa_channel_position_t position;
+        gboolean playing;
+
+        button = g_object_get_data (G_OBJECT (control), "button");
+        image = g_object_get_data (G_OBJECT (control), "image");
+        position = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "position"));
+        playing = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "playing"));
+        gtk_button_set_label (GTK_BUTTON (button), playing ? _("Stop") : _("Test"));
+        gtk_image_set_from_icon_name (GTK_IMAGE (image), icon_name (position, playing), GTK_ICON_SIZE_DIALOG);
+}
+
+static const char *
+pretty_position (pa_channel_position_t position)
+{
+        if (position == PA_CHANNEL_POSITION_LFE)
+                return N_("Subwoofer");
+
+        return pa_channel_position_to_pretty_string (position);
+}
+
+static gboolean
+idle_cb (GtkWidget *control)
+{
+        if (control == NULL)
+                return FALSE;
+
+        /* This is called in the background thread, hence
+         * forward to main thread via idle callback */
+        g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(FALSE));
+        update_button (control);
+
+        return FALSE;
+}
+
+static void
+finish_cb (ca_context *c, uint32_t id, int error_code, void *userdata)
+{
+        GtkWidget *control = (GtkWidget *) userdata;
+
+        if (error_code == CA_ERROR_DESTROYED || control == NULL)
+                return;
+        g_idle_add ((GSourceFunc) idle_cb, control);
+}
+
+static void
+on_test_button_clicked (GtkButton *button,
+                        GtkWidget *control)
+{
+        gboolean playing;
+        ca_context *canberra;
+
+        canberra = g_object_get_data (G_OBJECT (control), "canberra");
+
+        ca_context_cancel (canberra, 1);
+
+        playing = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "playing"));
+
+        if (playing) {
+                g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(FALSE));
+        } else {
+                pa_channel_position_t position;
+                const char *name;
+                ca_proplist *proplist;
+
+                position = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (control), "position"));
+
+                ca_proplist_create (&proplist);
+                ca_proplist_sets (proplist, CA_PROP_MEDIA_ROLE, "test");
+                ca_proplist_sets (proplist, CA_PROP_MEDIA_NAME, pretty_position (position));
+                ca_proplist_sets (proplist, CA_PROP_CANBERRA_FORCE_CHANNEL,
+                                  pa_channel_position_to_string (position));
+                ca_proplist_sets (proplist, CA_PROP_CANBERRA_ENABLE, "1");
+
+                name = sound_name (position);
+                if (name != NULL) {
+                        ca_proplist_sets (proplist, CA_PROP_EVENT_ID, name);
+                        playing = ca_context_play_full (canberra, 1, proplist, finish_cb, control) >= 0;
+                }
+
+                if (!playing) {
+                        ca_proplist_sets (proplist, CA_PROP_EVENT_ID, "audio-test-signal");
+                        playing = ca_context_play_full (canberra, 1, proplist, finish_cb, control) >= 0;
+                }
+
+                if (!playing) {
+                        ca_proplist_sets(proplist, CA_PROP_EVENT_ID, "bell-window-system");
+                        playing = ca_context_play_full (canberra, 1, proplist, finish_cb, control) >= 0;
+                }
+                g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(playing));
+        }
+
+        update_button (control);
+}
+
+static GtkWidget *
+channel_control_new (ca_context *canberra, pa_channel_position_t position)
+{
+        GtkWidget *control;
+        GtkWidget *box;
+        GtkWidget *label;
+        GtkWidget *image;
+        GtkWidget *test_button;
+        const char *name;
+
+        control = gtk_vbox_new (FALSE, 6);
+        g_object_set_data (G_OBJECT (control), "playing", GINT_TO_POINTER(FALSE));
+        g_object_set_data (G_OBJECT (control), "position", GINT_TO_POINTER(position));
+        g_object_set_data (G_OBJECT (control), "canberra", canberra);
+
+        name = icon_name (position, FALSE);
+        if (name == NULL)
+                name = "audio-volume-medium";
+        image = gtk_image_new_from_icon_name (name, GTK_ICON_SIZE_DIALOG);
+        g_object_set_data (G_OBJECT (control), "image", image);
+        gtk_box_pack_start (GTK_BOX (control), image, FALSE, FALSE, 0);
+
+        label = gtk_label_new (pretty_position (position));
+        gtk_box_pack_start (GTK_BOX (control), label, FALSE, FALSE, 0);
+
+        test_button = gtk_button_new_with_label (_("Test"));
+        
+        g_signal_connect (G_OBJECT (test_button), "clicked",
+                          G_CALLBACK (on_test_button_clicked), control);
+        g_object_set_data (G_OBJECT (control), "button", test_button);
+
+        atk_object_add_relationship (gtk_widget_get_accessible (test_button),
+                                     ATK_RELATION_LABELLED_BY,
+                                     gtk_widget_get_accessible (label));
+
+        box = gtk_hbox_new (FALSE, 0);
+        gtk_box_pack_start (GTK_BOX (box), test_button, TRUE, FALSE, 0);
+        gtk_box_pack_start (GTK_BOX (control), box, FALSE, FALSE, 0);
+
+        gtk_widget_show_all (control);
+
+        return control;
+}
+
+static void
+create_channel_controls (GvcSpeakerTest *speaker_test)
+{
+        guint i;
+
+        for (i = 0; i < G_N_ELEMENTS (position_table); i += 3) {
+                speaker_test->priv->channel_controls[position_table[i]] = channel_control_new (speaker_test->priv->canberra, (pa_channel_position_t) position_table[i]);
+                gtk_table_attach (GTK_TABLE (speaker_test),
+                                  speaker_test->priv->channel_controls[position_table[i]],
+                                  position_table[i+1],
+                                  position_table[i+1]+1,
+                                  position_table[i+2],
+                                  position_table[i+2]+1,
+                                  GTK_EXPAND, GTK_EXPAND, 0, 0);
+        }
+}
+
+#if 0
+static const GvcChannelMap *
+get_channel_map_for_card (GvcMixerControl *control,
+                          GvcMixerCard    *card,
+                          char           **output_name)
+{
+        int card_index;
+        GSList *sinks, *l;
+        GvcMixerStream *stream;
+        const GvcChannelMap *map;
+
+        /* This gets the channel map for the only
+         * output for the card */
+
+        card_index = gvc_mixer_card_get_index (card);
+        if (card_index == PA_INVALID_INDEX)
+                return NULL;
+        sinks = gvc_mixer_control_get_sinks (control);
+        stream = NULL;
+        for (l = sinks; l != NULL; l = l->next) {
+                GvcMixerStream *s = l->data;
+                if (gvc_mixer_stream_get_card_index (s) == card_index) {
+                        stream = g_object_ref (s);
+                        break;
+                }
+        }
+        g_slist_free (sinks);
+
+        if (stream == NULL)
+		return NULL;
+
+        g_debug ("Found stream '%s' for card '%s'",
+                 gvc_mixer_stream_get_name (stream),
+                 gvc_mixer_card_get_name (card));
+
+        *output_name = g_strdup (gvc_mixer_stream_get_name (stream));
+        map = gvc_mixer_stream_get_channel_map (stream);
+
+        g_debug ("Got channel map '%s' for port '%s'",
+                 gvc_channel_map_get_mapping (map), *output_name);
+
+        return map;
+}
+#endif
+
+static void
+update_channel_map (GvcSpeakerTest *speaker_test)
+{
+        guint i;
+        const GvcChannelMap *map;
+        char *output_name;
+
+        g_return_if_fail (speaker_test->priv->control != NULL);
+        g_return_if_fail (speaker_test->priv->stream != NULL);
+
+        g_debug ("XXX update_channel_map called XXX");
+
+        map = gvc_mixer_stream_get_channel_map (speaker_test->priv->stream);
+/*
+        map = get_channel_map_for_stream (speaker_test->priv->control,
+                                        speaker_test->priv->stream,
+                                        &output_name);
+*/
+        g_return_if_fail (map != NULL);
+
+        ca_context_change_device (speaker_test->priv->canberra, 
+                                  gvc_mixer_stream_get_name (speaker_test->priv->stream));
+        g_free (output_name);
+
+        for (i = 0; i < G_N_ELEMENTS (position_table); i += 3) {
+                gtk_widget_set_visible (speaker_test->priv->channel_controls[position_table[i]],
+                                        gvc_channel_map_has_position(map, position_table[i]));
+        }
+}
+
+static void
+gvc_speaker_test_set_theme (ca_context *ca)
+{
+        GtkSettings *settings;
+        char *theme_name;
+
+        settings = gtk_settings_get_for_screen (gdk_screen_get_default ());
+
+        g_object_get (G_OBJECT (settings),
+                      "gtk-sound-theme-name", &theme_name,
+                      NULL);
+
+        if (theme_name)
+                ca_context_change_props (ca, CA_PROP_CANBERRA_XDG_THEME_NAME, theme_name, NULL);
+
+        g_free (theme_name);
+}
+
+static void
+gvc_speaker_test_init (GvcSpeakerTest *speaker_test)
+{
+        GtkWidget *face;
+
+        speaker_test->priv = GVC_SPEAKER_TEST_GET_PRIVATE (speaker_test);
+
+        ca_context_create (&speaker_test->priv->canberra);
+        ca_context_set_driver (speaker_test->priv->canberra, "pulse");
+        ca_context_change_props (speaker_test->priv->canberra,
+                                 CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+                                 NULL);
+        gvc_speaker_test_set_theme (speaker_test->priv->canberra);
+
+        gtk_widget_set_direction (GTK_WIDGET (speaker_test), GTK_TEXT_DIR_LTR);
+        gtk_table_resize (GTK_TABLE (speaker_test), 3, 5);
+        gtk_container_set_border_width (GTK_CONTAINER (speaker_test), 12);
+        gtk_table_set_homogeneous (GTK_TABLE (speaker_test), TRUE);
+        gtk_table_set_row_spacings (GTK_TABLE (speaker_test), 12);
+        gtk_table_set_col_spacings (GTK_TABLE (speaker_test), 12);
+
+        create_channel_controls (speaker_test);
+
+        face = gtk_image_new_from_icon_name ("face-smile", GTK_ICON_SIZE_DIALOG);
+        gtk_table_attach (GTK_TABLE (speaker_test), face,
+                          2, 3, 1, 2, GTK_EXPAND, GTK_EXPAND, 0, 0);
+        gtk_widget_show (face);
+}
+
+static void
+gvc_speaker_test_finalize (GObject *object)
+{
+        GvcSpeakerTest *speaker_test;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_SPEAKER_TEST (object));
+
+        speaker_test = GVC_SPEAKER_TEST (object);
+
+        g_return_if_fail (speaker_test->priv != NULL);
+
+        g_object_unref (speaker_test->priv->stream);
+        speaker_test->priv->stream = NULL;
+
+        g_object_unref (speaker_test->priv->control);
+        speaker_test->priv->control = NULL;
+
+        ca_context_destroy (speaker_test->priv->canberra);
+        speaker_test->priv->canberra = NULL;
+
+        G_OBJECT_CLASS (gvc_speaker_test_parent_class)->finalize (object);
+}
+
+GtkWidget *
+gvc_speaker_test_new (GvcMixerControl *control,
+                      GvcMixerStream *stream)
+{
+        GObject *speaker_test;
+
+        g_return_val_if_fail (stream != NULL, NULL);
+        g_return_val_if_fail (control != NULL, NULL);
+
+        speaker_test = g_object_new (GVC_TYPE_SPEAKER_TEST,
+                                  "stream", stream,
+                                  "control", control,
+                                  NULL);
+
+        return GTK_WIDGET (speaker_test);
+}
+
Index: gnome-control-center/panels/sound-nua/gvc-speaker-test.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-speaker-test.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_SPEAKER_TEST_H
+#define __GVC_SPEAKER_TEST_H
+
+#include <glib-object.h>
+#include <gvc-mixer-card.h>
+#include <gvc-mixer-control.h>
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_SPEAKER_TEST         (gvc_speaker_test_get_type ())
+#define GVC_SPEAKER_TEST(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTest))
+#define GVC_SPEAKER_TEST_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTestClass))
+#define GVC_IS_SPEAKER_TEST(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_SPEAKER_TEST))
+#define GVC_IS_SPEAKER_TEST_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_SPEAKER_TEST))
+#define GVC_SPEAKER_TEST_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_SPEAKER_TEST, GvcSpeakerTestClass))
+
+typedef struct GvcSpeakerTestPrivate GvcSpeakerTestPrivate;
+
+typedef struct
+{
+        GtkNotebook               parent;
+        GvcSpeakerTestPrivate *priv;
+} GvcSpeakerTest;
+
+typedef struct
+{
+        GtkNotebookClass        parent_class;
+} GvcSpeakerTestClass;
+
+GType               gvc_speaker_test_get_type            (void);
+
+GtkWidget *         gvc_speaker_test_new                 (GvcMixerControl *control,
+                                                          GvcMixerStream *stream);
+
+G_END_DECLS
+
+#endif /* __GVC_SPEAKER_TEST_H */
Index: gnome-control-center/panels/sound-nua/gvc-stream-status-icon.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-stream-status-icon.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,780 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtk.h>
+#include <pulse/pulseaudio.h>
+
+#include "gvc-mixer-stream.h"
+#include "gvc-channel-bar.h"
+#include "gvc-stream-status-icon.h"
+
+#define GVC_STREAM_STATUS_ICON_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIconPrivate))
+
+struct GvcStreamStatusIconPrivate
+{
+        char          **icon_names;
+        GvcMixerStream *mixer_stream;
+        GtkWidget      *dock;
+        GtkWidget      *bar;
+        guint           current_icon;
+        char           *display_name;
+        gboolean        thaw;
+};
+
+enum
+{
+        PROP_0,
+        PROP_DISPLAY_NAME,
+        PROP_MIXER_STREAM,
+        PROP_ICON_NAMES,
+};
+
+static void     gvc_stream_status_icon_class_init (GvcStreamStatusIconClass *klass);
+static void     gvc_stream_status_icon_init       (GvcStreamStatusIcon      *stream_status_icon);
+static void     gvc_stream_status_icon_finalize   (GObject                  *object);
+
+G_DEFINE_TYPE (GvcStreamStatusIcon, gvc_stream_status_icon, GTK_TYPE_STATUS_ICON)
+
+static void
+on_adjustment_value_changed (GtkAdjustment *adjustment,
+                             GvcStreamStatusIcon     *icon)
+{
+        gdouble volume;
+
+        if (icon->priv->thaw)
+                return;
+
+        volume = gtk_adjustment_get_value (adjustment);
+
+        /* Only push the volume if it's actually changed */
+        if (gvc_mixer_stream_set_volume(icon->priv->mixer_stream,
+                                    (pa_volume_t) round (volume)) != FALSE) {
+                gvc_mixer_stream_push_volume(icon->priv->mixer_stream);
+        }
+}
+
+static void
+update_dock (GvcStreamStatusIcon *icon)
+{
+        GtkAdjustment *adj;
+        gboolean       is_muted;
+
+        g_return_if_fail (icon);
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (icon->priv->bar)));
+
+        icon->priv->thaw = TRUE;
+        gtk_adjustment_set_value (adj,
+                                  gvc_mixer_stream_get_volume (icon->priv->mixer_stream));
+        is_muted = gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream);
+        gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (icon->priv->bar), is_muted);
+        icon->priv->thaw = FALSE;
+}
+
+static gboolean
+popup_dock (GvcStreamStatusIcon *icon,
+            guint                time)
+{
+        GdkRectangle   area;
+        GtkOrientation orientation;
+        GdkDisplay    *display;
+        GdkScreen     *screen;
+        gboolean       res;
+        int            x;
+        int            y;
+        int            monitor_num;
+        GdkRectangle   monitor;
+        GtkRequisition dock_req;
+
+        update_dock (icon);
+
+        screen = gtk_status_icon_get_screen (GTK_STATUS_ICON (icon));
+        res = gtk_status_icon_get_geometry (GTK_STATUS_ICON (icon),
+                                            &screen,
+                                            &area,
+                                            &orientation);
+        if (! res) {
+                g_warning ("Unable to determine geometry of status icon");
+                return FALSE;
+        }
+
+        /* position roughly */
+        gtk_window_set_screen (GTK_WINDOW (icon->priv->dock), screen);
+        gvc_channel_bar_set_orientation (GVC_CHANNEL_BAR (icon->priv->bar),
+                                         1 - orientation);
+
+        monitor_num = gdk_screen_get_monitor_at_point (screen, area.x, area.y);
+        gdk_screen_get_monitor_geometry (screen, monitor_num, &monitor);
+
+        gtk_container_foreach (GTK_CONTAINER (icon->priv->dock),
+                               (GtkCallback) gtk_widget_show_all, NULL);
+        gtk_widget_get_preferred_size (icon->priv->dock, &dock_req, NULL);
+
+        if (orientation == GTK_ORIENTATION_VERTICAL) {
+                if (area.x + area.width + dock_req.width <= monitor.x + monitor.width) {
+                        x = area.x + area.width;
+                } else {
+                        x = area.x - dock_req.width;
+                }
+                if (area.y + dock_req.height <= monitor.y + monitor.height) {
+                        y = area.y;
+                } else {
+                        y = monitor.y + monitor.height - dock_req.height;
+                }
+        } else {
+                if (area.y + area.height + dock_req.height <= monitor.y + monitor.height) {
+                        y = area.y + area.height;
+                } else {
+                        y = area.y - dock_req.height;
+                }
+                if (area.x + dock_req.width <= monitor.x + monitor.width) {
+                        x = area.x;
+                } else {
+                        x = monitor.x + monitor.width - dock_req.width;
+                }
+        }
+
+        gtk_window_move (GTK_WINDOW (icon->priv->dock), x, y);
+
+        /* FIXME: without this, the popup window appears as a square
+         * after changing the orientation
+         */
+        gtk_window_resize (GTK_WINDOW (icon->priv->dock), 1, 1);
+
+        gtk_widget_show_all (icon->priv->dock);
+
+        /* grab focus */
+        gtk_grab_add (icon->priv->dock);
+
+        if (gdk_pointer_grab (gtk_widget_get_window (icon->priv->dock), TRUE,
+                              GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                              GDK_POINTER_MOTION_MASK | GDK_SCROLL_MASK, NULL, NULL,
+                              time)
+            != GDK_GRAB_SUCCESS) {
+                gtk_grab_remove (icon->priv->dock);
+                gtk_widget_hide (icon->priv->dock);
+                return FALSE;
+        }
+
+        if (gdk_keyboard_grab (gtk_widget_get_window (icon->priv->dock), TRUE, time) != GDK_GRAB_SUCCESS) {
+                display = gtk_widget_get_display (icon->priv->dock);
+                gdk_display_pointer_ungrab (display, time);
+                gtk_grab_remove (icon->priv->dock);
+                gtk_widget_hide (icon->priv->dock);
+                return FALSE;
+        }
+
+        gtk_widget_grab_focus (icon->priv->dock);
+
+        return TRUE;
+}
+
+static void
+on_status_icon_activate (GtkStatusIcon       *status_icon,
+                         GvcStreamStatusIcon *icon)
+{
+        popup_dock (icon, GDK_CURRENT_TIME);
+}
+
+static void
+on_menu_mute_toggled (GtkMenuItem         *item,
+                      GvcStreamStatusIcon *icon)
+{
+        gboolean is_muted;
+        is_muted = gtk_check_menu_item_get_active (GTK_CHECK_MENU_ITEM (item));
+        gvc_channel_bar_set_is_muted (GVC_CHANNEL_BAR (icon->priv->bar), is_muted);
+}
+
+static void
+on_menu_activate_open_volume_control (GtkMenuItem *item,
+                                      GvcStreamStatusIcon   *icon)
+{
+        GAppInfo *app;
+        GdkAppLaunchContext *context;
+        GError *error;
+
+        error = NULL;
+        context = gdk_app_launch_context_new ();
+        app = g_app_info_create_from_commandline ("gnome-control-center sound", "Sound preferences", 0, &error);
+        if (app)
+                g_app_info_launch (app, NULL, G_APP_LAUNCH_CONTEXT (context), &error);
+
+        if (error != NULL) {
+                GtkWidget *dialog;
+
+                dialog = gtk_message_dialog_new (NULL,
+                                                 0,
+                                                 GTK_MESSAGE_ERROR,
+                                                 GTK_BUTTONS_CLOSE,
+                                                 _("Failed to start Sound Preferences: %s"),
+                                                 error->message);
+                g_signal_connect (dialog,
+                                  "response",
+                                  G_CALLBACK (gtk_widget_destroy),
+                                  NULL);
+                gtk_widget_show (dialog);
+                g_error_free (error);
+        }
+
+        g_object_unref (context);
+        g_object_unref (app);
+}
+
+static void
+on_status_icon_popup_menu (GtkStatusIcon       *status_icon,
+                           guint                button,
+                           guint                activate_time,
+                           GvcStreamStatusIcon *icon)
+{
+        GtkWidget *menu;
+        GtkWidget *item;
+        GtkWidget *image;
+
+        menu = gtk_menu_new ();
+
+        item = gtk_check_menu_item_new_with_mnemonic (_("_Mute"));
+        gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item),
+                                        gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream));
+        g_signal_connect (item,
+                          "toggled",
+                          G_CALLBACK (on_menu_mute_toggled),
+                          icon);
+        gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
+
+        item = gtk_image_menu_item_new_with_mnemonic (_("_Sound Preferences"));
+        image = gtk_image_new_from_icon_name ("multimedia-volume-control",
+                                              GTK_ICON_SIZE_MENU);
+        gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), image);
+        g_signal_connect (item,
+                          "activate",
+                          G_CALLBACK (on_menu_activate_open_volume_control),
+                          icon);
+        gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
+
+        gtk_widget_show_all (menu);
+        gtk_menu_popup (GTK_MENU (menu),
+                        NULL,
+                        NULL,
+                        gtk_status_icon_position_menu,
+                        status_icon,
+                        button,
+                        activate_time);
+}
+
+static gboolean
+on_status_icon_scroll_event (GtkStatusIcon       *status_icon,
+                             GdkEventScroll      *event,
+                             GvcStreamStatusIcon *icon)
+{
+        return gvc_channel_bar_scroll (GVC_CHANNEL_BAR (icon->priv->bar), event->direction);
+}
+
+static void
+gvc_icon_release_grab (GvcStreamStatusIcon *icon,
+                         GdkEventButton    *event)
+{
+        GdkDisplay     *display;
+
+        /* ungrab focus */
+        display = gtk_widget_get_display (GTK_WIDGET (icon->priv->dock));
+        gdk_display_keyboard_ungrab (display, event->time);
+        gdk_display_pointer_ungrab (display, event->time);
+        gtk_grab_remove (icon->priv->dock);
+
+        /* hide again */
+        gtk_widget_hide (icon->priv->dock);
+}
+
+static gboolean
+on_dock_button_press (GtkWidget      *widget,
+                      GdkEventButton *event,
+                      GvcStreamStatusIcon      *icon)
+{
+        if (event->type == GDK_BUTTON_PRESS) {
+                gvc_icon_release_grab (icon, event);
+                return TRUE;
+        }
+
+        return FALSE;
+}
+
+static void
+popdown_dock (GvcStreamStatusIcon *icon)
+{
+        GdkDisplay *display;
+
+        /* ungrab focus */
+        display = gtk_widget_get_display (icon->priv->dock);
+        gdk_display_keyboard_ungrab (display, GDK_CURRENT_TIME);
+        gdk_display_pointer_ungrab (display, GDK_CURRENT_TIME);
+        gtk_grab_remove (icon->priv->dock);
+
+        /* hide again */
+        gtk_widget_hide (icon->priv->dock);
+}
+
+static gboolean
+on_dock_key_release (GtkWidget           *widget,
+                     GdkEventKey         *event,
+                     GvcStreamStatusIcon *icon)
+{
+        if (event->keyval == GDK_KEY_Escape) {
+                popdown_dock (icon);
+                return TRUE;
+        }
+
+#if 0
+        if (!gtk_bindings_activate_event (GTK_OBJECT (widget), event)) {
+                /* The popup hasn't managed the event, pass onto the button */
+                gtk_bindings_activate_event (GTK_OBJECT (user_data), event);
+        }
+#endif
+        return TRUE;
+}
+
+static gboolean
+on_dock_scroll_event (GtkWidget           *widget,
+                      GdkEventScroll      *event,
+                      GvcStreamStatusIcon *icon)
+{
+        /* Forward event to the status icon */
+        on_status_icon_scroll_event (NULL, event, icon);
+        return TRUE;
+}
+
+static void
+update_icon (GvcStreamStatusIcon *icon)
+{
+        guint    volume;
+        gboolean is_muted;
+        guint    n;
+        char    *markup;
+        gboolean can_decibel;
+        gdouble  db;
+
+        if (icon->priv->mixer_stream == NULL) {
+                return;
+        }
+
+        volume = gvc_mixer_stream_get_volume (icon->priv->mixer_stream);
+        is_muted = gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream);
+        db = gvc_mixer_stream_get_decibel (icon->priv->mixer_stream);
+        can_decibel = gvc_mixer_stream_get_can_decibel (icon->priv->mixer_stream);
+
+        /* select image */
+        if (volume <= 0 || is_muted) {
+                n = 0;
+        } else {
+                n = 3 * volume / PA_VOLUME_NORM + 1;
+                if (n < 1) {
+                        n = 1;
+                } else if (n > 3) {
+                        n = 3;
+                }
+        }
+
+        /* apparently status icon will reset icon even if
+         * if doesn't change */
+        if (icon->priv->current_icon != n) {
+                gtk_status_icon_set_from_icon_name (GTK_STATUS_ICON (icon),
+                                                    icon->priv->icon_names [n]);
+                icon->priv->current_icon = n;
+        }
+
+
+        if (is_muted) {
+                markup = g_strdup_printf (
+                                          "<b>%s: %s</b>\n<small>%s</small>",
+                                          icon->priv->display_name,
+                                          _("Muted"),
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        } else if (can_decibel && (db > PA_DECIBEL_MININFTY)) {
+                markup = g_strdup_printf (
+                                          "<b>%s: %.0f%%</b>\n<small>%0.2f dB\n%s</small>",
+                                          icon->priv->display_name,
+                                          100 * (float)volume / PA_VOLUME_NORM,
+                                          db,
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        } else if (can_decibel) {
+                markup = g_strdup_printf (
+                                          "<b>%s: %.0f%%</b>\n<small>-&#8734; dB\n%s</small>",
+                                          icon->priv->display_name,
+                                          100 * (float)volume / PA_VOLUME_NORM,
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        } else {
+                markup = g_strdup_printf (
+                                          "<b>%s: %.0f%%</b>\n<small>%s</small>",
+                                          icon->priv->display_name,
+                                          100 * (float)volume / PA_VOLUME_NORM,
+                                          gvc_mixer_stream_get_description (icon->priv->mixer_stream));
+        }
+        gtk_status_icon_set_tooltip_markup (GTK_STATUS_ICON (icon), markup);
+        g_free (markup);
+}
+
+void
+gvc_stream_status_icon_set_icon_names (GvcStreamStatusIcon  *icon,
+                                       const char          **names)
+{
+        g_return_if_fail (GVC_IS_STREAM_STATUS_ICON (icon));
+
+        g_strfreev (icon->priv->icon_names);
+        icon->priv->icon_names = g_strdupv ((char **)names);
+        update_icon (icon);
+        g_object_notify (G_OBJECT (icon), "icon-names");
+}
+
+static void
+on_stream_volume_notify (GObject             *object,
+                         GParamSpec          *pspec,
+                         GvcStreamStatusIcon *icon)
+{
+        update_icon (icon);
+        update_dock (icon);
+}
+
+static void
+on_stream_is_muted_notify (GObject             *object,
+                           GParamSpec          *pspec,
+                           GvcStreamStatusIcon *icon)
+{
+        update_icon (icon);
+        update_dock (icon);
+}
+
+void
+gvc_stream_status_icon_set_display_name (GvcStreamStatusIcon *icon,
+                                         const char          *name)
+{
+        g_return_if_fail (GVC_STREAM_STATUS_ICON (icon));
+
+        g_free (icon->priv->display_name);
+        icon->priv->display_name = g_strdup (name);
+        update_icon (icon);
+        g_object_notify (G_OBJECT (icon), "display-name");
+}
+
+void
+gvc_stream_status_icon_set_mixer_stream (GvcStreamStatusIcon *icon,
+                                         GvcMixerStream      *stream)
+{
+        g_return_if_fail (GVC_STREAM_STATUS_ICON (icon));
+
+        if (stream != NULL) {
+                g_object_ref (stream);
+        }
+
+        if (icon->priv->mixer_stream != NULL) {
+                g_signal_handlers_disconnect_by_func (icon->priv->mixer_stream,
+                                                      G_CALLBACK (on_stream_volume_notify),
+                                                      icon);
+                g_signal_handlers_disconnect_by_func (icon->priv->mixer_stream,
+                                                      G_CALLBACK (on_stream_is_muted_notify),
+                                                      icon);
+                g_object_unref (icon->priv->mixer_stream);
+                icon->priv->mixer_stream = NULL;
+        }
+
+        icon->priv->mixer_stream = stream;
+
+        if (icon->priv->mixer_stream != NULL) {
+                GtkAdjustment *adj;
+
+                g_object_ref (icon->priv->mixer_stream);
+
+                icon->priv->thaw = TRUE;
+                adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (icon->priv->bar)));
+                gtk_adjustment_set_value (adj,
+                                          gvc_mixer_stream_get_volume (icon->priv->mixer_stream));
+                icon->priv->thaw = FALSE;
+
+                g_signal_connect (icon->priv->mixer_stream,
+                                  "notify::volume",
+                                  G_CALLBACK (on_stream_volume_notify),
+                                  icon);
+                g_signal_connect (icon->priv->mixer_stream,
+                                  "notify::is-muted",
+                                  G_CALLBACK (on_stream_is_muted_notify),
+                                  icon);
+        }
+
+        update_icon (icon);
+
+        g_object_notify (G_OBJECT (icon), "mixer-stream");
+}
+
+static void
+gvc_stream_status_icon_set_property (GObject       *object,
+                                     guint          prop_id,
+                                     const GValue  *value,
+                                     GParamSpec    *pspec)
+{
+        GvcStreamStatusIcon *self = GVC_STREAM_STATUS_ICON (object);
+
+        switch (prop_id) {
+        case PROP_MIXER_STREAM:
+                gvc_stream_status_icon_set_mixer_stream (self, g_value_get_object (value));
+                break;
+        case PROP_DISPLAY_NAME:
+                gvc_stream_status_icon_set_display_name (self, g_value_get_string (value));
+                break;
+        case PROP_ICON_NAMES:
+                gvc_stream_status_icon_set_icon_names (self, g_value_get_boxed (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gvc_stream_status_icon_get_property (GObject     *object,
+                                     guint        prop_id,
+                                     GValue      *value,
+                                     GParamSpec  *pspec)
+{
+        GvcStreamStatusIcon *self = GVC_STREAM_STATUS_ICON (object);
+        GvcStreamStatusIconPrivate *priv = self->priv;
+
+        switch (prop_id) {
+        case PROP_MIXER_STREAM:
+                g_value_set_object (value, priv->mixer_stream);
+                break;
+        case PROP_DISPLAY_NAME:
+                g_value_set_string (value, priv->display_name);
+                break;
+        case PROP_ICON_NAMES:
+                g_value_set_boxed (value, priv->icon_names);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+on_bar_is_muted_notify (GObject             *object,
+                        GParamSpec          *pspec,
+                        GvcStreamStatusIcon *icon)
+{
+        gboolean is_muted;
+
+        is_muted = gvc_channel_bar_get_is_muted (GVC_CHANNEL_BAR (object));
+
+        if (gvc_mixer_stream_get_is_muted (icon->priv->mixer_stream) != is_muted) {
+                /* Update the stream before pushing the change */
+                gvc_mixer_stream_set_is_muted (icon->priv->mixer_stream, is_muted);
+                gvc_mixer_stream_change_is_muted (icon->priv->mixer_stream,
+                                                  is_muted);
+        }
+}
+
+static GObject *
+gvc_stream_status_icon_constructor (GType                  type,
+                                    guint                  n_construct_properties,
+                                    GObjectConstructParam *construct_params)
+{
+        GObject             *object;
+        GvcStreamStatusIcon *icon;
+        GtkWidget           *frame;
+        GtkWidget           *box;
+        GtkAdjustment       *adj;
+
+        object = G_OBJECT_CLASS (gvc_stream_status_icon_parent_class)->constructor (type, n_construct_properties, construct_params);
+
+        icon = GVC_STREAM_STATUS_ICON (object);
+
+        gtk_status_icon_set_from_icon_name (GTK_STATUS_ICON (icon),
+                                            icon->priv->icon_names[0]);
+
+        /* window */
+        icon->priv->dock = gtk_window_new (GTK_WINDOW_POPUP);
+        gtk_widget_set_name (icon->priv->dock, "gvc-stream-status-icon-popup-window");
+        g_signal_connect (icon->priv->dock,
+                          "button-press-event",
+                          G_CALLBACK (on_dock_button_press),
+                          icon);
+        g_signal_connect (icon->priv->dock,
+                          "key-release-event",
+                          G_CALLBACK (on_dock_key_release),
+                          icon);
+        g_signal_connect (icon->priv->dock,
+                          "scroll-event",
+                          G_CALLBACK (on_dock_scroll_event),
+                          icon);
+
+        gtk_window_set_decorated (GTK_WINDOW (icon->priv->dock), FALSE);
+
+        frame = gtk_frame_new (NULL);
+        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_OUT);
+        gtk_container_add (GTK_CONTAINER (icon->priv->dock), frame);
+
+        box = gtk_vbox_new (FALSE, 6);
+        gtk_container_set_border_width (GTK_CONTAINER (box), 2);
+        gtk_container_add (GTK_CONTAINER (frame), box);
+
+        icon->priv->bar = gvc_channel_bar_new ();
+        gvc_channel_bar_set_orientation (GVC_CHANNEL_BAR (icon->priv->bar),
+                                         GTK_ORIENTATION_VERTICAL);
+
+        gtk_box_pack_start (GTK_BOX (box), icon->priv->bar, TRUE, FALSE, 0);
+        g_signal_connect (icon->priv->bar,
+                          "notify::is-muted",
+                          G_CALLBACK (on_bar_is_muted_notify),
+                          icon);
+
+        adj = GTK_ADJUSTMENT (gvc_channel_bar_get_adjustment (GVC_CHANNEL_BAR (icon->priv->bar)));
+        g_signal_connect (adj,
+                          "value-changed",
+                          G_CALLBACK (on_adjustment_value_changed),
+                          icon);
+
+        return object;
+}
+
+static void
+gvc_stream_status_icon_dispose (GObject *object)
+{
+        GvcStreamStatusIcon *icon = GVC_STREAM_STATUS_ICON (object);
+
+        if (icon->priv->dock != NULL) {
+                gtk_widget_destroy (icon->priv->dock);
+                icon->priv->dock = NULL;
+        }
+
+        if (icon->priv->mixer_stream != NULL) {
+                g_object_unref (icon->priv->mixer_stream);
+                icon->priv->mixer_stream = NULL;
+        }
+
+        G_OBJECT_CLASS (gvc_stream_status_icon_parent_class)->dispose (object);
+}
+
+static void
+gvc_stream_status_icon_class_init (GvcStreamStatusIconClass *klass)
+{
+        GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->constructor = gvc_stream_status_icon_constructor;
+        object_class->finalize = gvc_stream_status_icon_finalize;
+        object_class->dispose = gvc_stream_status_icon_dispose;
+        object_class->set_property = gvc_stream_status_icon_set_property;
+        object_class->get_property = gvc_stream_status_icon_get_property;
+
+        g_object_class_install_property (object_class,
+                                         PROP_MIXER_STREAM,
+                                         g_param_spec_object ("mixer-stream",
+                                                              "mixer stream",
+                                                              "mixer stream",
+                                                              GVC_TYPE_MIXER_STREAM,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_DISPLAY_NAME,
+                                         g_param_spec_string ("display-name",
+                                                              "Display Name",
+                                                              "Name to display for this stream",
+                                                              NULL,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+        g_object_class_install_property (object_class,
+                                         PROP_ICON_NAMES,
+                                         g_param_spec_boxed ("icon-names",
+                                                             "Icon Names",
+                                                             "Name of icon to display for this stream",
+                                                              G_TYPE_STRV,
+                                                              G_PARAM_READWRITE|G_PARAM_CONSTRUCT));
+
+        g_type_class_add_private (klass, sizeof (GvcStreamStatusIconPrivate));
+}
+
+static void
+on_status_icon_visible_notify (GvcStreamStatusIcon *icon)
+{
+        gboolean visible;
+
+        g_object_get (icon, "visible", &visible, NULL);
+        if (! visible) {
+                if (icon->priv->dock != NULL) {
+                        gtk_widget_hide (icon->priv->dock);
+                }
+        }
+}
+
+static void
+gvc_stream_status_icon_init (GvcStreamStatusIcon *icon)
+{
+        icon->priv = GVC_STREAM_STATUS_ICON_GET_PRIVATE (icon);
+
+        g_signal_connect (icon,
+                          "activate",
+                          G_CALLBACK (on_status_icon_activate),
+                          icon);
+        g_signal_connect (icon,
+                          "popup-menu",
+                          G_CALLBACK (on_status_icon_popup_menu),
+                          icon);
+        g_signal_connect (icon,
+                          "scroll-event",
+                          G_CALLBACK (on_status_icon_scroll_event),
+                          icon);
+        g_signal_connect (icon,
+                          "notify::visible",
+                          G_CALLBACK (on_status_icon_visible_notify),
+                          NULL);
+
+        icon->priv->thaw = FALSE;
+}
+
+static void
+gvc_stream_status_icon_finalize (GObject *object)
+{
+        GvcStreamStatusIcon *stream_status_icon;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GVC_IS_STREAM_STATUS_ICON (object));
+
+        stream_status_icon = GVC_STREAM_STATUS_ICON (object);
+
+        g_return_if_fail (stream_status_icon->priv != NULL);
+
+        g_strfreev (stream_status_icon->priv->icon_names);
+
+        G_OBJECT_CLASS (gvc_stream_status_icon_parent_class)->finalize (object);
+}
+
+GvcStreamStatusIcon *
+gvc_stream_status_icon_new (GvcMixerStream *stream,
+                            const char    **icon_names)
+{
+        GObject *icon;
+        icon = g_object_new (GVC_TYPE_STREAM_STATUS_ICON,
+                             "mixer-stream", stream,
+                             "icon-names", icon_names,
+                             NULL);
+        return GVC_STREAM_STATUS_ICON (icon);
+}
Index: gnome-control-center/panels/sound-nua/gvc-stream-status-icon.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/gvc-stream-status-icon.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,63 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GVC_STREAM_STATUS_ICON_H
+#define __GVC_STREAM_STATUS_ICON_H
+
+#include <glib-object.h>
+#include "gvc-mixer-stream.h"
+
+G_BEGIN_DECLS
+
+#define GVC_TYPE_STREAM_STATUS_ICON         (gvc_stream_status_icon_get_type ())
+#define GVC_STREAM_STATUS_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIcon))
+#define GVC_STREAM_STATUS_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIconClass))
+#define GVC_IS_STREAM_STATUS_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GVC_TYPE_STREAM_STATUS_ICON))
+#define GVC_IS_STREAM_STATUS_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GVC_TYPE_STREAM_STATUS_ICON))
+#define GVC_STREAM_STATUS_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GVC_TYPE_STREAM_STATUS_ICON, GvcStreamStatusIconClass))
+
+typedef struct GvcStreamStatusIconPrivate GvcStreamStatusIconPrivate;
+
+typedef struct
+{
+        GtkStatusIcon               parent;
+        GvcStreamStatusIconPrivate *priv;
+} GvcStreamStatusIcon;
+
+typedef struct
+{
+        GtkStatusIconClass          parent_class;
+} GvcStreamStatusIconClass;
+
+GType                 gvc_stream_status_icon_get_type            (void);
+
+GvcStreamStatusIcon * gvc_stream_status_icon_new                 (GvcMixerStream      *stream,
+                                                                  const char         **icon_names);
+
+void                  gvc_stream_status_icon_set_icon_names      (GvcStreamStatusIcon *icon,
+                                                                  const char         **icon_names);
+void                  gvc_stream_status_icon_set_display_name    (GvcStreamStatusIcon *icon,
+                                                                  const char          *display_name);
+void                  gvc_stream_status_icon_set_mixer_stream    (GvcStreamStatusIcon *icon,
+                                                                  GvcMixerStream      *stream);
+
+G_END_DECLS
+
+#endif /* __GVC_STREAM_STATUS_ICON_H */
Index: gnome-control-center/panels/sound-nua/sound-theme-file-utils.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/sound-theme-file-utils.c	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,305 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ * Copyright (C) 2008 Bastien Nocera <hadess@hadess.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <config.h>
+#include <glib/gstdio.h>
+#include <glib/gi18n-lib.h>
+#include <gio/gio.h>
+#include <utime.h>
+#include <strings.h>
+
+#include "sound-theme-file-utils.h"
+
+#define CUSTOM_THEME_NAME       "__custom"
+
+/* This function needs to be called after each individual
+ * changeset to the theme */
+void
+custom_theme_update_time (void)
+{
+        char *path;
+
+        path = custom_theme_dir_path (NULL);
+        utime (path, NULL);
+        g_free (path);
+}
+
+char *
+custom_theme_dir_path (const char *child)
+{
+        static char *dir = NULL;
+        const char *data_dir;
+
+        if (dir == NULL) {
+                data_dir = g_get_user_data_dir ();
+                dir = g_build_filename (data_dir, "sounds", CUSTOM_THEME_NAME, NULL);
+        }
+        if (child == NULL)
+                return g_strdup (dir);
+
+        return g_build_filename (dir, child, NULL);
+}
+
+static gboolean
+directory_delete_recursive (GFile *directory, GError **error)
+{
+        GFileEnumerator *enumerator;
+        GFileInfo *info;
+        gboolean success = TRUE;
+
+        enumerator = g_file_enumerate_children (directory,
+                                                G_FILE_ATTRIBUTE_STANDARD_NAME ","
+                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,
+                                                G_FILE_QUERY_INFO_NONE,
+                                                NULL, error);
+        if (enumerator == NULL)
+                return FALSE;
+
+        while (success &&
+               (info = g_file_enumerator_next_file (enumerator, NULL, NULL))) {
+                GFile *child;
+
+                child = g_file_get_child (directory, g_file_info_get_name (info));
+
+                if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY) {
+                        success = directory_delete_recursive (child, error);
+                }
+                g_object_unref (info);
+
+                if (success)
+                        success = g_file_delete (child, NULL, error);
+        }
+        g_file_enumerator_close (enumerator, NULL, NULL);
+
+        if (success)
+                success = g_file_delete (directory, NULL, error);
+
+        return success;
+}
+
+/**
+ * capplet_file_delete_recursive :
+ * @file :
+ * @error  :
+ *
+ * A utility routine to delete files and/or directories,
+ * including non-empty directories.
+ **/
+static gboolean
+capplet_file_delete_recursive (GFile *file, GError **error)
+{
+        GFileInfo *info;
+        GFileType type;
+
+        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+        info = g_file_query_info (file,
+                                  G_FILE_ATTRIBUTE_STANDARD_TYPE,
+                                  G_FILE_QUERY_INFO_NONE,
+                                  NULL, error);
+        if (info == NULL)
+                return FALSE;
+
+        type = g_file_info_get_file_type (info);
+        g_object_unref (info);
+
+        if (type == G_FILE_TYPE_DIRECTORY)
+                return directory_delete_recursive (file, error);
+        else
+                return g_file_delete (file, NULL, error);
+}
+
+void
+delete_custom_theme_dir (void)
+{
+        char *dir;
+        GFile *file;
+
+        dir = custom_theme_dir_path (NULL);
+        file = g_file_new_for_path (dir);
+        g_free (dir);
+        capplet_file_delete_recursive (file, NULL);
+        g_object_unref (file);
+
+        g_debug ("deleted the custom theme dir");
+}
+
+gboolean
+custom_theme_dir_is_empty (void)
+{
+        char            *dir;
+        GFile           *file;
+        gboolean         is_empty;
+        GFileEnumerator *enumerator;
+        GFileInfo       *info;
+        GError          *error = NULL;
+
+        dir = custom_theme_dir_path (NULL);
+        file = g_file_new_for_path (dir);
+        g_free (dir);
+
+        is_empty = TRUE;
+
+        enumerator = g_file_enumerate_children (file,
+                                                G_FILE_ATTRIBUTE_STANDARD_NAME ","
+                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,
+                                                G_FILE_QUERY_INFO_NONE,
+                                                NULL, &error);
+        if (enumerator == NULL) {
+                g_warning ("Unable to enumerate files: %s", error->message);
+                g_error_free (error);
+                goto out;
+        }
+
+        while (is_empty &&
+               (info = g_file_enumerator_next_file (enumerator, NULL, NULL))) {
+
+                if (strcmp ("index.theme", g_file_info_get_name (info)) != 0) {
+                        is_empty = FALSE;
+                }
+
+                g_object_unref (info);
+        }
+        g_file_enumerator_close (enumerator, NULL, NULL);
+
+ out:
+        g_object_unref (file);
+
+        return is_empty;
+}
+
+static void
+delete_one_file (const char *sound_name, const char *pattern)
+{
+        GFile *file;
+        char *name, *filename;
+
+        name = g_strdup_printf (pattern, sound_name);
+        filename = custom_theme_dir_path (name);
+        g_free (name);
+        file = g_file_new_for_path (filename);
+        g_free (filename);
+        capplet_file_delete_recursive (file, NULL);
+        g_object_unref (file);
+}
+
+void
+delete_old_files (const char **sounds)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++) {
+                delete_one_file (sounds[i], "%s.ogg");
+        }
+}
+
+void
+delete_disabled_files (const char **sounds)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++)
+                delete_one_file (sounds[i], "%s.disabled");
+}
+
+static void
+create_one_file (GFile *file)
+{
+        GFileOutputStream* stream;
+
+        stream = g_file_create (file, G_FILE_CREATE_NONE, NULL, NULL);
+        if (stream != NULL) {
+                g_output_stream_close (G_OUTPUT_STREAM (stream), NULL, NULL);
+                g_object_unref (stream);
+        }
+}
+
+void
+add_disabled_file (const char **sounds)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++) {
+                GFile *file;
+                char *name, *filename;
+
+                name = g_strdup_printf ("%s.disabled", sounds[i]);
+                filename = custom_theme_dir_path (name);
+                g_free (name);
+                file = g_file_new_for_path (filename);
+                g_free (filename);
+
+                create_one_file (file);
+                g_object_unref (file);
+        }
+}
+
+void
+add_custom_file (const char **sounds, const char *filename)
+{
+        guint i;
+
+        for (i = 0; sounds[i] != NULL; i++) {
+                GFile *file;
+                char *name, *path;
+
+                /* We use *.ogg because it's the first type of file that
+                 * libcanberra looks at */
+                name = g_strdup_printf ("%s.ogg", sounds[i]);
+                path = custom_theme_dir_path (name);
+                g_free (name);
+                /* In case there's already a link there, delete it */
+                g_unlink (path);
+                file = g_file_new_for_path (path);
+                g_free (path);
+
+                /* Create the link */
+                g_file_make_symbolic_link (file, filename, NULL, NULL);
+                g_object_unref (file);
+        }
+}
+
+void
+create_custom_theme (const char *parent)
+{
+        GKeyFile *keyfile;
+        char     *data;
+        char     *path;
+
+        /* Create the custom directory */
+        path = custom_theme_dir_path (NULL);
+        g_mkdir_with_parents (path, 0755);
+        g_free (path);
+
+        /* Set the data for index.theme */
+        keyfile = g_key_file_new ();
+        g_key_file_set_string (keyfile, "Sound Theme", "Name", _("Custom"));
+        g_key_file_set_string (keyfile, "Sound Theme", "Inherits", parent);
+        g_key_file_set_string (keyfile, "Sound Theme", "Directories", ".");
+        data = g_key_file_to_data (keyfile, NULL, NULL);
+        g_key_file_free (keyfile);
+
+        /* Save the index.theme */
+        path = custom_theme_dir_path ("index.theme");
+        g_file_set_contents (path, data, -1, NULL);
+        g_free (path);
+        g_free (data);
+
+        custom_theme_update_time ();
+}
Index: gnome-control-center/panels/sound-nua/sound-theme-file-utils.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center/panels/sound-nua/sound-theme-file-utils.h	2012-02-10 14:39:56.993601000 -0500
@@ -0,0 +1,37 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ * Copyright (C) 2008 Bastien Nocera <hadess@hadess.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+#ifndef __SOUND_THEME_FILE_UTILS_HH__
+#define __SOUND_THEME_FILE_UTILS_HH__
+
+#include <gio/gio.h>
+
+char *custom_theme_dir_path (const char *child);
+gboolean custom_theme_dir_is_empty (void);
+void create_custom_theme (const char *parent);
+
+void delete_custom_theme_dir (void);
+void delete_old_files (const char **sounds);
+void delete_disabled_files (const char **sounds);
+
+void add_disabled_file (const char **sounds);
+void add_custom_file (const char **sounds, const char *filename);
+
+void custom_theme_update_time (void);
+
+#endif /* __SOUND_THEME_FILE_UTILS_HH__ */
Index: gnome-control-center/panels/sound/data/gnome-sound-panel.desktop.in.in
===================================================================
--- gnome-control-center.orig/panels/sound/data/gnome-sound-panel.desktop.in.in	2012-02-10 14:39:56.993601000 -0500
+++ gnome-control-center/panels/sound/data/gnome-sound-panel.desktop.in.in	2012-02-10 14:39:56.993601000 -0500
@@ -7,7 +7,7 @@
 Type=Application
 StartupNotify=true
 Categories=GNOME;GTK;Settings;HardwareSettings;X-GNOME-Settings-Panel;
-OnlyShowIn=GNOME;Unity;
+OnlyShowIn=GNOME;
 X-GNOME-Bugzilla-Bugzilla=GNOME
 X-GNOME-Bugzilla-Product=gnome-control-center
 X-GNOME-Bugzilla-Component=sound
